input AcceptFriendRequestInput {
  targetID: ID!
}

type AcceptFriendRequestPayload {
  user: User
}

type AcceptOrganizationInviteError {
  code: AcceptOrganizationInviteErrorCode!
}

enum AcceptOrganizationInviteErrorCode {
  INTERNAL_ERROR
  INVALID_ARGUMENT
  NOT_FOUND
  PERMISSION_DENIED
  MEMBER_INELIGIBLE
  ALREADY_EXISTS
  EXCEEDS_MEMBERSHIP_LIMIT
}

input AcceptOrganizationInviteInput {
  firstName: String!
  lastName: String!
  organizationInviteID: ID!
  title: String!
}

type AcceptOrganizationInvitePayload {
  error: AcceptOrganizationInviteError
}

enum AcceptProgramAgreementError {
  UNAUTHENTICATED
  FORBIDDEN
  NOT_FOUND
  INVALID_AGREEMENT_VERSION
  INTERNAL_ERROR
}

input AcceptProgramAgreementInput {
  targetUserID: ID!
  type: PayoutOnboardingCategory!
  version: String!
}

type AcceptProgramAgreementPayload {
  error: AcceptProgramAgreementError
  workflow: PayoutOnboardingWorkflow
}

type AcceptSquadStreamInvitationError {
  code: AcceptSquadStreamInvitationErrorCode!
}

enum AcceptSquadStreamInvitationErrorCode {
  INVITATION_NOT_FOUND
  SQUAD_NOT_FOUND
  UNAUTHORIZED
  INVITATION_CANNOT_BE_ACCEPTED
  USER_CANNOT_ACCESS_SQUADS
}

input AcceptSquadStreamInvitationInput {
  invitationID: ID!
}

type AcceptSquadStreamInvitationPayload {
  error: AcceptSquadStreamInvitationError
  invitation: SquadStreamInvitation
}

type AccountConnectionSet {
  blizzard: UserBlizzardConnectionLink
  facebook: UserFacebookConnectionLink
  hasConnectedAmazon: Boolean
  riot: UserRiotConnectionLink
  steam: UserSteamConnectionLink
  twitter: UserTwitterConnectionLink
  youtube: UserYoutubeConnectionLink
}

type AcknowledgePredictionResultError {
  code: AcknowledgePredictionResultErrorCode!
}

enum AcknowledgePredictionResultErrorCode {
  FORBIDDEN
  NOT_FOUND
  NOT_RESOLVED
  UNKNOWN
}

input AcknowledgePredictionResultInput {
  id: ID!
}

type AcknowledgePredictionResultPayload {
  error: AcknowledgePredictionResultError
  prediction: Prediction
}

input AcknowledgeSubscriptionStateInput {
  subscriptionID: ID!
}

type AcknowledgeSubscriptionStatePayload {
  state: UnacknowledgedSubscriptionEventState
}

input AcknowledgeUnbanRequestInput {
  id: ID!
}

type AcknowledgeUnbanRequestPayload {
  error: UnbanRequestError
  unbanRequest: UnbanRequest
}

input ActivateExtensionInput {
  anchor: ExtensionAnchor!
  extensionInstallationID: ID!
  slot: String!
}

type ActivateExtensionPayload {
  installedExtensions: [ExtensionInstallation!]!
}

enum ActivationState {
  ACTIVE
  INACTIVE
  REJECTED_PERMISSIONS
}

interface Activity {
  type: ActivityType
}

input ActivityInput {
  gameID: String
  type: ActivityType
  userID: String
}

enum ActivityType {
  PLAYING
  STREAMING
  WATCHING
}

type ADASProperties {
  partner: String @deprecated(reason: "No longer needed.")
  programID: ID @deprecated(reason: "No longer needed.")
}

type AdContentMetadata {
  contentRating: String
  categoryProperties: CategoryProperties
}

type AdContext {
  declineState: AdContextDeclineState!
  id: ID!
  radToken: String!
}

type AdContextDeclineState {
  reason: String
  shouldDecline: Boolean!
}

type AdCreative {
  id: ID!
  integratedLoudness: Float @deprecated
}

input AddAutohostChannelsInput {
  channelIDs: [ID!]!
  userID: ID!
}

type AddAutohostChannelsPayload {
  user: User
}

input AddBrowserPushSubscriptionInput {
  auth: String!
  endpoint: String!
  p256DH: String!
}

type AddBrowserPushSubscriptionPayload {
  browserPushSubscriptionID: ID
}

enum AddChannelBlockedTermError {
  NO_PERMISSIONS
  DURATION_INVALID
  TERM_TOO_SHORT
  UNKNOWN_ERROR
}

input AddChannelBlockedTermInput {
  channelID: ID!
  isModEditable: Boolean!
  phrase: String!
  phrases: [String!] = []
}

type AddChannelBlockedTermPayload {
  term: ChannelBlockedTerm
  wasRemovedFromPermittedList: Boolean
  error: AddChannelBlockedTermError
  addedAt: Time
    @deprecated(
      reason: "Use the term field for information about the newly added term"
    )
  phrases: [String!]!
    @deprecated(
      reason: "Use the term field for information about the newly added term"
    )
}

enum AddChannelPermittedTermError {
  NO_PERMISSIONS
  DURATION_INVALID
  TERM_TOO_SHORT
  UNKNOWN_ERROR
}

input AddChannelPermittedTermInput {
  channelID: ID!
  phrase: String!
  phrases: [String!] = []
}

type AddChannelPermittedTermPayload {
  term: ChannelPermittedTerm
  wasRemovedFromBlockedList: Boolean
  error: AddChannelPermittedTermError
  addedAt: Time
    @deprecated(
      reason: "Use the term field for information about the newly added term"
    )
  phrases: [String!]!
    @deprecated(
      reason: "Use the term field for information about the newly added term"
    )
}

input AddCollectionItemInput {
  collectionID: ID!
  itemID: ID!
  itemType: String!
}

type AddCollectionItemPayload {
  collection: Collection
}

input AddCompetitionPhaseInput {
  competitionID: ID!
}

type AddCompetitionPhasePayload {
  competition: Competition
  error: CompetitionError
}

input AddCompetitionPlayerInput {
  competitionID: ID!
  discordUsername: String
  inGameUsername: String
  state: CompetitionPlayerState
  userID: ID!
}

type AddCompetitionPlayerPayload {
  competition: Competition
  error: CompetitionError
}

input AddCompetitionTeamInput {
  captainID: ID
  competitionID: ID!
  members: [ID!]
  name: String!
}

type AddCompetitionTeamPayload {
  competition: Competition
  error: CompetitionError
}

input AddDeviceTokenInput {
  appBuild: String
  deviceID: ID
  deviceName: String
  deviceToken: ID!
  notificationCapabilitiesTypes: [String!]
  onsiteCapabilitiesTypes: [String!]
  platform: String!
  userID: ID
}

type AddDeviceTokenPayload {
  deviceToken: ID!
}

input AddDropToCampaignInput {
  campaignID: ID!
  dropRuleType: DropRuleType!
  endAt: Time
  name: String!
  startAt: Time
}

type AddDropToCampaignPayload {
  drop: DropType
  error: DropsError
}

type AddEditorError {
  code: AddEditorErrorCode!
}

enum AddEditorErrorCode {
  CHANNEL_NOT_FOUND
  TARGET_USER_ALREADY_EDITOR
  TARGET_USER_NOT_FOUND
}

input AddEditorInput {
  channelID: ID!
  targetUserID: ID
  targetUserLogin: String
}

type AddEditorPayload {
  channel: User
  error: AddEditorError
  targetUser: User
}

type AddRadioRecentlyPlayedError {
  code: AddRadioRecentlyPlayedErrorCode!
}

enum AddRadioRecentlyPlayedErrorCode {
  INVALID_ID
  PERMISSION_DENIED
}

input AddRadioRecentlyPlayedInput {
  contentType: RadioRecentlyPlayedType!
  id: ID!
}

type AddRadioRecentlyPlayedPayload {
  error: AddRadioRecentlyPlayedError
  recent: RadioRecentlyPlayed
}

input AddReactionInput {
  emoteID: ID!
  entityID: ID!
}

type AddReactionPayload {
  content: ReactableContent!
}

input AddRecommendationFeedbackInput {
  category: RecommendationFeedbackCategory!
  itemID: ID!
  itemType: RecommendationFeedbackType!
  sourceItemPage: String!
  sourceItemRequestID: ID!
  sourceItemTrackingID: ID!
}

type AddRecommendationFeedbackPayload {
  recommendationFeedback: RecommendationFeedback
}

type AddStreamAuthorizedUserError {
  code: AddStreamAuthorizedUserErrorCode!
}

enum AddStreamAuthorizedUserErrorCode {
  TARGET_USER_UNRETURNABLE
  CHANNEL_NOT_FOUND
  MAX_ACCOUNT_LIMIT
  PERMISSION_DENIED
  INVALID_ARGUMENT
}

input AddStreamAuthorizedUserInput {
  authorizedUserID: ID!
  channelID: ID!
}

type AddStreamAuthorizedUserPayload {
  channel: Channel
  error: AddStreamAuthorizedUserError
}

enum AdPlatform {
  IOS_PHONE
  IOS_TABLET
  ANDROID_PHONE
  ANDROID_TABLET
}

type AdPollVote {
  choiceID: ID!
  id: ID!
  pollID: ID!
  userID: ID!
}

type AdProperties {
  adServer: String @deprecated(reason: "Should use adServerDefault instead")
  adServerDefault: String
  adasProperties: ADASProperties
  costreamers: [User]
  density: Density
  disablePrerollsAbility: DisablePrerollsAbility
  experimentTreatment(bucket: String!): String
  frequency: Int
  hasPostrollsDisabled: Boolean
  hasPrerollsDisabled: Boolean
  hasTurboDisabled: Boolean
  hasVodAdsEnabled: Boolean
  isMultiplayerAdsForSubsEnabled: Boolean
  maxAdBreakLength: Int
  multiplayerAdOffers: [MultiplayerAdOffer!]
  requiredAge: Int
  trackingPixels(consent: GDPRConsent): [TrackingPixel!]
  vodArchiveMidrolls: String
  vodArchiveMidrollsBreakLength: Int
  vodArchiveMidrollsFrequency: Int
}

type AdReminderConfig {
  isEnabled: Boolean!
  seconds: Int!
  maxSeconds: Int!
}

input AdRequestClientContext {
  isAudioOnly: Boolean!
  isMiniTheater: Boolean!
  isPIP: Boolean!
  isUsingExternalPlayback: Boolean!
  clientApp: String
  appVersion: String
}

enum AdRequestContentType {
  LIVE
  VOD
}

input AdRequestContext {
  adSessionID: ID!
  clientContext: AdRequestClientContext!
  commercialID: ID
  duration: Int!
  isVLM: Boolean
  playerContext: AdRequestPlayerContext!
  rollType: AdrollType!
  game: String
  twitchCorrelator: String
  adFormat: String
}

input AdRequestPlayerContext {
  contentType: AdRequestContentType!
  isAutoPlay: Boolean!
  nauthSig: String!
  nauthToken: String!
  videoSessionID: ID
  playerSizeMode: String
  raidID: ID
}

enum AdrollType {
  PREROLL
  MIDROLL
  POSTROLL
}

type AdScheduleConfig {
  desiredSeconds: Int!
  minSeconds: Int!
  maxSeconds: Int!
}

type AdSession {
  id: ID!
  lengthSeconds: Int!
  retryAfterSeconds: Int!
}

type AdSlot {
  durationSeconds: Int!
  runAtTime: Time!
}

type AdSnoozeConfig {
  currentAmount: Int!
  maxAmount: Int!
  refreshAt: Time!
  durationSeconds: Int!
}

enum AffiliateInvitationStatus {
  INCOMPLETE_WORKFLOW
  PENDING_INVITE
  SENT
}

type AggregatedReferrals {
  count: Int!
  name: String!
}

type AllocateKeysForBountyError {
  code: AllocateKeysForBountyErrorCode!
}

enum AllocateKeysForBountyErrorCode {
  INVALID_ARGUMENT
  NOT_FOUND
  UNKNOWN_ERROR
}

input AllocateKeysForBountyInput {
  bountyID: ID!
  userID: ID!
}

type AllocateKeysForBountyPayload {
  bounty: Bounty
  error: AllocateKeysForBountyError
}

input AllowRejectedChatMessageInput {
  id: ID!
}

type AllowRejectedChatMessagePayload {
  message: RejectedChatMessage
}

input AllowRejectedCheerInput {
  id: ID!
  targetUserID: ID!
}

type AllowRejectedCheerPayload {
  id: ID!
}

enum AndroidCurrencyUnits {
  NORMAL_UNITS
  MICRO_UNITS
}

input AndroidPaymentTrackingDataInput {
  deviceID: ID
  locale: String
}

input AndroidReceiptDataInput {
  currency: String!
  price: String!
  rawReceipt: String!
  signedReceipt: String!
  units: AndroidCurrencyUnits!
}

enum AnimatedEmotePreset {
  SHAKE
  ROLL
  SPIN
  RAVE
  SLIDE_IN
  SLIDE_OUT
}

type AnimatedImageAsset {
  id: ID!
  size: EmoteImageSize!
}

input ApplyExtensionActivationsInput {
  activations: [ExtensionActivationInput!]!
  channelID: ID!
}

type ApplyExtensionActivationsPayload {
  installedExtensions: [ExtensionInstallation!]!
}

input ApproveUnbanRequestInput {
  id: ID!
  resolverMessage: String
}

type ApproveUnbanRequestPayload {
  error: UnbanRequestError
  unbanRequest: UnbanRequest
}

input ArchiveChanletInput {
  chanletID: ID!
}

type ArchiveChanletPayload {
  chanlet: Channel!
}

type ArchiveCommunityPointsCommunityGoalError {
  code: ArchiveCommunityPointsCommunityGoalErrorCode!
}

enum ArchiveCommunityPointsCommunityGoalErrorCode {
  NOT_FOUND
  FORBIDDEN
  UNKNOWN
}

input ArchiveCommunityPointsCommunityGoalInput {
  channelID: ID!
  goalID: ID!
}

type ArchiveCommunityPointsCommunityGoalPayload {
  error: ArchiveCommunityPointsCommunityGoalError
  goal: CommunityPointsCommunityGoal
}

input ArchivePollInChannelInput {
  channelID: ID!
}

type ArchivePollInChannelPayload {
  poll: Poll
}

input ArchivePollInput {
  pollID: ID!
}

type ArchivePollPayload {
  poll: Poll
}

enum ArkoseEndpointVersion {
  V1
  V2
}

type AssignEmoteToBitsTierError {
  code: AssignEmoteToBitsTierErrorCode!
}

enum AssignEmoteToBitsTierErrorCode {
  EMOTE_NOT_FOUND
  PERMISSION_DENIED
  EMOTE_LIMIT_REACHED
  INVALID_EMOTE_STATE
  EMOTE_CODE_ALREADY_EXISTS
  EMOTES_NOT_ALLOWED_IN_TIER
  UNKNOWN
}

input AssignEmoteToBitsTierInput {
  channelID: ID!
  emoteID: ID!
  tierThreshold: Int!
}

type AssignEmoteToBitsTierPayload {
  emote: Emote
  error: AssignEmoteToBitsTierError
}

type AssignEmoteToSubscriptionProductError {
  code: AssignEmoteToSubscriptionProductErrorCode!
}

enum AssignEmoteToSubscriptionProductErrorCode {
  EMOTE_NOT_FOUND
  PERMISSION_DENIED
  EMOTE_LIMIT_REACHED
  INVALID_EMOTE_STATE
  EMOTE_CODE_ALREADY_EXISTS
  UNKNOWN
}

input AssignEmoteToSubscriptionProductInput {
  emoteID: ID!
  productID: ID!
}

type AssignEmoteToSubscriptionProductPayload {
  emote: Emote
  error: AssignEmoteToSubscriptionProductError
}

type AssignExtensionBillingManagerError {
  code: AssignExtensionBillingManagerErrorCode!
}

enum AssignExtensionBillingManagerErrorCode {
  FAILED_PRECONDITION
  MEMBER_INELIGIBLE
  PERMISSION_DENIED
}

input AssignExtensionBillingManagerInput {
  extensionID: ID!
  userID: ID!
}

type AssignExtensionBillingManagerPayload {
  error: AssignExtensionBillingManagerError
  extensionClient: ExtensionClient
}

type AssociatesStore {
  ID: ID!
  isPayoutEnabled: Boolean
  storeID: String
}

type AuthenticatedSession {
  clientID: ID!
  createdAt: Time
  deletedAt: Time
  location: String
  userAgent: String
  userID: ID!
}

type AutohostChannelConnection {
  nodes: [User!]
}

type AutohostedByChannelConnection {
  nodes: [User!]
}

type AutohostSettings {
  deprioritizeVodcast: Boolean!
  enabled: Boolean!
  incomingRaidsPolicy: AutohostSettingsIncomingRaidsPolicy!
    @deprecated(reason: "Use User.raidSettings.incomingRaidsPolicy instead.")
  strategy: AutohostSettingsStrategy!
  teamHost: Boolean!
}

enum AutohostSettingsIncomingRaidsPolicy {
  NONE
  NETWORK
  ALL
}

enum AutohostSettingsStrategy {
  ORDERED
  RANDOM
}

type AutoMod {
  topics: [AutoModTopic!]!
}

type AutoModCaughtMessage {
  category: AutoModCaughtMessageCategory!
  id: ID!
  modLogsMessage: ModLogsMessage!
  resolvedAt: Time
  resolver: User
  status: AutoModCaughtMessageStatus!
}

enum AutoModCaughtMessageCategory {
  INVALID
  AGGRESSIVE
  IDENTITY
  PROFANITY
  SEXUAL
  BULLYING
  SEXUALITY_SEX_OR_GENDER
  DISABILITY
  RACE_ETHNICITY_OR_RELIGION
  MISOGYNY
  AGGRESSION
  SEX_BASED_TERMS
  SWEARING
}

enum AutoModCaughtMessageStatus {
  PENDING
  APPROVED
  ALLOWED
  DENIED
  INVALID
  EXPIRED
}

type AutoModConfiguration {
  detailedLevels: DetailedAutoModConfiguration
  overallLevel: Int
}

type AutoModContent {
  failureReasons: [AutoModFailureReason!]
  text: String!
  canPass: Boolean!
  id: ID!
  error: AutoModContentError
}

type AutoModContentError {
  code: AutoModContentErrorCode!
}

enum AutoModContentErrorCode {
  INTERNAL_ERROR
  INVALID_ARGUMENT
  RESOURCE_EXHAUSTED
}

input AutoModContentInput {
  channelID: ID!
  text: String!
  overallLevel: Int
  autoModSettings: DetailedAutoModLevelsInput
}

type AutoModFailureReason {
  normalizedText: String!
  startPosition: Int!
  endPosition: Int!
  topics: DetailedAutoModConfiguration!
}

type AutoModProperties {
  aggressiveLevel: Int!
  identityLevel: Int!
  profanityLevel: Int!
  sexualLevel: Int!
}

type AutoModTopic {
  type: String!
  weight: Int!
}

type AutoRefill {
  actions(paymentProvider: PaymentProvider!): [CheckoutAction!]!
  profiles: [AutoRefillProfile!]!
  xsollaPaymentMethods: [PaymentMethod!]
}

type AutoRefillProfile {
  chargeInstrument: ChargeInstrument
  id: ID!
  isEnabled: Boolean!
  offerID: ID
  threshold: Int!
}

enum Availability {
  AWAY
  BUSY
  IDLE
  OFFLINE
  ONLINE
}

enum AvailabilityInput {
  ONLINE
  IDLE
  OFFLINE
}

enum AVCProfile {
  BASELINE
  MAIN
  HIGH
}

type BackupIngestSession {
  stitchedFrom: [BackupStreamSession!]
  stitchedTo: [BackupStreamSession!]
}

type BackupStreamSession {
  broadcastFormat: BroadcastFormat!
  id: ID!
  stitchedTimeAt: Time!
}

type Badge {
  clickAction: BadgeClickAction
    @deprecated(reason: "Should use onClickAction instead")
  clickURL: String
  description: String!
  id: ID!
  imageURL(size: BadgeImageSize = NORMAL): String!
  onClickAction: BadgeClickAction
  self: BadgeSelfEdge
  setID: ID!
  title: String!
  user: User
  version: String!
}

enum BadgeClickAction {
  SUBSCRIBE
  GET_TURBO
  GET_BITS
  VISIT_URL
}

enum BadgeDomain {
  CRATE
}

enum BadgeImageSize {
  NORMAL
  DOUBLE
  QUADRUPLE
}

type BadgeSelfEdge {
  isVisibleInChatCard: Boolean!
}

enum BadgeTierEmotesFilter {
  ALL
  LOCKED
  LOCKED_PREVIEW
  UNLOCKED
  HIGHEST_UNLOCKED_AND_NEXT
}

type Balance {
  amount: Int!
  currency: Currency!
  expiresAt: Time
  exponent: Int!
}

type BanUserFromChatRoomError {
  code: BanUserFromChatRoomErrorCode!
  maxTimeoutDurationSeconds: Int
  minTimeoutDurationSeconds: Int
}

enum BanUserFromChatRoomErrorCode {
  FORBIDDEN
  TARGET_NOT_FOUND
  TARGET_IS_SELF
  TARGET_IS_ANONYMOUS
  TARGET_IS_MOD
  TARGET_IS_VIP
  TARGET_IS_BROADCASTER
  TARGET_IS_STAFF
  TARGET_IS_ADMIN
  TARGET_IS_GLOBAL_MOD
  TARGET_ALREADY_BANNED
  DURATION_INVALID
}

input BanUserFromChatRoomInput {
  bannedUserLogin: String!
  channelID: ID!
  expiresIn: String
  reason: String
}

type BanUserFromChatRoomPayload {
  ban: ChatRoomBanStatus
  error: BanUserFromChatRoomError
}

input BanVideoCommenterInput {
  channelID: ID!
  commenterID: ID!
}

type BanVideoCommenterPayload {
  user: User
}

input BeginUseBitsInExtensionInput {
  channelID: ID!
  extensionClientID: ID!
  sku: String!
}

type BeginUseBitsInExtensionPayload {
  balance: Int
  bitsRequired: Int
  isPromptRequired: Boolean
  transactionID: ID
}

input BillingAuthInfo {
  recurlyFraudSessionID: ID
  threeDSecureActionResultTokenID: ID
}

type BitsAdOffer implements BitsOffer {
  bits: Int!
  id: ID!
  type: BitsOfferType!
}

type BitsBadgeTier {
  badge: Badge
  canUploadEmoticons: Boolean!
  emoticonUploadConfigurations: [EmoteUploadConfiguration]!
  emoticons: [Emote]!
  isEnabled: Boolean!
  lastUpdated: Time
  threshold: Int!
  unlockedUsersCount: Int!
}

input BitsBadgeTierEmoticonSetting {
  code: String!
  codeSuffix: String!
  imageID1x: String
  imageID2x: String
  imageID4x: String
}

input BitsBadgeTierInput {
  deleteImage: Boolean
  deleteTitle: Boolean
  emoticonSettings: [BitsBadgeTierEmoticonSetting!]
  imageData1x: String
  imageData2x: String
  imageData4x: String
  isEnabled: Boolean
  threshold: Int!
  title: String
}

type BitsBadgeTierNotification {
  canShare: Boolean!
  id: ID!
  threshold: Int!
  unlockedEmoticons: [Emote]!
}

enum BitsBadgeTierNotificationState {
  SKIPPED
  SHARED
  SHOW
}

type BitsBundleOffer implements BitsOffer {
  amount: Float!
  asin: ID!
  bits: Int!
  currencyCode: String!
  discount: Float!
  id: ID!
  includesVAT: Boolean!
  isPromo: Boolean!
  price: String!
    @deprecated(
      reason: "Use the 'amount' field and localize it yourself in conjunction with the 'currencyCode' field"
    )
  promotion: BitsPromotion
  type: BitsOfferType!
  url: String!
}

input BitsChallengeConditionPoolRecipientWeightedShare {
  recipientUserID: ID!
  weight: Int!
}

type BitsEvent {
  amount: Int!
  channel: User
  id: ID!
  type: BitsEventType!
  usedAt: Time!
}

type BitsEventConnection {
  edges: [BitsEventEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input BitsEventConnectionCriteriaInput {
  sortBy: BitsEventSort = DATE
  sortDirection: BitsEventSortDirection = DESC
  type: BitsEventType
  usedAfter: Time
  usedBefore: Time
}

type BitsEventEdge {
  cursor: Cursor!
  node: BitsEvent!
}

enum BitsEventSort {
  AMOUNT
  DATE
}

enum BitsEventSortDirection {
  DESC
  ASC
}

enum BitsEventType {
  GIVE_BITS_TO_BROADCASTER
  USE_BITS_ON_EXTENSION
  USE_BITS_ON_POLL
  UNKNOWN
}

type BitsHashtagConnection {
  edges: [BitsHashtagEdge!]
}

type BitsHashtagEdge {
  cursor: Cursor!
  node: BitsHashtagEntry!
}

type BitsHashtagEntry {
  description: String
  id: ID!
  imageURL: String
}

type BitsKeyCode implements Claimable {
  description: String!
  id: ID!
  self: SelfClaimEdge
  type: ClaimableType!
}

type BitsKeyCodeSelfClaimEdge implements SelfClaimEdge {
  canClaim: Boolean!
  countryOfResidence: String
  id: ID!
  statusCode: String
}

type BitsLeaderboard {
  entries: BitsLeaderboardConnection!
    @deprecated(
      reason: "the ID field is not unique between leaderboards on leaderboard entries. Use leaderboard item."
    )
  id: ID!
  items: BitsLeaderboardItemConnection!
  secondsRemaining: Int!
}

type BitsLeaderboardConnection {
  edges: [BitsLeaderboardEdge]!
}

type BitsLeaderboardEdge {
  cursor: String!
  node: BitsLeaderboardEntry
}

type BitsLeaderboardEntry {
  id: ID!
  rank: Int!
  score: Int!
}

type BitsLeaderboardItem {
  entryKey: String!
  id: ID!
  rank: Int!
  score: Int!
}

type BitsLeaderboardItemConnection {
  edges: [BitsLeaderboardItemEdge]
  pageInfo: PageInfo!
  totalCount: Int
}

type BitsLeaderboardItemEdge {
  cursor: Cursor!
  node: BitsLeaderboardItem
}

type BitsLeaderboardSettings {
  isEnabled: Boolean!
  timePeriodType: LeaderboardTimePeriodType
}

interface BitsOffer {
  bits: Int!
  id: ID!
  type: BitsOfferType!
}

enum BitsOfferType {
  AD
  BUNDLE
}

type BitsPaymentMethods {
  paymentMethods: [BitsPaymentMethodType!]
}

enum BitsPaymentMethodType {
  PAYPAL
  AMAZON_PAY
  XSOLLA
}

type BitsProduct {
  amount: Int!
  id: ID!
  maxQuantity: Int!
  offerID: ID
  promo: BitsProductPromotion
  self: BitsProductSelfEdge
  type: BitsProductType!
  restrictedToCurrencies: [String!]!
}

type BitsProductEligibility {
  canPurchase: Boolean!
  reasonCode: String
}

type BitsProductPromotion {
  id: ID!
  title: String!
  type: String!
}

enum BitsProductProvider {
  AMAZON
  ANDROID
  IOS
  PAYPAL
  XSOLLA
}

type BitsProductPurchaseInfo {
  actions: [CheckoutAction!]!
  error: BitsProductPurchaseInfoError
  previewPriceInfo: PriceInfo
}

type BitsProductPurchaseInfoError {
  code: BitsProductPurchaseInfoErrorCode!
}

enum BitsProductPurchaseInfoErrorCode {
  INTERNAL_SERVER_ERROR
  USER_UNAUTHORIZED
  PRICING_ID_NOT_FOUND
  UNKNOWN_USER_RESIDENCE
  BILLING_INFO_NOT_FOUND
  PURCHASE_INELIGIBLE
}

type BitsProductSelfEdge {
  checkoutConfiguration: CheckoutConfiguration
  eligibility(quantity: Int!): BitsProductEligibility!
  purchaseInfo(
    quantity: Int!
    paymentSession: PaymentSession
  ): BitsProductPurchaseInfo!
}

enum BitsProductType {
  PURCHASED_PRODUCT
  UNKNOWN
}

type BitsPromotion {
  id: ID!
  type: String!
}

type BitsUserSettings {
  firstCheerTutorial: FirstCheerTutorial
}

enum BitsUserState {
  NEW_USER
  ACQUIRED
  SKIPPED
  CHEERED
  UNKNOWN
}

type BlizzardUser {
  battleTag: String!
  id: ID!
  region: String!
}

enum BlockContext {
  WHISPER
  CHAT
}

input BlockUserInput {
  reason: String
  sourceContext: BlockContext
  targetUserID: ID!
}

type BlockUserPayload {
  targetUser: User!
}

type BoostSettings {
  isEarnedEnabled: Boolean
  isEligible: Boolean!
  isEnabled: Boolean
  isPaidEnabled: Boolean
}

type Bounty {
  campaign: BountyCampaign!
  chatCTA: BountyChatCTA
  claimTime: Time
    @deprecated(
      reason: "Replacing with 'claimedAt' for consistency with 'At' suffix"
    )
  claimedAt: Time
  endAt: Time
    @deprecated(
      reason: "Replacing with 'expiresAt' as that is a more descriptive property name for the value."
    )
  endTime: Time
    @deprecated(
      reason: "Replacing with 'trackingStoppedAt' as that is a more descriptive property name for the value."
    )
  expiresAt: Time
  id: ID!
  keys: [BountyProductKey!]
  lastModifiedAt: Time
  maximumPayoutCCU: Int
  maximumPayoutCents: Int!
  minimumPayoutCCU: Int
  moderationMetadata: BountyModerationMetadata
  moderationStatus: BountyModerationStatus
    @deprecated(reason: "Replacing with 'status' within moderationMetadata.")
  payoutCents: Int
  platform: String
  region: String
  restriction: BountyRestriction
  startAt: Time
    @deprecated(
      reason: "Replacing with 'claimTime' as that is a more descriptive property name for the value."
    )
  startTime: Time
    @deprecated(
      reason: "Replacing with 'trackingStartedAt' as that is a more descriptive property name for the value."
    )
  status: BountyStatus!
  trackingStartedAt: Time
  trackingStoppedAt: Time
  videos: [BountyVideo!]
}

type BountyBoardSettings {
  hasNotification: Boolean!
  isEnabled: Boolean! @deprecated(reason: "Use 'status' instead.")
  status: BountyBoardUserStatus!
}

enum BountyBoardUserStatus {
  INVITED
  ACCEPTED
  BANNED
  NONE
}

type BountyCampaign {
  allowedGames: [Game!]
  availablePlatforms: [String!]
  bountyLengthDays: Int!
  boxArtURL: String
  brandDetails: BountyCampaignBrandDetails
  coverURL: String
  details: String!
  displayName: String
  endAt: Time!
    @deprecated(
      reason: "Replacing with 'endTime' as that is a more descriptive property name for the value."
    )
  endTime: Time!
  game: Game
    @deprecated(
      reason: "Replacing with 'allowedGames' as this provides a set of available games instead of a single game"
    )
  id: ID!
  isPromotionEligible: Boolean
  keyDescriptors: [BountyCampaignKeyDescriptor!]
  rejectionReason: String
    @deprecated(reason: "Use 'rejectionReason' in 'brandDetails' instead.")
  shouldAllowAllGames: Boolean
  sponsor: String!
  startAt: Time!
    @deprecated(
      reason: "Replacing with 'startTime' as that is a more descriptive property name for the value."
    )
  startTime: Time!
  status: BountyCampaignStatus
    @deprecated(reason: "Use 'status' in 'brandDetails' instead.")
  streamLengthSeconds: Int
  targetPromotionalVideoClicks: Int
  termsAndConditionsURL: String
  title: String!
  trackingPixels: [TrackingPixel!]
  type: BountyCampaignType!
  videoURL: String @deprecated(reason: "Use 'videos' instead.")
  videos: [BountyCampaignVideo!]
}

type BountyCampaignBrandDetails {
  blacklistedBroadcasters: [User!]
  broadcasterMultiplier: Float
  campaignReporting: BountyCampaignReporting
  chatCTAs: [BountyChatCTA!]
  claimedBountyCount: Int
    @deprecated(
      reason: "Use 'claimedBountyCount' in 'campaignReporting' instead."
    )
  claimedBudgetCents: Int
    @deprecated(
      reason: "Use 'claimedBudgetCents' in 'campaignReporting' instead."
    )
  completedBountyCount: Int
    @deprecated(
      reason: "Use 'completedBountyCount' in 'campaignReporting' instead."
    )
  expandedBountyCount: Int
    @deprecated(
      reason: "Use 'expandedBountyCount' in 'campaignReporting' instead."
    )
  includesAllBroadcasters: Boolean
  includesAllCountries: Boolean!
  includesAllGames: Boolean!
  includesVarietyBroadcasters: Boolean!
  performanceMetrics: [BountyCampaignPerformanceMetric!]
    @deprecated(
      reason: "Use 'performanceMetrics' in 'campaignReporting' instead."
    )
  rejectionReason: String
  spentBudgetCents: Int
  status: BountyCampaignStatus
  targetedCountries: [String!]
  targetedGames: [Game!]
  totalBlockedBroadcasters: Int
  totalBudgetCents: Int
  viewedBountyCount: Int
    @deprecated(
      reason: "Use 'viewedBountyCount' in 'campaignReporting' instead."
    )
}

input BountyCampaignChatCTAInput {
  countryCode: String!
  title: String!
  url: String!
}

type BountyCampaignConnection {
  edges: [BountyCampaignEdge]
  pageInfo: PageInfo!
}

type BountyCampaignEdge {
  cursor: Cursor!
  node: BountyCampaign
}

type BountyCampaignKeyDescriptor {
  platform: String!
  region: String!
}

type BountyCampaignPerformanceMetric {
  chatCTAClickThroughCount: Int
  completedBountyCount: Int!
  endTime: Time!
  minutesWatched: Int!
  startTime: Time!
  thirtySecondViewerCount: Int!
  totalViewerCount: Int!
  twoMinuteViewerCount: Int!
}

type BountyCampaignReporting {
  chatCTAsClicks: Int
  chatCTAsImpressions: Int
  claimedBountyCount: Int
  claimedBudgetCents: Int
  completedBountyCount: Int
  expandedBountyCount: Int
  performanceMetrics: [BountyCampaignPerformanceMetric!]
  spentBudgetCents: Int
  viewedBountyCount: Int
}

enum BountyCampaignStatus {
  PENDING
  APPROVED
  REJECTED
  LIVE
  COMPLETED
}

enum BountyCampaignType {
  PAY_TO_STREAM
  GAME_TRAILER
  MISC_TRAILER
  UNKNOWN
}

enum BountyCampaignUploadType {
  BOX_ART
  COVER
}

type BountyCampaignVideo {
  country: String!
  title: String!
  url: String!
}

input BountyCampaignVideoInput {
  country: String!
  title: String!
  url: String!
}

type BountyChatCTA {
  countryCode: String!
  frequencySeconds: Int!
  initialDelaySeconds: Int!
  title: String!
  url: String!
}

type BountyConnection {
  edges: [BountyEdge!]
  pageInfo: PageInfo!
}

type BountyEdge {
  cursor: Cursor!
  node: Bounty
}

enum BountyKeyProductType {
  COUPON
  DLC
  GAME
  GIFTCARD
  GIVEAWAY
  IGC
  OTHER
}

enum BountyModerationFailReason {
  MINIMUM_TIME_NOT_MET
  INCORRECT_CONTENT
  BADMOUTHING
  OTHER_CONTENT_VISIBLE
  IDLE
  NO_VOD
  OTHER
}

type BountyModerationMetadata {
  reason: BountyModerationFailReason
  status: BountyModerationStatus
  updatedAt: Time
}

enum BountyModerationStatus {
  PASS
  PENDING_REVIEW
  FAIL
}

type BountyProductKey {
  code: String!
  platform: String
  productType: BountyKeyProductType
  region: String
}

type BountyRestriction {
  days: [Int!]
  endTime: Int
  startTime: Int
}

enum BountyStatus {
  AVAILABLE
  LIVE
  COMPLETED
  CANCELLED
}

type BountyVideo {
  title: String!
  url: String!
}

type BrandPortalSettings {
  canAccessAllGames: Boolean!
  isEnabled: Boolean!
}

type Broadcast {
  game: Game
  id: ID
  startedAt: Time
  title: String
}

type BroadcasterViewerReach {
  broadcasterPool: Range!
  minutesWatched: Range!
  viewerPool: Range!
}

enum BroadcastFormat {
  LIVE
  DELAY
  BACKUP_000
  BACKUP_001
  BACKUP_002
  BACKUP_003
}

type BroadcastSettings {
  game: Game
  id: ID!
  isMature: Boolean!
  language: Language!
  liveUpNotification: String
    @deprecated(reason: "Use liveUpNotificationInfo instead.")
  liveUpNotificationInfo: LiveUpNotificationInfo
  title: String!
}

enum BroadcastType {
  ARCHIVE
  HIGHLIGHT
  UPLOAD
  PREMIERE_UPLOAD
  PAST_PREMIERE
}

type BuildACommunity {
  badgeURL: String
  completedAt: Time
  followers: QuestGoalInt
  uniqueChatters: QuestGoalInt
}

input BulkApproveUnbanRequestInput {
  ids: [ID!]!
}

type BulkApproveUnbanRequestPayload {
  error: UnbanRequestError
  unbanRequests: [UnbanRequest!]
}

input BulkDenyUnbanRequestInput {
  ids: [ID!]!
}

type BulkDenyUnbanRequestPayload {
  error: UnbanRequestError
  unbanRequests: [UnbanRequest!]
}

type Campaign {
  domain: String!
  endDate: Time!
  id: ID!
  objectives: [CampaignObjective!]!
  startDate: Time!
}

type CampaignCheergroup {
  cheerCodes: [String!]!
  division: String
  imageUrl: String!
  name: String!
}

enum CampaignDiscoveryEventType {
  ENGAGE_COMMAND_CENTER
  ENGAGE_STREAM
}

type CampaignObjective {
  cheergroup: CampaignCheergroup
  description: String!
  id: ID!
  isActive: Boolean!
  milestones: [Milestone!]
  participation: Int!
  progress: Int!
  tag: String!
  title: String!
}

type CampaignProperties {
  activeCampaigns: [String!]
  domains: [String!]
  hasPass: Boolean!
  objectives: [CampaignObjective!]
  triggers: [CampaignTrigger!]
}

type CampaignRewardMetadata {
  isPending: Boolean! @deprecated
  subType: String @deprecated
}

type CampaignTrigger {
  description: String!
  id: ID!
  isActive: Boolean!
  rewards: [TournamentReward!]
  title: String!
  triggerAmountMax: Int!
  triggerAmountMin: Int!
  triggerType: TriggerType!
}

enum CampaignType {
  DEFAULT
  MANUAL_TRIGGER_BASED
}

type CancelActiveBoostOrdersError {
  code: CancelActiveBoostOrdersErrorCode!
}

enum CancelActiveBoostOrdersErrorCode {
  INVALID_PARAMETER
  INTERNAL_ERROR
}

input CancelActiveBoostOrdersInput {
  channelID: ID!
}

type CancelActiveBoostOrdersPayload {
  error: CancelActiveBoostOrdersError
}

type CancelBountyError {
  code: CancelBountyErrorCode!
}

enum CancelBountyErrorCode {
  INVALID_PARAMETER
  BOUNTY_NOT_LIVE
  UNKNOWN_ERROR
}

input CancelBountyInput {
  bountyID: ID!
  reason: String
  userID: ID!
}

type CancelBountyPayload {
  bounty: Bounty
  error: CancelBountyError
  user: User
}

input CancelFriendRequestInput {
  targetID: ID!
}

type CancelFriendRequestPayload {
  user: User
}

enum CancellationPolicyType {
  NON_REFUNDABLE
  REFUNDABLE
}

input CancelPayoutOnboardingWorkflowInput {
  targetUserID: ID!
}

type CancelPayoutOnboardingWorkflowPayload {
  workflow: PayoutOnboardingWorkflow
}

type CancelPredictionEventError {
  code: CancelPredictionEventErrorCode!
}

enum CancelPredictionEventErrorCode {
  FORBIDDEN
  EVENT_ENDED
  UNKNOWN
}

input CancelPredictionEventInput {
  id: ID!
}

type CancelPredictionEventPayload {
  error: CancelPredictionEventError
  predictionEvent: PredictionEvent
}

type CancelRaidError {
  code: CancelRaidErrorCode!
}

enum CancelRaidErrorCode {
  RAID_DOES_NOT_EXIST
  INVALID_CHANNEL
  NO_ACTIVE_RAID
}

input CancelRaidInput {
  sourceID: ID!
}

type CancelRaidPayload {
  error: CancelRaidError
  raid: Raid
}

input CancelSubscriptionGiftInput {
  originID: ID!
  productID: ID!
}

type CancelSubscriptionGiftPayload {
  gift: SubscriptionGift
}

input CancelUnbanRequestInput {
  id: ID!
}

type CancelUnbanRequestPayload {
  error: UnbanRequestError
  unbanRequest: UnbanRequest
}

type CategoryProperties {
  rating: String
  contentDescription: String
}

enum CaughtMessageStatus {
  INVALID
  ALLOWED
  DENIED
  EXPIRED
  PENDING
}

type CCPACookieVendor {
  consentStatus: ConsentStatus!
  hasUserSetConsent: Boolean!
  isVisible: Boolean!
  name: VendorName!
}

type CCPAVendorConsent {
  status: [CCPACookieVendor!]!
}

type Celebration {
  area: CelebrationArea!
  durationMilliseconds: Int!
  effect: CelebrationEffect!
  eventThreshold: Int!
  eventType: CelebrationEventType!
  id: ID!
  intensity: Int!
  isEnabled: Boolean!
}

enum CelebrationArea {
  EVERYWHERE
  VIDEO_ONLY
  VIDEO_AND_PANEL
  UNKNOWN
}

type CelebrationConfig {
  celebrations: [Celebration!]!
  id: ID!
  isEnabled: Boolean!
}

enum CelebrationEffect {
  FIREWORKS
  RAIN
  FLAMETHROWERS
  UNKNOWN
}

type CelebrationError {
  code: CelebrationErrorCode!
}

enum CelebrationErrorCode {
  CELEBRATION_NOT_FOUND
  CELEBRATION_ALREADY_EXISTS
  PERMISSION_DENIED
  OVER_CELEBRATION_LIMIT
  UNKNOWN
}

enum CelebrationEventType {
  BITS_CHEER
  SUBSCRIPTION_GIFT
  UNKNOWN
}

enum CelebrationIntensity {
  SMALL
  MEDIUM
  LARGE
  UNKNOWN
}

type CelebrationProduct implements ProductCatalogItem {
  benefits: [ProductCatalogBenefit!]
  description: String
  id: ID!
  intensity: CelebrationIntensity!
  isEnabled: Boolean!
  offers: [Offer!]
  owner: ID!
  potentialOffers: [Offer!]
  title: String!
}

type CelebrationProductBenefit implements ProductCatalogBenefit {
  id: ID!
}

input CelebrationProductConfigInput {
  intensity: CelebrationIntensity!
  isEnabled: Boolean
  offerID: ID
}

type CelebrationUserSettings {
  isOptedOut: Boolean!
}

type ChallengeCondition {
  createdAt: Time
  effectSettings: [ChallengeEffectSettings!]
  id: ID!
  name: String!
  owner: User
  participantSummary: ChallengeConditionParticipantSummaryByState
  state: ChallengeConditionState!
  supportedEffects: [ChallengeEffectType!]!
  timeoutAt: Time
  updatedAt: Time
  willDisableWhenSatisfied: Boolean!
}

type ChallengeConditionParticipant {
  condition: ChallengeCondition
  effect: ChallengeEffect!
  endState: ChallengeConditionParticipantEndState!
  id: ID!
  owner: User
  processingState: ChallengeConditionParticipantProcessingState!
}

enum ChallengeConditionParticipantEndState {
  PENDING
  CONDITION_EXPIRED
  CONDITION_CANCELED
  CONDITION_SATISFIED
  EXPIRED
  CANCELED
  FAILED_VALIDATION
  UNKNOWN
}

enum ChallengeConditionParticipantProcessingState {
  PENDING
  SUCCESS
  ERROR
  UNKNOWN
}

type ChallengeConditionParticipantSummary {
  effects: ChallengeEffectSummary
  total: Int!
}

type ChallengeConditionParticipantSummaryByState {
  canceled: ChallengeConditionParticipantSummary
  conditionCanceled: ChallengeConditionParticipantSummary
  conditionTimeout: ChallengeConditionParticipantSummary
  failedValidation: ChallengeConditionParticipantSummary
  pending: ChallengeConditionParticipantSummary
  satisfied: ChallengeConditionParticipantSummary
  timeout: ChallengeConditionParticipantSummary
  total: Int!
}

enum ChallengeConditionState {
  ACTIVE
  CANCELED
  INACTIVE
  EXPIRED
  UNKNOWN
}

type ChallengeEffect {
  details: ChallengeEffectDetails!
  type: ChallengeEffectType!
}

union ChallengeEffectDetails = ChallengeUseBitsEffectDetails
type ChallengeEffectSettings {
  details: ChallengeEffectSettingsDetails!
  type: ChallengeEffectType!
}

union ChallengeEffectSettingsDetails = ChallengeUseBitsEffectSettingsDetails
type ChallengeEffectSummary {
  useBits: ChallengeUseBitsEffectSummary
}

enum ChallengeEffectType {
  USE_BITS
  UNKNOWN
}

type ChallengeUseBitsEffectDetails {
  benefactor: User
  bitsAmount: Int!
}

type ChallengeUseBitsEffectSettingsDetails {
  bitsRecipientWeightedShares: [ChallengeUseBitsPoolRecipientWeightedShare!]!
}

type ChallengeUseBitsEffectSummary {
  totalBitsAmount: Int!
  totalEffects: Int!
}

type ChallengeUseBitsPoolRecipientWeightedShare {
  recipient: User
  weight: Int!
}

type ChangelogEntry {
  content: String!
  iconURL: String!
  id: ID!
  linkText: String
  linkURL: String
  position: Int!
  publishedAt: Time
  title: String!
}

type ChangeUsernameCodeError {
  code: ChangeUsernameErrorCode!
}

enum ChangeUsernameErrorCode {
  REAUTH_NEEDED
  REQUESTS_THROTTLED
  LOGIN_CHANGE_COOLDOWN
  LOGIN_UNAVAILABLE
  LOGIN_TOO_SHORT
  LOGIN_TOO_LONG
  LOGIN_CONTAINS_INVALID_CHARACTERS
  LOGIN_CHANGE_EMAIL_VERIFIED
  UNKNOWN_ERROR
}

input ChangeUsernameInput {
  login: String!
  userID: ID!
}

type ChangeUsernamePayload {
  error: ChangeUsernameCodeError
  user: User
}

enum ChanletSort {
  NONE
  VIEWER_COUNT
}

type Channel {
  activePredictionEvents: [PredictionEvent!]
  adContentMetadata: AdContentMetadata
  autoModConfiguration: AutoModConfiguration
  availableContentAttributes: [MultiviewContentAttribute!]
  availableDrops: [DropObject]
    @deprecated(reason: "use channel.viewerDropCampaigns")
  bannedUsers(after: Cursor, first: Int = 25): ChannelBannedUserConnection
  blockedTerms(after: Cursor, first: Int = 25): ChannelBlockedTermConnection
  boostSettings: BoostSettings
  broadcasterLanguage: String!
    @deprecated(reason: "Use stream.language instead.")
  celebrations: CelebrationConfig
  chanletStreamKey: String
  chanlets(
    sort: ChanletSort = NONE
    bypassDisableFlag: Boolean = false
  ): [Channel!]
  chatters: ChattersInfo
  clipsSettings: ChannelClipsSettings
  communityPointsCustomRewardRedemption(
    id: ID!
  ): CommunityPointsCustomRewardRedemption
  communityPointsRedemptionQueue(
    first: Int = 10
    after: Cursor
    options: CommunityPointsRedemptionQueueOptions
  ): CommunityPointsCustomRewardRedemptionConnection
  communityPointsSettings: CommunityPointsChannelSettings
  contentAttributes: [MultiviewContentAttribute!]
  creatorBadgeFlair: CreatorBadgeFlair
  crowdChants: CrowdChants
  currentRadioTrack: RadioCurrentlyPlaying
  dashboardView(type: ChannelDashboardViewType!): ChannelDashboardView!
  displayName: String
  dropCampaign(id: ID!): DropCampaign
  dropCampaigns: [DropCampaign!]
  founderBadgeAvailability: Int!
  game: String! @deprecated(reason: "Use user.lastBroadcast.game.name instead.")
  home: ChannelHome
  hypeTrain: HypeTrain!
  id: ID!
  isClipsEnabled: Boolean!
    @deprecated(reason: "Use channel.clipsSettings instead.")
  isHiddenChanlet: Boolean!
  isMature: Boolean! @deprecated(reason: "Use stream.isMature instead.")
  isOptedOutOfDrops: Boolean
  isMemberOfAutoModRollout: Boolean
  leaderboardSet(first: Int = 10): LeaderboardSet
  leaderboardTimePeriod: LeaderboardTimePeriodType
  lockedPredictionEvents: [PredictionEvent!]
  managedVideos(
    first: Int = 10
    after: Cursor
    statuses: [VideoStatus!]
    types: [BroadcastType!]
    sort: VideoSort = TIME
  ): VideoConnection
  moderationLogs: ModerationLogs
  name: String!
  numberOfVIPsAllowed: Int
  owner: User
  ownerChanletAttributes: OwnerChanletAttributes
  permittedTerms(after: Cursor, first: Int = 25): ChannelPermittedTermConnection
  predictionSettings: ChannelPredictionSettings
  recentChatMessages: [Message!]!
  resolvedPredictionEvents(
    first: Int = 10
    after: Cursor
  ): PredictionEventConnection
  restriction: ResourceRestriction
  schedule: Schedule
  self: ChannelSelfEdge
  selfInstalledExtensions(
    isMobile: Boolean = false
  ): [ExtensionInstallationSelfEdge!]
  socialMedias: [SocialMedia!]
  status: String! @deprecated(reason: "Use user.lastBroadcast.title instead.")
  stream: Stream @deprecated(reason: "Use user.stream instead.")
  streams: [Stream!]
  trailer: Trailer
  unbanRequests(
    after: Cursor
    first: Int = 25
    options: UnbanRequestsOptions
  ): UnbanRequestConnection
  unbanRequestsSettings: UnbanRequestsSettings
  url: String!
  videoStreamSettings: VideoStreamSettings
  viewerDropCampaigns: [DropCampaign!]
}

type ChannelAnalytics {
  subCountSeries: SubCountSeries
}

type ChannelAnalyticsContentOverlap {
  channels: [ChannelOverlap!]
  games: [GameOverlap!]
}

type ChannelBannedUser {
  bannedAt: Time!
  bannedUser: User
  modUser: User
}

type ChannelBannedUserConnection {
  edges: [ChannelBannedUserEdge!]
  pageInfo: PageInfo!
}

type ChannelBannedUserEdge {
  cursor: Cursor!
  node: ChannelBannedUser
}

type ChannelBlockedTerm {
  id: ID!
  category: String! @deprecated(reason: "ChannelBlockedTerm is always banned")
  createdAt: Time
  expiresAt: Time
  isModEditable: Boolean!
  phrases: [String!]! @deprecated(reason: "Replaced by phrase field")
  phrase: String!
  source: User
  updatedAt: Time
}

type ChannelBlockedTermConnection {
  edges: [ChannelBlockedTermEdge!]!
  pageInfo: PageInfo!
}

type ChannelBlockedTermEdge {
  cursor: Cursor!
  node: ChannelBlockedTerm
}

interface ChannelChallenge {
  bitsAmount: Int!
  createdAt: Time!
  createdBy: User
  durationSeconds: Int!
  id: ID!
  ownedBy: User
  remainingDurationMilliseconds: Int!
  self: ChannelChallengeSelfEdge
  status: ChannelChallengeStatus!
  updatedAt: Time!
}

type ChannelChallengeConnection {
  edges: [ChannelChallengeEdge!]
  pageInfo: PageInfo!
}

type ChannelChallengeEdge {
  cursor: Cursor!
  node: ChannelChallenge!
}

type ChannelChallengeParticipant {
  bits: Int!
  challenge: ChannelChallenge
  firstContributedAt: Time!
  id: ID!
  lastContributedAt: Time!
}

type ChannelChallengeSelfEdge {
  participant: ChannelChallengeParticipant
}

enum ChannelChallengeSort {
  START_TIME
  END_TIME
}

enum ChannelChallengeStatus {
  UNKNOWN
  ACTIVE
  COMPLETED
  FAILED
  TIMED_OUT
}

input ChannelClipsCreationAuthRestrictionOptionsInput {
  followingLengthMinutes: Int
}

type ChannelClipsCreationRestrictedTo {
  isFollower: Boolean!
  isSubscriber: Boolean!
}

input ChannelClipsCreationRestrictedToInput {
  followers: Boolean!
  subscribers: Boolean!
}

type ChannelClipsCreationRestrictionOptions {
  followingLengthMinutes: Int
}

type ChannelClipsSettings {
  creationRestrictedTo: ChannelClipsCreationRestrictedTo
  creationRestrictionOptions: ChannelClipsCreationRestrictionOptions
  isClipsCreationEnabled: Boolean!
}

type ChannelCrowdChantSettings {
  isEligible: Boolean!
}

interface ChannelDashboardLayout {
  id: ID!
  name: String!
  version: String!
  lastUpdated: Time
}

type ChannelDashboardView {
  layouts: [ChannelDashboardLayout!]
  options: ChannelDashboardViewOptions!
}

type ChannelDashboardViewOptions {
  customLayoutsTotal: Int
  customLayoutsUsed: Int
}

enum ChannelDashboardViewType {
  STREAM_MANAGER
  TWITCH_STUDIO
}

type ChannelHome {
  preferences: ChannelHomePreferences
  shelves: ChannelHomeShelves
}

type ChannelHomeCategoryShelf {
  edges: [ChannelHomeCategoryShelfEdge!]!
}

type ChannelHomeCategoryShelfEdge {
  node: Game
}

type ChannelHomeCategorySuggestionsShelf {
  edges: [ChannelHomeCategorySuggestionsShelfEdge!]!
}

type ChannelHomeCategorySuggestionsShelfEdge {
  isHidden: Boolean!
  node: Game
}

type ChannelHomePreferences {
  heroPreset: HeroPreset!
  streamerShelfType: StreamerShelfType!
  isStreamScheduleSyncDisabled: Boolean!
}

type ChannelHomeShelves {
  categoryShelf(first: Int = 20): ChannelHomeCategoryShelf
  categoryShelfSuggestions(first: Int = 20): ChannelHomeCategorySuggestionsShelf
  streamerShelf(first: Int = 20): ChannelHomeStreamerShelf
}

type ChannelHomeStreamerShelf {
  edges: [ChannelHomeStreamerShelfEdge!]!
  type: StreamerShelfType!
}

type ChannelHomeStreamerShelfEdge {
  node: User
}

type ChannelModerationActionConnection {
  edges: [ChannelModerationActionEdge!]
  pageInfo: PageInfo!
}

type ChannelModerationActionEdge {
  cursor: Cursor!
  node: ChannelModerationActionEntry
}

interface ChannelModerationActionEntry {
  action: ModerationAction!
  createdAt: Time!
  id: ID!
  moderator: User
}

type ChannelModerationActionOnAutomodLevelEntry implements ChannelModerationActionEntry {
  action: ModerationAction!
  automodNewProperties: AutoModProperties
  automodOldProperties: AutoModProperties
  automodPreviousLevels: AutoModConfiguration
  automodUpdatedLevels: AutoModConfiguration
  createdAt: Time!
  id: ID!
  moderator: User
}

type ChannelModerationActionOnAutomodTermEntry implements ChannelModerationActionEntry {
  action: ModerationAction!
  createdAt: Time!
  id: ID!
  isFromAutomod: Boolean!
  moderator: User
  terms: [String!]
}

type ChannelModerationActionOnChannelEntry implements ChannelModerationActionEntry {
  action: ModerationAction!
  createdAt: Time!
  id: ID!
  isAutoHosted: Boolean!
  isHostedAfterRaiding: Boolean!
  moderator: User
  shouldRevealViewerCount: Boolean!
  target: User
  viewerCount: Int
}

type ChannelModerationActionOnChatMessageEntry implements ChannelModerationActionEntry {
  action: ModerationAction!
  createdAt: Time!
  id: ID!
  messageBody: String
  messageID: ID
  messageSender: User
  moderator: User
}

type ChannelModerationActionOnChatModeEntry implements ChannelModerationActionEntry {
  action: ModerationAction!
  createdAt: Time!
  durationSeconds: Int
  id: ID!
  moderator: User
}

type ChannelModerationActionOnUnbanRequestsEntry implements ChannelModerationActionEntry {
  action: ModerationAction!
  createdAt: Time!
  id: ID!
  moderator: User
  reason: String!
  target: User
}

type ChannelModerationActionOnUserEntry implements ChannelModerationActionEntry {
  action: ModerationAction!
  createdAt: Time!
  durationSeconds: Int
  id: ID!
  moderator: User
  reason: String!
  target: User
}

type ChannelModerationActionOtherEntry implements ChannelModerationActionEntry {
  action: ModerationAction!
  createdAt: Time!
  id: ID!
  moderator: User
}

type ChannelNotificationSetting {
  category: String!
  isEnabled: Boolean!
  settingState: String!
}

type ChannelNotificationSettings {
  isEnabled: Boolean!
  nodes: [ChannelNotificationSetting!]!
}

type ChannelOverlap {
  score: Float!
  viewersAlsoWatch: User
}

enum ChannelPermission {
  MULTIVIEW_ADMIN
  SET_CHANNEL_RESTRICTION
}

type ChannelPermittedTerm {
  id: ID!
  category: String!
    @deprecated(
      reason: "ChannelPermittedTerm type will always be of category permitted"
    )
  createdAt: Time
  expiresAt: Time
  isModEditable: Boolean!
    @deprecated(reason: "ChannelPermittedTerm is always mod editable")
  phrases: [String!]! @deprecated(reason: "Replaced by phrase field")
  phrase: String!
  source: User
  updatedAt: Time
}

type ChannelPermittedTermConnection {
  edges: [ChannelPermittedTermEdge!]!
  pageInfo: PageInfo!
}

type ChannelPermittedTermEdge {
  cursor: Cursor!
  node: ChannelPermittedTerm
}

type ChannelPredictionSettings {
  canModeratorsManagePredictions: Boolean!
  isEligibleForPredictions: Boolean!
}

type ChannelRestriction {
  endsAt: Time
  exemptionInfo: ChannelRestrictionExemptionInfo!
    @deprecated(reason: "Use resourceRestriction.exemptions instead.")
  id: ID!
  startsAt: Time
  type: ChannelRestrictionType!
}

type ChannelRestrictionExemptionInfo {
  exemptionType: String!
    @deprecated(reason: "Use channelRestriction.type instead.")
}

enum ChannelRestrictionType {
  UNKNOWN
  SUB_ONLY_LIVE
  ALL_ACCESS_PASS
}

type ChannelSelfEdge {
  canRequestUnban: Boolean
  communityPoints: CommunityPointsProperties
  isAuthorized: Boolean!
  isResourceRestricted: Boolean!
  lastUnbanRequest: UnbanRequest
  modChatLogs(
    first: Int = 100
    after: Cursor
    order: SortOrder = DESC
    includeMessageCount: Boolean = false
    includeTargetedActions: Boolean = false
    includeAutoModCaughtMessages: Boolean = true
  ): ModLogsMessageConnection
  permissions: [ChannelPermission!]!
  recentPredictions: [Prediction!]
  restrictionType: ResourceRestrictionType
  unbanRequestRestriction: UnbanRequestRestrictionReason
}

enum ChannelUserRole {
  BROADCASTER
  EDITOR
  MODERATOR
  SUBSCRIBER
  REGULAR
}

type ChannelViewer {
  id: ID!
  earnedBadges: [Badge!]
}

type ChargeInstrument {
  id: ID!
}

input ChargeInstrumentInput {
  id: ID!
}

type ChargeModel {
  credit: CreditChargeModel
  external: ExternalChargeModel
  internal: InternalChargeModel
}

type ChargeModelPlan {
  interval: ChargeModelPlanInterval!
  renewalPolicy: RenewalPolicy!
}

type ChargeModelPlanInterval {
  duration: Int!
  unit: ChargeModelPlanIntervalUnit!
}

enum ChargeModelPlanIntervalUnit {
  DAYS
  MONTHS
  UNKNOWN
}

enum ChatPauseSetting {
  SCROLL_ONLY
  MOUSEOVER
  ALTKEY
  MOUSEOVER_ALTKEY
}

enum ChatRestrictedReason {
  REQUIRE_VERIFIED_PHONE_NUMBER
  SUBSCRIBERS_ONLY
  FOLLOWERS_ONLY
  VERIFIED_ONLY
  SLOW_MODE
}

type ChatRoomBanStatus {
  bannedUser: User
  createdAt: Time!
  expiresAt: Time
  expiresInMs: Int
  isPermanent: Boolean!
  moderator: User
  reason: String
  roomOwner: User
}

type ChatSettings {
  autoModLevel: Int! @deprecated(reason: "No longer used.")
  blockLinks: Boolean!
  chatDelayMs: Int!
  followersOnlyDurationMinutes: Int
  isBroadcasterLanguageModeEnabled: Boolean!
    @deprecated(reason: "No longer used.")
  isEmoteOnlyModeEnabled: Boolean!
  isFastSubsModeEnabled: Boolean!
  isOptedOutOfGlobalBannedWordsList: Boolean!
    @deprecated(reason: "No longer used.")
  isSubscribersOnlyModeEnabled: Boolean!
  isUniqueChatModeEnabled: Boolean!
  requireVerifiedAccount: Boolean!
  rules: [String!]!
  slowModeDurationSeconds: Int
}

type Chatter {
  login: String!
}

type ChattersInfo {
  broadcasters: [Chatter!]!
  count: Int!
  moderators: [Chatter!]!
  staff: [Chatter!]!
  viewers: [Chatter!]!
  vips: [Chatter!]!
}

enum ChatTheme {
  DARK
  LIGHT
}

type ChatUISettings {
  chatPauseSetting: ChatPauseSetting
  deletedMessageDisplaySetting: DeletedMessageDisplaySetting
  isEmoteAnimationsEnabled: Boolean
  isReadableChatColorsEnabled: Boolean
  isEmoteAnimationsSettingCalloutDismissed: Boolean
}

enum CheckoutAction {
  BLOCK_SAVED_PAYMENT_METHOD
  EXCEEDED_VELOCITY_LIMITS
  VERIFIED_SAVED_PAYMENT_METHOD
  DISABLE_NEW_CREDIT_CARD
  DISABLE_NEW_DIRECT_DEBIT
  AUTHORIZED_USER
  PRIORITIZE_XSOLLA
}

type CheckoutConfiguration {
  xsolla(
    productType: PurchaseableProductType
    productID: ID
    offerTagBindings: [OfferTagBindingInput!]
    quantity: Int
    giftRecipientIDs: [ID!]
    tenantTracking: String
    paymentSession: PaymentSession
    isDarkMode: Boolean
  ): Xsolla
}

input CheckoutConfigurationInput {
  isAnonymous: Boolean
  isGift: Boolean!
  isReactivateRecurring: Boolean
  mysteryGiftCount: Int
  paymentSession: PaymentSession
  recipientID: ID
  taxCountryCode: String
}

type CheckoutPriceSummary {
  currency: Currency!
  description: String!
  discount: DiscountBreakdown
  exponent: Int!
  id: ID!
  isTaxInclusive: Boolean!
  price: Int!
  pricingIdentifier: String!
  tax: Int!
  total: Int!
}

type CheerImage {
  id: ID!
  url: String!
}

type CheerInfo {
  availableBadges: [Badge!]
  badgeTierEmotes(filter: BadgeTierEmotesFilter!): [Emote]!
  cheerGroups: [CheermoteGroup!]!
  emotes(
    prefixes: [String!]
    type: [CheermoteType!]
    includeUpperTiers: Boolean
    includeSponsored: Boolean
  ): [Cheermote]!
    @deprecated(reason: "Scheduled to be removed. Use cheerGroups instead")
  hashtags(first: Int = 10, after: String): BitsHashtagConnection
    @deprecated(reason: "Hashtags is no longer a supported feature.")
  id: ID!
  images: [CheerImage]
  leaderboard(first: Int!): BitsLeaderboard
  recentTimeoutMs: Int!
    @deprecated(
      reason: "Recent cheer is a a removed feature, this functionality shouldn't be used anymore."
    )
  settings: CheerSettings!
}

type Cheermote {
  campaign: CheermoteCampaign
  id: ID!
  prefix: String!
  tiers: [CheermoteTier!]!
  type: CheermoteType!
}

type CheermoteCampaign {
  bitsPercentageRemaining: Float!
  bitsTotal: Int
  bitsUsed: Int
  brandImageURL: String!
  brandName: String!
  id: ID!
  minimumBitsAmount: Int!
  self: CheermoteCampaignSelfEdge
  thresholds: [CheermoteCampaignThreshold!]!
  userLimit: Int!
}

type CheermoteCampaignSelfEdge {
  bitsUsed: Int!
  canBeSponsored: Boolean!
  id: ID!
}

type CheermoteCampaignThreshold {
  id: ID!
  matchedPercent: Float!
  minimumBits: Int!
}

type CheermoteColorConfig {
  bits: Int!
  color: String!
}

type CheermoteDisplayConfig {
  backgrounds: [String!]!
  colors: [CheermoteColorConfig!]!
  order: [CheermoteType!]!
  scales: [String!]!
  types: [CheermoteDisplayType!]!
}

type CheermoteDisplayType {
  animation: String!
  extension: String!
}

type CheermoteGroup {
  nodes: [Cheermote!]!
  templateURL: String!
}

type CheermoteImage {
  dpiScale: Float! @deprecated(reason: "Scheduled to be removed.")
  id: ID! @deprecated(reason: "Scheduled to be removed.")
  isAnimated: Boolean! @deprecated(reason: "Scheduled to be removed.")
  theme: ChatTheme! @deprecated(reason: "Scheduled to be removed.")
  url: String! @deprecated(reason: "Scheduled to be removed.")
}

type CheermoteTier {
  bits: Int!
  canCheer: Boolean! @deprecated(reason: "Scheduled to be removed.")
  canShowInBitsCard: Boolean!
  color: String! @deprecated(reason: "Scheduled to be removed.")
  id: ID!
  images(
    theme: ChatTheme
    isAnimated: Boolean
    dpiScale: Float
  ): [CheermoteImage]! @deprecated(reason: "Scheduled to be removed.")
  tierID: ID! @deprecated(reason: "Scheduled to be removed.")
}

enum CheermoteTierThreshold {
  TIER_1
  TIER_100
  TIER_1000
  TIER_5000
  TIER_10000
}

type CheermoteToken {
  bitsAmount: Int!
  prefix: String!
  tier: Int!
}

enum CheermoteType {
  DEFAULT
  CUSTOM
  SPONSORED
  CHARITY
  FIRST_PARTY
  THIRD_PARTY
  DISPLAY_ONLY
  ANONYMOUS
  UNKNOWN
}

type CheerPartnerBadgeSettings {
  canUploadBadgeTierEmoticons: Boolean
  tiers: [BitsBadgeTier!]!
}

type CheerPartnerChatMessageSettings {
  isOptedOutOfProjectV: Boolean!
  minBitsPerEmote: Int!
  minBitsToCheer: Int!
}

type CheerPartnerCheerBombSettings {
  isOptedOut: Boolean!
}

type CheerPartnerCustomPrefixSettings {
  isEnabled: Boolean!
  prefix: String!
  tiers: [CheermoteTier!]
}

type CheerPartnerLeaderboardSettings {
  isEnabled: Boolean!
  timePeriod: LeaderboardTimePeriodType!
}

type CheerPartnerRecentCheerSettings {
  canPin: Boolean!
  minimumBits: Int!
  timeoutMilliseconds: Int!
}

type CheerPartnerSettings {
  badges: CheerPartnerBadgeSettings
  chatMessage: CheerPartnerChatMessageSettings!
  cheerBomb: CheerPartnerCheerBombSettings!
  customPrefix: CheerPartnerCustomPrefixSettings!
  hasSignedBitsAmendment: Boolean!
  id: ID!
  isOnboarded: Boolean!
  leaderboard: CheerPartnerLeaderboardSettings!
    @deprecated(reason: "Use leaderboard settings in user settings instead.")
  recentCheer: CheerPartnerRecentCheerSettings!
  sponsoredCheermotes: CheerPartnerSponsoredCheermoteSettings!
}

type CheerPartnerSponsoredCheermoteSettings {
  campaigns: SponsoredCheermoteChannelSettingsConnection
}

type CheerSettings {
  cheerMinimumBits: Int!
  emoteMinimumBits: Int!
  event: String
  id: ID!
  isCheerBombEventEnabled: Boolean!
  isPollsEnabled: Boolean!
    @deprecated(
      reason: "Unsupported field. Check partner or affiliate status instead of using this field"
    )
  isRecentEnabled: Boolean!
  isTopEnabled: Boolean!
  leaderboard: BitsLeaderboardSettings
    @deprecated(reason: "Use leaderboard settings in user settings instead.")
  recentMinimumBits: Int!
  recentTimeoutMs: Int!
}

interface Claimable {
  description: String!
  id: ID!
  self: SelfClaimEdge
  type: ClaimableType!
}

enum ClaimableType {
  BITS_KEY_CODE
  SUBS_KEY_CODE
  GIFT_CARD_KEY_CODE
}

type ClaimBountyError {
  code: ClaimBountyErrorCode!
}

enum ClaimBountyErrorCode {
  INVALID_PARAMETER
  BOUNTY_LIMIT_REACHED
  BOUNTY_ALREADY_CLAIMED
  UNAUTHORIZED
  UNKNOWN_ERROR
}

input ClaimBountyInput {
  bountyCampaignID: ID!
  bountyID: ID!
  platform: String
  region: String
  userID: ID!
}

type ClaimBountyPayload {
  claimedBounty: Bounty
  error: ClaimBountyError
  user: User
}

type ClaimCommunityPointsError {
  code: ClaimCommunityPointsErrorCode
}

enum ClaimCommunityPointsErrorCode {
  NOT_FOUND
  FORBIDDEN
}

input ClaimCommunityPointsInput {
  channelID: ID!
  claimID: ID!
}

type ClaimCommunityPointsPayload {
  claim: CommunityPointsClaim
  currentPoints: Int
  error: ClaimCommunityPointsError
}

input ClaimDropRewardsInput {
  dropInstanceID: ID!
}

type ClaimDropRewardsPayload {
  drop: DropObject
    @deprecated(reason: "No longer supported. Use dropType instead.")
  dropInstanceID: ID
  dropType: DropType
  isUserAccountConnected: Boolean
  rewards: [DropReward!]!
  status: DropInstanceEligibilityStatus
}

enum ClaimHint {
  AVAILABLE
  CLAIMED_NO_CONFLICTS
  CLAIMED_AMAZON_LINK_CONFLICT
  RECLAIMABLE_NO_CONFLICTS
  CLAIMED_BY_MEMBER_OF_HOUSEHOLD
  NEED_PRIME
  OFFER_FULLY_CLAIMED
  UNKNOWN
}

type ClaimPrimeOfferError {
  code: ClaimPrimeOfferErrorCode!
}

enum ClaimPrimeOfferErrorCode {
  OFFER_ALREADY_CLAIMED
  UNKNOWN
}

input ClaimPrimeOfferInput {
  offerID: ID!
}

type ClaimPrimeOfferPayload {
  error: ClaimPrimeOfferError
  self: PrimeOfferSelfConnection
}

type ClearUnreadFriendRequestsPayload {
  user: User
}

type ClientAuthorization {
  clientID: ID!
  clientName: String
  createdAt: Time
}

type Clip {
  broadcast: Broadcast
  broadcaster: User
  champBadge: Badge
    @deprecated(reason: "Clip Champ Badges are no longer being awarded")
  createdAt: Time!
  creationState: ClipCreationState
  curator: User
  durationSeconds: Int!
  embedURL: String!
  game: Game
  id: ID!
  isPublished: Boolean
  language: Language!
  playbackAccessToken(params: PlaybackAccessTokenParams!): PlaybackAccessToken
  rawMedia: ClipRawMedia!
  rawVideoQualities: [ClipVideoQuality!]
  reactions: [Reaction]
  relatedClips: ClipRelatedClips
  slug: String!
  thumbnailURL(width: Int = 260, height: Int = 147): String!
  title: String!
  url: String!
  video: Video
  videoOffsetSeconds: Int
  videoQualities: [ClipVideoQuality!]
  viewCount: Int!
}

type ClipConnection {
  edges: [ClipEdge]
  pageInfo: PageInfo
}

enum ClipCreationState {
  CREATING
  CREATED
  FAILED
}

type ClipEdge {
  cursor: Cursor
  node: Clip
}

type ClipRawMedia {
  defaultClipInitialOffset: Float!
  duration: Float!
  filmStripFrames: Int!
  filmStripSecondsPerFrame: Int!
  frameHeight: Int!
  frameWidth: Int!
  spritesheetURL: String!
  status: ClipCreationState!
  videoURL: String!
}

type ClipRelatedClips {
  broadcaster: [Clip!]
  combined: [Clip!]
  curator: [Clip!]
  game: [Clip!]
  similar: [Clip!]
    @deprecated(reason: "Similar clips relied on a deprecated backend service.")
  top: [Clip!]
}

input ClipSegmentInput {
  durationSeconds: Float!
  offsetSeconds: Float!
  speed: Float = 1
}

enum ClipsFilter {
  TRENDING
  LAST_DAY
  LAST_WEEK
  LAST_MONTH
  ALL_TIME
}

enum ClipsPeriod {
  LAST_DAY
  LAST_WEEK
  LAST_MONTH
  ALL_TIME
}

enum ClipsSort {
  CREATED_AT_ASC
  CREATED_AT_DESC
  VIEWS_ASC
  VIEWS_DESC
  TRENDING
}

type ClipVideoQuality {
  frameRate: Float
  quality: String!
  sourceURL: String!
}

enum CloneExtensionDiscoveryDataError {
  UNAUTHORIZED
  INVALID_NEW_VERSION
  VERSION_NOT_FOUND
}

input CloneExtensionDiscoveryDataInput {
  id: ID!
  newVersion: String!
  version: String!
}

type CloneExtensionDiscoveryDataPayload {
  error: CloneExtensionDiscoveryDataError
  manifest: ExtensionVersionDiscoveryManifest
}

enum CloneExtensionManifestError {
  UNAUTHORIZED
  INVALID_NEW_VERSION
  VERSION_ALREDY_EXISTS
  VERSION_NOT_FOUND
}

input CloneExtensionManifestInput {
  id: ID!
  newVersion: String!
  version: String!
}

type CloneExtensionManifestPayload {
  error: CloneExtensionManifestError
  manifest: ExtensionManifest
}

type CloudBroadcast {
  id: ID!
  state: CloudBroadcastState!
  uri: String
}

type CloudBroadcastProvider {
  capabilities: CloudBroadcastProviderCapabilities
  displayName: String!
  id: ID!
}

type CloudBroadcastProviderCapabilities {
  framerate: Int
  height: Int
  id: ID!
  isAvailable: Boolean!
  width: Int
}

type CloudBroadcastProviderKey {
  displayName: String!
  id: ID!
}

enum CloudBroadcastState {
  OFFLINE
  PENDING
  ONLINE
  UNKNOWN
}

type Collection {
  description: String!
  id: ID!
  items(first: Int = 10, after: Cursor): CollectionConnection!
  lengthSeconds: Int!
  owner: User
  thumbnailURL(height: Int, width: Int): String
  title: String!
  type: CollectionType!
  updatedAt: Time!
  viewCount: Int
}

type CollectionConnection {
  edges: [CollectionItemEdge]!
  pageInfo: PageInfo!
  totalCount: Int!
}

union CollectionItem = Video
type CollectionItemEdge {
  cursor: Cursor!
  node: CollectionItem!
}

input CollectionOptions {
  includeAllItems: Boolean = false
}

type CollectionsConnection {
  edges: [CollectionsItemEdge]!
  pageInfo: PageInfo!
}

type CollectionsItemEdge {
  cursor: Cursor
  node: Collection!
}

input CollectionsOptions {
  includeEmpty: Boolean = false
  withVideoID: ID
}

enum CollectionType {
  SERIES
  DEFAULT
}

type CommunityPointsAutomaticReward {
  backgroundColor: String
  cost: Int
  defaultBackgroundColor: String!
  defaultCost: Int!
  defaultImage: CommunityPointsImage!
  globallyUpdatedForIndicatorAt: Time!
  id: ID!
  image: CommunityPointsImage
  isEnabled: Boolean!
  isHiddenForSubs: Boolean!
  minimumCost: Int!
  type: CommunityPointsAutomaticRewardType!
  updatedForIndicatorAt: Time
}

enum CommunityPointsAutomaticRewardType {
  SINGLE_MESSAGE_BYPASS_SUB_MODE
  RANDOM_SUB_EMOTE_UNLOCK
  CHOSEN_SUB_EMOTE_UNLOCK
  SEND_HIGHLIGHTED_MESSAGE
  CHOSEN_MODIFIED_SUB_EMOTE_UNLOCK
}

type CommunityPointsChannelEarningSettings {
  averagePointsPerHour: Int!
  averagePointsPerHourSubscriber: Int!
    @deprecated(
      reason: "Front-end messaging will update to display base averagePointsPerHour value and multipliers instead."
    )
  cheerPoints: Int!
  claimPeriodMinutes: Int!
  claimPoints: Int!
  followPoints: Int!
  id: ID!
  multipliers: [CommunityPointsMultiplier!]!
  passiveWatchPeriodMinutes: Int!
  passiveWatchPoints: Int!
  raidPoints: Int!
  subscriberMultiplier: Float!
    @deprecated(
      reason: "This is the T1 specific multipler value, which is now included in multipliers list."
    )
  subscriptionGiftPoints: Int!
  watchStreakPoints: [CommunityPointsWatchStreakEarningSettings!]!
}

type CommunityPointsChannelSettings {
  archivedGoals(
    first: Int = 10
    after: Cursor
  ): CommunityPointsCommunityGoalConnection
  automaticRewards: [CommunityPointsAutomaticReward!]
  communityGoalMaxContributionPerStream: Int!
  communityGoalSmallContribution: Int!
  customReward(id: ID!): CommunityPointsCustomReward
  customRewardTemplateCollections: [CommunityPointsCustomRewardTemplateCollection!]
  customRewards: [CommunityPointsCustomReward!]
  defaultImage: CommunityPointsImage!
  earlyAccess: CommunityPointsEarlyAccessSettings
    @deprecated(reason: "Early Access period is over.")
  earning: CommunityPointsChannelEarningSettings
  emoteVariants: [CommunityPointsEmoteVariant!]
  goals(
    includeGoalTypes: [CommunityPointsCommunityGoalType!]
  ): [CommunityPointsCommunityGoal!]
  image: CommunityPointsImage
  isAvailable: Boolean!
  isAvailableAtLaunch: Boolean!
    @deprecated(reason: "Early Access period is over.")
  isEnabled: Boolean!
  isEnabledAtLaunch: Boolean!
    @deprecated(reason: "Early Access period is over.")
  name: String
  raidPointAmount: Int!
    @deprecated(reason: "Should use earning.raidPoints instead")
  smartCostsAcknowledgements: [SmartCostsAcknowledgement!]
  summarizedRewards: [CommunityPointsRewardSummary!]
  updateCustomRewardRedemptionStatusesProgress: [CommunityPointsUpdateCustomRewardRedemptionStatusesProgress!]
}

type CommunityPointsClaim {
  id: ID!
  multipliers: [CommunityPointsMultiplier!]!
  pointsEarnedBaseline: Int!
  pointsEarnedTotal: Int!
}

type CommunityPointsCommunityGoal {
  amountNeeded: Int!
  backgroundColor: String!
  defaultImage: CommunityPointsImage!
  description: String
  durationDays: Int!
  endedAt: Time
  id: ID!
  image: CommunityPointsImage
  isInStock: Boolean!
  perStreamUserMaximumContribution: Int!
  pointsContributed: Int!
  smallContribution: Int!
  startedAt: Time
  status: CommunityPointsCommunityGoalStatus!
  title: String!
  type: CommunityPointsCommunityGoalType!
}

type CommunityPointsCommunityGoalConnection {
  edges: [CommunityPointsCommunityGoalEdge!]
  pageInfo: PageInfo!
}

type CommunityPointsCommunityGoalContribution {
  goal: CommunityPointsCommunityGoal!
  userPointsContributedThisStream: Int!
}

type CommunityPointsCommunityGoalEdge {
  cursor: Cursor!
  node: CommunityPointsCommunityGoal!
}

enum CommunityPointsCommunityGoalStatus {
  UNSTARTED
  STARTED
  ENDED
  FULFILLED
  ARCHIVED
  UNKNOWN
}

enum CommunityPointsCommunityGoalType {
  CREATOR
  BOOST
  UNKNOWN
}

enum CommunityPointsContentType {
  UNKNOWN
  AUTOMATIC_REWARD
  CUSTOM_REWARD
}

type CommunityPointsCustomReward {
  backgroundColor: String
  cooldownExpiresAt: Time
  cost: Int!
  defaultImage: CommunityPointsImage!
  globalCooldownSetting: CommunityPointsCustomRewardGlobalCooldownSetting!
  hasRealWorldValue: Boolean
  id: ID!
  image: CommunityPointsImage
  isEnabled: Boolean!
  isInStock: Boolean!
  isPaused: Boolean!
  isSubOnly: Boolean!
  isUserInputRequired: Boolean!
  maxPerStreamSetting: CommunityPointsCustomRewardMaxPerStreamSetting!
  maxPerUserPerStreamSetting: CommunityPointsCustomRewardMaxPerUserPerStreamSetting!
  prompt: String
  redemptionsRedeemedCurrentStream: Int
  shouldRedemptionsSkipRequestQueue: Boolean!
  templateID: ID
  title: String!
  updatedForIndicatorAt: Time!
}

type CommunityPointsCustomRewardGlobalCooldownSetting {
  globalCooldownSeconds: Int!
  isEnabled: Boolean!
}

input CommunityPointsCustomRewardGlobalCooldownSettingInput {
  globalCooldownSeconds: Int!
  isEnabled: Boolean!
}

type CommunityPointsCustomRewardMaxPerStreamSetting {
  isEnabled: Boolean!
  maxPerStream: Int!
}

input CommunityPointsCustomRewardMaxPerStreamSettingInput {
  isEnabled: Boolean!
  maxPerStream: Int!
}

type CommunityPointsCustomRewardMaxPerUserPerStreamSetting {
  isEnabled: Boolean!
  maxPerUserPerStream: Int!
}

input CommunityPointsCustomRewardMaxPerUserPerStreamSettingInput {
  isEnabled: Boolean!
  maxPerUserPerStream: Int!
}

type CommunityPointsCustomRewardRedemption {
  id: ID!
  input: String
  reward: CommunityPointsCustomReward
    @deprecated(reason: "Use the 'rewardID' and 'rewardTitle' fields instead.")
  rewardID: ID!
  rewardTitle: String!
  status: CommunityPointsCustomRewardRedemptionStatus!
  timestamp: Time!
  user: User
}

type CommunityPointsCustomRewardRedemptionConnection {
  edges: [CommunityPointsCustomRewardRedemptionEdge!]!
  pageInfo: PageInfo!
}

type CommunityPointsCustomRewardRedemptionEdge {
  cursor: Cursor!
  node: CommunityPointsCustomRewardRedemption!
}

enum CommunityPointsCustomRewardRedemptionQueueSortOrder {
  OLDEST
  NEWEST
}

enum CommunityPointsCustomRewardRedemptionStatus {
  UNFULFILLED
  FULFILLED
  CANCELED
  REPORTED
}

type CommunityPointsCustomRewardTemplate {
  backgroundColor: String!
  cost: Int!
  globalCooldownSetting: CommunityPointsCustomRewardGlobalCooldownSetting!
  id: ID!
  image: CommunityPointsImage!
  isSubOnly: Boolean!
  isUserInputRequired: Boolean!
  maxPerStreamSetting: CommunityPointsCustomRewardMaxPerStreamSetting!
  maxPerUserPerStreamSetting: CommunityPointsCustomRewardMaxPerUserPerStreamSetting!
  prompt: String
  shouldRedemptionsSkipRequestQueue: Boolean!
  title: String!
}

type CommunityPointsCustomRewardTemplateCollection {
  category: CommunityPointsCustomRewardTemplateCollectionCategory!
  customRewardTemplates: [CommunityPointsCustomRewardTemplate!]!
}

enum CommunityPointsCustomRewardTemplateCollectionCategory {
  UNKNOWN
  GAME
  IRL
  TWITCH
}

type CommunityPointsCustomRewardUserRedemption {
  reward: CommunityPointsCustomReward!
  userRedemptionsCurrentStream: Int!
}

type CommunityPointsEarlyAccessSettings {
  canSignUp: Boolean!
  isSignedUp: Boolean!
}

type CommunityPointsEmote {
  id: ID!
  token: String!
}

type CommunityPointsEmoteModification {
  emote: CommunityPointsEmote!
  globallyUpdatedForIndicatorAt: Time!
  id: ID!
  modifier: CommunityPointsEmoteModifier!
  modifierIconDark: CommunityPointsImage!
    @deprecated(reason: "Use field in modifier.")
  modifierIconLight: CommunityPointsImage!
    @deprecated(reason: "Use field in modifier.")
  title: String! @deprecated(reason: "Use field in modifier.")
}

type CommunityPointsEmoteModifier {
  iconDark: CommunityPointsImage!
  iconLight: CommunityPointsImage!
  id: ID!
  title: String!
}

type CommunityPointsEmoteVariant {
  emote: CommunityPointsEmote!
  id: ID!
  isUnlockable: Boolean!
  modifications: [CommunityPointsEmoteModification!]!
}

type CommunityPointsImage {
  url: String!
  url2x: String!
  url4x: String!
}

type CommunityPointsImageUploadInfo {
  uploadID: ID!
  url: String!
}

type CommunityPointsLastViewedContentByType {
  contentType: CommunityPointsContentType!
  lastViewedAt: Time
}

type CommunityPointsLastViewedContentByTypeAndID {
  contentID: ID!
  contentType: CommunityPointsContentType!
  lastViewedAt: Time
}

type CommunityPointsLimitedEarnings {
  cheerAvailableAt: Time
  id: ID!
  isCheerAvailable: Boolean!
  isFollowAvailable: Boolean!
  isSubscriptionGiftAvailable: Boolean!
  subscriptionGiftAvailableAt: Time
}

type CommunityPointsMultiplier {
  factor: Float!
  reasonCode: CommunityPointsMultiplierReason!
}

enum CommunityPointsMultiplierReason {
  SUB_T1
  SUB_T2
  SUB_T3
}

type CommunityPointsProperties {
  activeMultipliers: [CommunityPointsMultiplier!]
  availableClaim: CommunityPointsClaim
  balance: Int!
  canRedeemRewardsForFree: Boolean!
  goalContributions: [CommunityPointsCommunityGoalContribution!]
  lastViewedContent: [CommunityPointsLastViewedContentByType!]
  limitedEarnings: CommunityPointsLimitedEarnings
  userRedemptions: [CommunityPointsCustomRewardUserRedemption!]
}

input CommunityPointsRedemptionQueueOptions {
  order: CommunityPointsCustomRewardRedemptionQueueSortOrder = OLDEST
  rewardID: ID
  status: CommunityPointsCustomRewardRedemptionStatus
}

type CommunityPointsRewardSummary {
  count: Int!
  isCountAtMaximum: Boolean!
  node: CommunityPointsCustomReward!
}

type CommunityPointsUnlockEmoteError {
  code: CommunityPointsUnlockEmoteErrorCode!
}

enum CommunityPointsUnlockEmoteErrorCode {
  INVALID_EMOTE
  EMOTE_ALREADY_ENTITLED
  NO_EMOTES_AVAILABLE
  INSUFFICIENT_POINTS
  TRANSACTION_ALREADY_COMMITTED
  TRANSACTION_IN_PROGRESS
  REWARD_COST_MISMATCH
  REWARD_DISABLED
  REWARD_FORBIDDEN
  UNKNOWN
}

enum CommunityPointsUpdateCustomRewardRedemptionStatusesMethod {
  UNKNOWN
  BY_CHANNEL
  BY_REWARD
  BY_REDEMPTIONS
}

type CommunityPointsUpdateCustomRewardRedemptionStatusesProgress {
  channelID: ID!
  id: ID!
  method: CommunityPointsUpdateCustomRewardRedemptionStatusesMethod!
  newStatus: CommunityPointsCustomRewardRedemptionStatus!
  processed: Int!
  rewardID: ID
  total: Int!
}

type CommunityPointsUserProperties {
  lastViewedContent: [CommunityPointsLastViewedContentByTypeAndID!]
}

type CommunityPointsWatchStreakEarningSettings {
  points: Int!
  streakLength: Int!
}

type Company {
  bountyCampaigns(
    campaignID: ID
    status: BountyCampaignStatus
  ): BountyCampaignConnection
  brandPortalSettings: BrandPortalSettings
  curseCompanyID: ID
  estimatedBroadcasterViewerReach(
    gameNames: [String!]!
    targetAllBroadcasters: Boolean!
    targetVarietyBroadcasters: Boolean!
    streamLengthSeconds: Int
    targetAllCountries: Boolean = false
    targetAllGames: Boolean = false
    countries: [String!] = []
  ): BroadcasterViewerReach
  games(includeBountyBoardGames: Boolean = false): [Game!]
  id: ID!
  isCampaignsEnabled: Boolean!
  isContractSigned: Boolean!
  isLegacy: Boolean!
  name: String!
  type: OrganizationType!
  url: String!
}

type Competition {
  bannerImageURL: String
  cancelledAt: Time
  checkInDurationMinutes: Int!
  createdAt: Time!
  description: String
  endAt: Time!
  format: CompetitionFormat!
  game: Game
  id: ID!
  imageURL: String
  name: String!
  owner: User
  participantOnlyContactInfo: CompetitionContactInfo
  participantType: CompetitionParticipantType!
  participants(first: Int = 10, after: Cursor): CompetitionParticipantConnection
  phases: [CompetitionPhase!]!
  players(
    first: Int = 10
    after: Cursor
    state: CompetitionPlayerState
  ): CompetitionPlayerConnection
  prizeDescription: String
  publicContactInfo: CompetitionContactInfo
  registrationEndAt: Time!
  registrationLimit: Int!
  registrationType: RegistrationType!
  rulesDescription: String
  self: CompetitionSelfEdge
  standings(first: Int = 100, after: Cursor): CompetitionStandingConnection
  startAt: Time!
  state: CompetitionState!
  teamSize: Int!
  teams(first: Int = 10, after: Cursor): CompetitionTeamConnection
  termsURL: String
  updatedAt: Time!
  visibility: CompetitionVisibilityState!
}

enum CompetitionAutomodField {
  COMPETITION_NAME
  PCI_DISCORD
  PCI_EMAIL
  POCI_DISCORD
  POCI_EMAIL
  IMAGE_URL
  BANNER_IMAGE_URL
  TERMS_URL
  DESCRIPTION
  RULES
  PRIZE
  PLAYER_DISCORD_USERNAME
  PLAYER_IN_GAME_USERNAME
  TEAM_NAME
  UNKNOWN
}

type CompetitionConnection {
  edges: [CompetitionEdge!]!
  pageInfo: PageInfo!
}

type CompetitionContactInfo {
  discordURL: String
  email: String
}

type CompetitionEdge {
  cursor: Cursor!
  node: Competition!
}

type CompetitionError {
  automodFailedFields: [CompetitionAutomodField!]
  code: CompetitionErrorCode!
  message: String!
}

enum CompetitionErrorCode {
  REQUIRED_ARGUMENT
  INVALID_ARGUMENT
  ALREADY_EXISTS
  LIMIT_REACHED
  AUTOMOD_FAILED
  UNKNOWN
}

type CompetitionFormat {
  details: FormatTypeDetails
  type: FormatType!
}

enum CompetitionImageType {
  BANNER
  THUMBNAIL
  UNKNOWN
}

type CompetitionImageUpload {
  id: ID!
  url: String!
}

type CompetitionLobby {
  advanceNextLobby: ID
  id: ID!
  lossNextLobby: ID
  participants: [CompetitionLobbyParticipant!]
  reportedScoreCount: Int!
  state: LobbyState!
  winner: CompetitionLobbyParticipant
}

type CompetitionLobbyParticipant {
  detailedParticipant: CompetitionParticipant!
  id: ID!
  score: Int
  tiebreakerScore: Int
}

type CompetitionOrganizerCapability {
  allowedRegistrationTypes: [RegistrationType!]
  canAttachTerms: Boolean
  canCreateCompetitions: Boolean
  canManageParticipantStatus: Boolean
  canUseCustomFormat: Boolean
}

union CompetitionParticipant = CompetitionPlayer | CompetitionTeam
type CompetitionParticipantConnection {
  edges: [CompetitionParticipantEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CompetitionParticipantEdge {
  cursor: Cursor!
  node: CompetitionParticipant!
}

enum CompetitionParticipantType {
  TEAM
  SOLO
  UNKNOWN
}

type CompetitionPhase {
  id: ID!
  lobbies: [CompetitionLobby!]!
  state: PhaseState!
  type: CompetitionPhaseType
}

enum CompetitionPhaseType {
  DOUBLE_ELIMINATION_WINNERS
  DOUBLE_ELIMINATION_LOSERS
  NOT_APPLICABLE
  UNKNOWN
}

type CompetitionPlacement {
  position: Int
}

type CompetitionPlayer {
  competitionID: ID!
  createdAt: Time!
  discordUsername: String
  id: ID!
  inGameUsername: String
  isDisqualified: Boolean!
  state: CompetitionPlayerState!
  team: CompetitionTeam
  totalScore: Int!
  user: User!
}

type CompetitionPlayerConnection {
  edges: [CompetitionPlayerEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CompetitionPlayerEdge {
  cursor: Cursor!
  node: CompetitionPlayer!
}

enum CompetitionPlayerState {
  INVITED
  REGISTERED
  CHECKED_IN
  COMPETED
  DECLINED
  UNKNOWN
}

type CompetitionSelfEdge {
  isInvited: Boolean
  isOwner: Boolean
  isPlayer: Boolean
  isRegistered: Boolean
}

type CompetitionStanding {
  history: [HistoricalCompetitionLobby!]
  participant: CompetitionParticipant!
  placement: CompetitionPlacement!
  score: Int
  tiebreakerScore: Int
  winPercentage: Int
}

type CompetitionStandingConnection {
  edges: [CompetitionStandingEdge!]!
  pageInfo: PageInfo!
}

type CompetitionStandingEdge {
  cursor: Cursor!
  node: CompetitionStanding!
}

enum CompetitionState {
  UPCOMING
  PAST
  LIVE
  CHECK_IN
  READY
  CANCELLED
  UNKNOWN
}

type CompetitionTeam {
  captain: CompetitionPlayer
  competitionID: ID!
  id: ID!
  isDisqualified: Boolean!
  members: [CompetitionPlayer!]
  name: String!
  self: CompetitionTeamSelfEdge
  totalScore: Int!
}

type CompetitionTeamConnection {
  edges: [CompetitionTeamEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CompetitionTeamEdge {
  cursor: Cursor!
  node: CompetitionTeam!
}

type CompetitionTeamSelfEdge {
  isCaptain: Boolean!
}

type CompetitionUploadImageError {
  code: CompetitionUploadImageErrorCode!
  message: String!
}

enum CompetitionUploadImageErrorCode {
  REQUIRED_ARGUMENT
  INVALID_ARGUMENT
  UNKNOWN
}

enum CompetitionVisibilityState {
  PRIVATE
  PUBLIC
  UNKNOWN
}

input ComponentActivationInput {
  slot: String!
  x: Int
  y: Int
}

type ComponentView implements ExtensionView {
  aspectRatioX: Int!
  aspectRatioY: Int!
  canLinkExternalContent: Boolean!
  hasAutoscale: Boolean!
  scalePixels: Int
  targetHeight: Int!
  viewerPath: String!
  viewerURL: String!
}

input ComponentViewInput {
  aspectHeight: Int!
  aspectWidth: Int!
  hasZoom: Boolean!
  size: Float!
  viewerPath: String!
  zoomPixels: Int
}

type ConfigView implements ExtensionView {
  canLinkExternalContent: Boolean!
  viewerPath: String!
  viewerURL: String!
}

input ConfigViewInput {
  viewerPath: String!
}

input ConnectAdIdentityInput {
  mobile: MobileAdIdentityInput
  targetDeviceID: ID!
}

type ConnectAdIdentityPayload {
  identityURL: String
}

type Consent {
  id: ID!
  isDeniedUnderage: Boolean!
  privacyLawName: PrivacyLawName!
  shouldShowNotification: Boolean!
  shouldShowSettingsPage: Boolean!
  vendorConsentStatus: VendorConsent!
  vendorStatus: [VendorConsentStatus!]!
    @deprecated(reason: "Use vendorConsentStatus instead")
}

enum ConsentFeature {
  MATCH_COMBINE_OFFLINE_DATA_SOURCES
  LINK_DIFFERENT_DEVICES
  RECEIVE_USE_AUTO_SENT_DEVICE_CHARACTERISTICS_FOR_IDENTIFICATION
}

enum ConsentPurpose {
  STORE_ACCESS_INFO_ON_DEVICE
  SELECT_BASIC_ADS
  CREATE_PERSONALISED_ADS_PROFILE
  SELECT_PERSONALISED_ADS
  CREATE_PERSONALISED_CONTENT_PROFILE
  SELECT_PERSONALISED_CONTENT
  MEASURE_AD_PERFORMANCE
  MEASURE_CONTENT_PERFORMANCE
  APPLY_MARKET_RESEARCH_TO_GENERATE_AUDIENCE_INSIGHTS
  DEVELOP_IMPROVE_PRODUCTS
}

enum ConsentSpecialFeature {
  USE_PRECISE_GEO_DATA
  ACTIVELY_SCAN_DEVICE_CHARACTERISTICS_FOR_IDENTIFICATION
}

enum ConsentSpecialPurpose {
  ENSURE_SECURITY_PREVENT_FRAUD_DEBUG
  TECHNICALLY_DELIVER_ADS_CONTENT
}

enum ConsentStatus {
  GIVEN
  DENIED
}

enum ContentType {
  CLIP
  USER
  LIVE_CHANNEL @deprecated(reason: "Use 'USER' instead")
  VOD
  CATEGORY
}

type ContributeCommunityPointsCommunityGoalError {
  code: ContributeCommunityPointsCommunityGoalErrorCode!
}

enum ContributeCommunityPointsCommunityGoalErrorCode {
  NOT_CURRENTLY_REDEEMABLE
  NOT_ENOUGH_POINTS
  NOT_FOUND
  FORBIDDEN
  MAX_PER_STREAM
  TRANSACTION_IN_PROGRESS
  DUPLICATE_TRANSACTION
  USER_BANNED
  UNKNOWN
}

input ContributeCommunityPointsCommunityGoalInput {
  amount: Int!
  channelID: ID!
  goalID: ID!
  transactionID: ID!
}

type ContributeCommunityPointsCommunityGoalPayload {
  error: ContributeCommunityPointsCommunityGoalError
}

type ContributeToChallengeError {
  code: ContributeToChallengeErrorCode!
}

enum ContributeToChallengeErrorCode {
  CHALLENGE_NOT_FOUND
  CHALLENGE_NOT_ACTIVE
  INVALID_CHANNEL_ID
  INSUFFICIENT_BITS_BALANCE
  USER_FORBIDDEN
  UNKNOWN
}

input ContributeToChallengeInput {
  bits: Int!
  challengeID: ID!
  userID: ID!
}

type ContributeToChallengePayload {
  challengeParticipant: ChannelChallengeParticipant
  error: ContributeToChallengeError
}

enum CookieVendorType {
  ESSENTIAL
  ANALYTICS
  ADVERTISING
}

type CopyrightClaim {
  id: ID!
  claimant: CopyrightClaimant!
  work: String!
  date: Time!
}

type CopyrightClaimant {
  name: String!
  email: String!
}

type CopyrightClaimConnection {
  edges: [CopyrightClaimEdge!]
  pageInfo: PageInfo!
}

input CopyrightClaimContact {
  relationship: String!
  ownerName: String!
  claimantName: String!
  phoneNumber: String!
  emailAddress: String!
  twitchEmail: String!
  country: String!
  city: String!
  streetAddress: String!
  stateOrProvince: String!
  zipCode: String!
}

type CopyrightClaimEdge {
  cursor: Cursor!
  node: CopyrightClaim!
}

input CopyrightedWork {
  description: String!
  type: CopyrightedWorkType!
  url: String!
}

enum CopyrightedWorkType {
  OTHER
  VIDEO
  IMAGE_OR_PHOTO
  ARTWORK
  MUSIC
}

input CopyrightTimeOffset {
  startTimeSeconds: Int!
  endTimeSeconds: Int
}

type CreateArchivedEmoteError {
  code: CreateArchivedEmoteErrorCode!
}

enum CreateArchivedEmoteErrorCode {
  USER_OWNED_EMOTE_LIMIT_REACHED
  INVALID_OWNER
  EMOTE_CODE_UNACCEPTABLE
  INCOMPLETE_EMOTE_IMAGE_DATA
  INVALID_CODE_SUFFIX
  INVALID_IMAGE_UPLOAD
  EMOTE_IMAGE_NOT_FOUND
  NOT_ENOUGH_EMOTE_IMAGE_ASSETS
  TOO_MANY_EMOTE_IMAGE_ASSETS
  INVALID_EMOTE_ASSET_TYPE
  INVALID_EMOTE_STATE
  TOO_MANY_EMOTE_GROUPS
  EMOTE_MISSING_STATIC_ASSET
  EMOTE_MISSING_ANIMATED_ASSET
  UNKNOWN_ERROR
}

input CreateArchivedEmoteInput {
  assetType: EmoteAssetType
  code: String!
  codeSuffix: String!
  imageAssets: [EmoteImageAssetInput!]!
}

type CreateArchivedEmotePayload {
  emote: Emote
  error: CreateArchivedEmoteError
}

type CreateBadgeFlairError {
  code: CreateBadgeFlairErrorCode!
  message: String!
}

enum CreateBadgeFlairErrorCode {
  INVALID_CHANNEL_ID
  INVALID_FLAIR_IMAGE_1X_ID
  INVALID_FLAIR_IMAGE_2X_ID
  INVALID_FLAIR_IMAGE_4X_ID
  INVALID_TIER
}

input CreateBadgeFlairInput {
  channelID: ID!
  image1xID: ID!
  image2xID: ID!
  image4xID: ID!
  tier: CreatorBadgeFlairTier!
}

type CreateBadgeFlairPayload {
  error: CreateBadgeFlairError
}

input CreateBitsChallengeConditionForExtensionInput {
  bitsRecipientWeightedShares: [BitsChallengeConditionPoolRecipientWeightedShare!]
  description: String
  disableWhenSatisfied: Boolean!
  extensionID: ID!
  extensionInstallationChannelID: ID
  name: String!
  timeoutAt: Time
}

type CreateBitsChallengeConditionForExtensionPayload {
  condition: ChallengeCondition
  error: CreateChallengeConditionError
}

input CreateBitsChallengeConditionParticipantForExtensionInput {
  bitsAmount: Int!
  conditionID: ID!
  conditionOwnerID: ID!
  extensionID: ID!
  ttlSeconds: Int!
}

type CreateBitsChallengeConditionParticipantForExtensionPayload {
  conditionParticipant: ChallengeConditionParticipant
  error: CreateChallengeConditionParticipantError
}

input CreateBountyCampaignInput {
  availablePlatforms: [String!]
  blacklistedBroadcasters: [ID!]
  boxArtURL: String
  broadcasterMessage: String
  broadcasterMultiplier: Float!
  budgetCents: Int!
  chatCTAs: [BountyCampaignChatCTAInput!]
  contentID: ID
  coverURL: String
  displayName: String
  endAt: Time!
  isPromotionEligible: Boolean
  organizationID: ID!
  shouldAllowAllGames: Boolean
  sponsor: String
  startAt: Time!
  streamLengthMinutes: Int
  streamLengthSeconds: Int
  targetAllBroadcasters: Boolean
  targetAllCountries: Boolean
  targetAllGames: Boolean
  targetPromotionalVideoClicks: Int
  targetVarietyBroadcasters: Boolean
  targetedCountries: [String!]
  targetedGames: [String!]
  title: String!
  trackingPixels: [TrackingPixelInput!]
  type: BountyCampaignType
  videoURL: String
  videos: [BountyCampaignVideoInput!]
}

type CreateBountyCampaignPayload {
  campaign: BountyCampaign
}

input CreateBountyCampaignUploadConfigInput {
  organizationID: ID!
  uploadType: BountyCampaignUploadType!
}

type CreateBountyCampaignUploadConfigPayload {
  imageID: ID
  uploadID: ID
  uploadURL: String
}

input CreateCelebrationInput {
  area: CelebrationArea!
  channelID: ID!
  durationMilliseconds: Int!
  effect: CelebrationEffect!
  eventThreshold: Int!
  eventType: CelebrationEventType!
  intensity: Int!
  isEnabled: Boolean!
}

type CreateCelebrationPayload {
  celebration: Celebration
  error: CelebrationError
}

type CreateChallengeConditionError {
  code: CreateChallengeConditionErrorCode!
}

enum CreateChallengeConditionErrorCode {
  BITS_RECIPIENT_INELIGIBLE
  UNKNOWN
}

type CreateChallengeConditionParticipantError {
  code: CreateChallengeConditionParticipantErrorCode!
}

enum CreateChallengeConditionParticipantErrorCode {
  BITS_BENEFACTOR_INELIGIBLE
  INSUFFICIENT_BITS_BALANCE
  CONDITION_NOT_ACTIVE
  CONDITION_NOT_FOUND
  EFFECT_TYPE_UNSUPPORTED_BY_CONDITION
  UNKNOWN
}

input CreateChanletInput {
  channelID: ID!
}

type CreateChanletPayload {
  chanlet: Channel!
  channelID: ID!
}

type CreateClipError {
  code: CreateClipErrorCode
}

enum CreateClipErrorCode {
  CHANNEL_NOT_CLIPPABLE
  CHANNEL_BANNED
  USER_BANNED
  USER_TIMED_OUT
  CHANNEL_NOT_LIVE
  REQUEST_THROTTLED
  USER_RESTRICTED
  UNKNOWN
}

input CreateClipInput {
  broadcastID: ID
  broadcasterID: ID!
  offsetSeconds: Float!
  videoID: ID
}

type CreateClipPayload {
  clip: Clip
  error: CreateClipError
}

input CreateCollectionInput {
  description: String
  ownerID: ID!
  title: String!
}

type CreateCollectionPayload {
  collection: Collection
}

type CreateCommunityPointsCommunityGoalError {
  code: CreateCommunityPointsCommunityGoalErrorCode!
}

enum CreateCommunityPointsCommunityGoalErrorCode {
  DUPLICATE_GOAL
  TITLE_AUTOMOD_FAILED
  TITLE_INVALID
  DESCRIPTION_AUTOMOD_FAILED
  DESCRIPTION_INVALID
  GOAL_AMOUNT_INVALID
  DURATION_INVALID
  BACKGROUND_COLOR_INVALID
  TOO_MANY_GOALS
  FORBIDDEN
  UNKNOWN
}

input CreateCommunityPointsCommunityGoalInput {
  amountNeeded: Int!
  backgroundColor: String!
  channelID: ID!
  description: String
  durationDays: Int!
  title: String!
}

type CreateCommunityPointsCommunityGoalPayload {
  error: CreateCommunityPointsCommunityGoalError
  goal: CommunityPointsCommunityGoal
}

type CreateCommunityPointsCustomRewardError {
  code: CreateCommunityPointsCustomRewardErrorCode!
  maxRewards: Int
}

enum CreateCommunityPointsCustomRewardErrorCode {
  UNKNOWN
  FORBIDDEN
  TITLE_AUTOMOD_FAILED
  PROMPT_AUTOMOD_FAILED
  COST_INVALID
  MAX_PER_STREAM_INVALID
  TOO_MANY_REWARDS
  TITLE_INVALID
  DUPLICATE_REWARD
  BACKGROUND_COLOR_INVALID
  TEMPLATE_INVALID
  MAX_PER_USER_PER_STREAM_INVALID
  GLOBAL_COOLDOWN_INVALID
}

input CreateCommunityPointsCustomRewardInput {
  backgroundColor: String
  channelID: ID!
  cost: Int!
  globalCooldownSetting: CommunityPointsCustomRewardGlobalCooldownSettingInput
  isSubOnly: Boolean!
  isUserInputRequired: Boolean!
  maxPerStreamSetting: CommunityPointsCustomRewardMaxPerStreamSettingInput
  maxPerUserPerStreamSetting: CommunityPointsCustomRewardMaxPerUserPerStreamSettingInput
  prompt: String
  shouldRedemptionsSkipRequestQueue: Boolean = false
  templateID: ID
  title: String!
}

type CreateCommunityPointsCustomRewardPayload {
  error: CreateCommunityPointsCustomRewardError
  reward: CommunityPointsCustomReward
}

type CreateCommunityPointsImageUploadInfoError {
  code: CreateCommunityPointsImageUploadInfoErrorCode
}

enum CreateCommunityPointsImageUploadInfoErrorCode {
  FORBIDDEN
  MORE_THAN_ONE_TYPE
  CUSTOM_REWARD_NOT_FOUND
}

input CreateCommunityPointsImageUploadInfoInput {
  automaticRewardType: CommunityPointsAutomaticRewardType
  channelID: ID!
  customRewardID: ID
  goalID: ID
  icon: Boolean
}

type CreateCommunityPointsImageUploadInfoPayload {
  error: CreateCommunityPointsImageUploadInfoError
  uploadInfoLarge: CommunityPointsImageUploadInfo
  uploadInfoMedium: CommunityPointsImageUploadInfo
  uploadInfoSmall: CommunityPointsImageUploadInfo
}

input CreateCompetitionContactInfoInput {
  discordURL: String
  email: String
}

input CreateCompetitionInput {
  bannerImageURL: String
  checkInDurationMinutes: Int!
  description: String
  endAt: Time!
  formatType: FormatType!
  gameID: ID!
  imageURL: String
  leaderboardDetails: CreateCompetitionLeaderboardDetailsInput
  name: String!
  ownerID: ID
  participantOnlyContactInfo: CreateCompetitionContactInfoInput
  participantType: CompetitionParticipantType!
  prizeDescription: String
  publicContactInfo: CreateCompetitionContactInfoInput
  registrationEndAt: Time!
  registrationLimit: Int = 100
  registrationType: RegistrationType!
  rulesDescription: String
  startAt: Time!
  state: CompetitionState
  teamSize: Int!
  termsURL: String
}

input CreateCompetitionLeaderboardDetailsInput {
  lobbyMaxSize: Int!
  phaseCount: Int!
  tiebreakerLabel: TiebreakerLabel
}

type CreateCompetitionPayload {
  competition: Competition
  error: CompetitionError
}

input CreateContentTagsInput {
  authorID: ID!
  contentID: ID!
  contentType: ContentType!
  tagIDs: [ID!]!
}

type CreateContentTagsPayload {
  content: TaggedContent
}

type CreateCrowdChantError {
  code: CreateCrowdChantErrorCode!
}

enum CreateCrowdChantErrorCode {
  CHANT_ALREADY_ACTIVE
  NOT_ELIGIBLE
  FORBIDDEN
  AUTOMOD_FAILED
  CHANNEL_SETTINGS
  MESSAGE_REJECTED
  UNKNOWN
}

input CreateCrowdChantInput {
  channelID: ID!
  text: String!
}

type CreateCrowdChantPayload {
  error: CreateCrowdChantError
  chant: CrowdChant
}

enum CreateDashboardViewMosaicLayoutErrorCode {
  UNKNOWN
  CUSTOM_LIMIT_EXCEEDED
  INVALID_ARGUMENT_NAME
  INVALID_ARGUMENT_USERID
  INVALID_ARGUMENT_TYPE
  INVALID_ARGUMENT_LAYOUT
  INVALID_ARGUMENT_VERSION
  INVALID_ARGUMENT_CHANNELID
  INVALID_ARGUMENT
}

input CreateDashboardViewMosaicLayoutInput {
  channelID: ID!
  data: MosaicData!
  name: String!
  type: ChannelDashboardViewType!
  version: String!
}

type CreateDashboardViewMosaicLayoutPayload {
  errorCode: CreateDashboardViewMosaicLayoutErrorCode
  layout: ChannelDashboardLayout
}

input CreateDropBenefitInput {
  accountLinkURL: String!
  benefitID: ID!
  benefitName: String!
  entitlementLimit: Int!
  gameID: ID!
  isIosAvailable: Boolean
  ownerID: ID!
}

type CreateDropBenefitPayload {
  dropBenefit: DropBenefit
  error: DropsError
}

input CreateDropCampaignInput {
  accountLinkURL: String!
  campaignType: CampaignType
  description: String!
  detailsURL: String!
  endAt: Time!
  gameID: ID!
  name: String!
  ownerID: ID!
  startAt: Time!
}

type CreateDropCampaignPayload {
  dropCampaign: DropCampaign
  error: DropsError
}

enum CreateDropImageUploadURLErrorCode {
  USER_UNAUTHORIZED
    @deprecated(
      reason: "Drops 1.0 is deprecated, use Drops 2.0/DropImageUpload instead."
    )
  SERVICE_DEPENDENCY_FAILURE
    @deprecated(
      reason: "Drops 1.0 is deprecated, use Drops 2.0/DropImageUpload instead."
    )
  UNKNOWN
    @deprecated(
      reason: "Drops 1.0 is deprecated, use Drops 2.0/DropImageUpload instead."
    )
}

input CreateDropImageUploadURLInput {
  campaignID: ID
  imageType: DropImageType!
  itemID: ID
  serviceID: ID!
  token: String!
}

type CreateDropImageUploadURLPayload {
  error: CreateDropImageUploadURLErrorCode
    @deprecated(
      reason: "Drops 1.0 is deprecated, use Drops 2.0/DropImageUpload instead."
    )
  uploadID: ID
    @deprecated(
      reason: "Drops 1.0 is deprecated, use Drops 2.0/DropImageUpload instead."
    )
  url: String
    @deprecated(
      reason: "Drops 1.0 is deprecated, use Drops 2.0/DropImageUpload instead."
    )
}

enum CreateExtensionClientError {
  INVALID_NAME
  NAME_IN_USE
}

input CreateExtensionClientInput {
  name: String!
  organizationID: ID
  redirectURI: String!
}

type CreateExtensionClientPayload {
  client: ExtensionClient
  error: CreateExtensionClientError
}

type CreateExtensionImageUploadInfoError {
  code: CreateExtensionImageUploadInfoErrorCode!
  maximum: Int
  minimum: Int
}

enum CreateExtensionImageUploadInfoErrorCode {
  UNAUTHORIZED
  INVALID_VERSION
  NOT_ENOUGH_UPLOAD_DISCOVERY_IMAGE
  NOT_ENOUGH_UPLOAD_LOGO_IMAGE
  NOT_ENOUGH_UPLOAD_SCREENSHOT_IMAGE
  NOT_ENOUGH_UPLOAD_TASKBAR_IMAGE
  TOO_MANY_UPLOAD_DISCOVERY_IMAGE
  TOO_MANY_UPLOAD_LOGO_IMAGE
  TOO_MANY_UPLOAD_SCREENSHOT_IMAGE
  TOO_MANY_UPLOAD_TASKBAR_IMAGE
}

input CreateExtensionImageUploadInfoInput {
  discovery: Boolean
  extensionID: ID!
  logo: Boolean
  screenshots: Int
  taskbar: Boolean
}

type CreateExtensionImageUploadInfoPayload {
  discovery: ExtensionImageUploadResponse
  error: CreateExtensionImageUploadInfoError
  logo: ExtensionImageUploadResponse
  screenshots: [ExtensionImageUploadResponse]
  taskbar: ExtensionImageUploadResponse
}

enum CreateExtensionZipUploadInfoError {
  UNAUTHORIZED
  INVALID_VERSION
}

input CreateExtensionZipUploadInfoInput {
  extensionID: ID!
  filename: String
}

type CreateExtensionZipUploadInfoPayload {
  error: CreateExtensionZipUploadInfoError
  response: ExtensionZipUploadResponse
}

type CreateFollowerEmoteError {
  code: CreateFollowerEmoteErrorCode!
}

enum CreateFollowerEmoteErrorCode {
  USER_OWNED_EMOTE_LIMIT_REACHED
  INVALID_OWNER
  EMOTE_CODE_UNACCEPTABLE
  INCOMPLETE_EMOTE_IMAGE_DATA
  INVALID_CODE_SUFFIX
  INVALID_IMAGE_UPLOAD
  EMOTE_IMAGE_NOT_FOUND
  NOT_ENOUGH_EMOTE_IMAGE_ASSETS
  TOO_MANY_EMOTE_IMAGE_ASSETS
  INVALID_EMOTE_ASSET_TYPE
  INVALID_EMOTE_STATE
  TOO_MANY_EMOTE_GROUPS
  EMOTE_MISSING_STATIC_ASSET
  EMOTE_MISSING_ANIMATED_ASSET
  UNKNOWN_ERROR
}

input CreateFollowerEmoteInput {
  assetType: EmoteAssetType
  groupIDs: [ID!]!
  code: String!
  codeSuffix: String!
  imageAssets: [EmoteImageAssetInput!]!
}

type CreateFollowerEmotePayload {
  emote: Emote
  error: CreateFollowerEmoteError
}

input CreateFriendRequestInput {
  targetID: ID!
}

type CreateFriendRequestPayload {
  user: User
}

type CreateGameApplicationError {
  code: CreateGameApplicationErrorCode
}

enum CreateGameApplicationErrorCode {
  GAME_HAS_ALREADY_BEEN_OWNED
  PERMISSION_DENIED
  INTERNAL_ERROR
}

input CreateGameApplicationInput {
  companyID: ID!
  gameID: ID!
}

type CreateGameApplicationPayload {
  error: CreateGameApplicationError
  gameApplication: GameApplication
}

input CreateGameBoxArtUploadURLInput {
  gameID: ID!
}

type CreateGameBoxArtUploadURLPayload {
  response: CreateGameBoxArtUploadURLResponse
}

type CreateGameBoxArtUploadURLResponse {
  uploadID: ID!
  url: String!
}

input CreateLoyaltyBadgeInput {
  channelID: ID!
  image1xID: ID!
  image2xID: ID!
  image4xID: ID!
  requiredTenureMonths: Int!
}

type CreateLoyaltyBadgePayload {
  badge: LoyaltyBadge
  errorCode: CreateLoyaltyBadgeResponseCode
}

enum CreateLoyaltyBadgeResponseCode {
  ERR_INVALID_USER
  ERR_INVALID_BADGE_IMAGE_1X_ID
  ERR_INVALID_BADGE_IMAGE_2X_ID
  ERR_INVALID_BADGE_IMAGE_4X_ID
  ERR_INVALID_BADGE_REQUIRED_TENURE_MONTHS
  ERR_BADGE_EXISTS
  ERR_BADGE_TIMEOUT
  ERR_UNKNOWN
}

input CreateLoyaltyBadgeUploadConfigInput {
  channelID: ID!
  size: Int!
}

type CreateLoyaltyBadgeUploadConfigPayload {
  errorCode: CreateLoyaltyBadgeUploadConfigResponseCode
  uploadConfig: LoyaltyBadgeUploadConfig
}

enum CreateLoyaltyBadgeUploadConfigResponseCode {
  ERR_INVALID_USER
  ERR_INVALID_BADGE_SIZE
  ERR_UNKNOWN
}

input CreateModeratorCommentInput {
  channelID: ID!
  targetID: ID!
  text: String!
}

type CreateModeratorCommentPayload {
  comment: ModLogsComment
}

input CreateMultiVideoHighlightInput {
  metadata: CreateMultiVideoHighlightMetadata!
}

input CreateMultiVideoHighlightMetadata {
  creatorID: ID!
  description: String!
  game: ID
  highlightRanges: [HighlightRange!]!
  language: String!
  tags: [String!]!
  title: String!
}

type CreateMultiVideoHighlightPayload {
  highlight: Video
}

input CreateMultiviewContentAttributeImageUploadConfigInput {
  channelID: ID!
}

type CreateMultiviewContentAttributeImageUploadConfigPayload {
  channel: Channel
  imageURL: String!
  uploadID: ID!
  uploadURL: String!
}

input CreateMultiviewContentAttributesInput {
  params: [MultiviewContentAttributeParams!]!
}

type CreateMultiviewContentAttributesPayload {
  failedCreates: [MultiviewContentAttribute!]!
  succeededCreates: [MultiviewContentAttribute!]!
}

type CreateOrganizationApplicationError {
  code: CreateOrganizationApplicationErrorCode
}

enum CreateOrganizationApplicationErrorCode {
  INTERNAL_ERROR
  INVALID_ARGUMENT
  ALREADY_EXISTS
}

input CreateOrganizationApplicationInput {
  city: String
  contactEmail: String
  contactFirstName: String!
  contactLastName: String!
  contactTitle: String!
  country: String!
  gameIDs: [ID!]
  industry: String!
  joinReason: String
  organizationName: String!
  productInterest: String
  size: String!
  state: String
  type: OrganizationType!
  userID: ID
  website: String!
}

type CreateOrganizationApplicationPayload {
  applicationID: ID
  error: CreateOrganizationApplicationError
}

type CreateOrganizationInviteError {
  code: CreateOrganizationInviteErrorCode!
}

enum CreateOrganizationInviteErrorCode {
  INTERNAL_ERROR
  INVALID_ARGUMENT
  ALREADY_EXISTS
  PERMISSION_DENIED
  USER_NOT_FOUND
  MEMBER_INELIGIBLE
}

input CreateOrganizationInviteInput {
  inviteeTwitchID: ID!
  inviterTwitchID: ID!
  organizationID: ID!
  role: OrganizationMemberRole!
}

type CreateOrganizationInvitePayload {
  error: CreateOrganizationInviteError
  invite: OrganizationInvite
}

type CreateOrganizationJWTError {
  code: CreateOrganizationJWTErrorCode!
}

enum CreateOrganizationJWTErrorCode {
  PERMISSION_DENIED
  INVALID_ARGUMENT
}

input CreateOrganizationJWTInput {
  operation: String!
  organizationID: ID!
}

type CreateOrganizationJWTPayload {
  error: CreateOrganizationJWTError
  jwt: String
}

type CreateOrganizationMemberError {
  code: CreateOrganizationMemberErrorCode!
}

enum CreateOrganizationMemberErrorCode {
  ALREADY_EXISTS
  PERMISSION_DENIED
  USER_NOT_FOUND
  MEMBER_INELIGIBLE
}

input CreateOrganizationMemberInput {
  email: String!
  firstName: String!
  lastName: String!
  organizationID: ID!
  role: OrganizationMemberRole!
  title: String!
  userID: ID!
}

type CreateOrganizationMemberPayload {
  error: CreateOrganizationMemberError
  organizationMember: OrganizationMember
}

type CreatePanelImageUploadInfo {
  uploadID: ID!
  url: String!
}

input CreatePanelImageUploadInfoInput {
  channelID: ID!
  height: Int!
  left: Int!
  top: Int!
  width: Int!
}

type CreatePanelImageUploadInfoPayload {
  uploadInfo: CreatePanelImageUploadInfo
}

input CreatePanelInput {
  channelID: ID!
  description: String
  imageURL: String
  linkURL: String
  slotID: String
  title: String
  type: PanelType!
}

type CreatePanelPayload {
  panel: Panel!
}

input CreatePartnershipApplicationInput {
  category: String!
  country: String!
  description: String!
  fullName: String!
  language: String!
}

type CreatePartnershipApplicationPayload {
  partnershipApplication: PartnershipApplication
}

input CreatePollChoiceInput {
  title: String!
}

type CreatePollError {
  code: CreatePollErrorCode!
}

enum CreatePollErrorCode {
  AUTOMOD_FAILED
  POLL_ALREADY_ACTIVE
  CHANNEL_NOT_BITS_ENABLED
  UNKNOWN
}

input CreatePollInput {
  bitsCost: Int = 0
  bitsVoting: Boolean = false
  choices: [CreatePollChoiceInput!]!
  communityPointsCost: Int = 0
  durationSeconds: Int!
  isCommunityPointsVotingEnabled: Boolean = false
  multichoiceEnabled: Boolean = true
  ownedBy: ID!
  subscriberMultiplier: Boolean = false
  subscriberOnly: Boolean = false
  title: String!
}

type CreatePollPayload {
  error: CreatePollError
  poll: Poll
}

input CreatePostInput {
  body: String!
  channelID: ID!
  embedURLs: [String!]
  postToTwitter: Boolean
}

type CreatePostPayload {
  post: Post
  tweet: String
  tweetStatus: Int!
}

type CreatePredictionEventError {
  code: CreatePredictionEventErrorCode!
  maxOutcomes: Int
  maxPredictionWindowSeconds: Int
}

enum CreatePredictionEventErrorCode {
  FORBIDDEN
  AUTOMOD_FAILED
  EVENT_ALREADY_ACTIVE
  CHANNEL_POINTS_NOT_ENABLED
  COLORS_NOT_UNIQUE
  NOT_ENOUGH_OUTCOMES
  TOO_MANY_OUTCOMES
  INVALID_PREDICTION_WINDOW
  UNKNOWN
}

input CreatePredictionEventInput {
  channelID: ID!
  outcomes: [CreatePredictionOutcomeInput!]!
  predictionWindowSeconds: Int!
  title: String!
}

type CreatePredictionEventPayload {
  error: CreatePredictionEventError
  predictionEvent: PredictionEvent
}

input CreatePredictionOutcomeInput {
  color: PredictionOutcomeColor!
  title: String!
}

type CreateRaidError {
  code: CreateRaidErrorCode!
}

enum CreateRaidErrorCode {
  ALREADY_RAIDING
  CANNOT_RAID_YOURSELF
  CANNOT_RAID_THIS_CHANNEL
  INVALID_CHANNEL
  TOO_MANY_VIEWERS_TO_RAID
}

input CreateRaidInput {
  sourceID: ID!
  targetID: ID!
}

type CreateRaidPayload {
  error: CreateRaidError
  raid: Raid
}

input CreateRewardedVideoTokenInput {
  userID: ID!
}

type CreateRewardedVideoTokenPayload {
  token: String
}

type CreateRoomError {
  code: CreateRoomErrorCode!
  maxAllowedRooms: Int
  maxLength: Int
  minLength: Int
}

enum CreateRoomErrorCode {
  NAME_LENGTH_INVALID
  NAME_CONTAINS_INVALID_CHARACTERS
  NAME_INAPPROPRIATE
  NAME_NOT_UNIQUE
  TOPIC_LENGTH_INVALID
  TOPIC_INAPPROPRIATE
  MAX_ROOMS_LIMIT_EXCEEDED
  ROLES_INVALID
}

input CreateRoomInput {
  isPreviewable: Boolean
  minimumAllowedRole: RoomRole
  minimumReadMessagesRole: RoomRole
  minimumSendMessagesRole: RoomRole
  name: String!
  topic: String!
}

type CreateRoomPayload {
  error: CreateRoomError
  room: Room
}

enum CreateScheduleError {
  ALREADY_EXISTS
  PERMISSION_DENIED
}

input CreateScheduleInput {
  channelID: ID!
}

type CreateSchedulePayload {
  channel: Channel
  error: CreateScheduleError
}

type CreateScheduleSegmentError {
  code: CreateScheduleSegmentErrorCode!
  conflictingSegment: ScheduleSegment
  maximum: Int
  minimum: Int
}

enum CreateScheduleSegmentErrorCode {
  PERMISSION_DENIED
  NOT_FOUND
  INVALID_CATEGORY_COUNT
  OVERLAPPING_SEGMENTS
  INVALID_TITLE
  TITLE_FAILED_MODERATION
  INVALID_TIMEZONE
  INVALID_CATEGORIES
  INVALID_START_DAY
  INVALID_START_HOUR
  INVALID_START_MINUTE
  INVALID_DURATION
  INVALID_SEGMENT
  INVALID_ARGUMENT
  INVALID_SEGMENT_COUNT
  REPEAT_ENDS_AFTER_COUNT_INVALID
  FIRST_OCCURRENCE_DATE_IN_PAST
}

input CreateScheduleSegmentInput {
  categories: [ID!]!
  durationMinutes: Int
  firstOccurrenceDate: Time
  repeatEndsAfterCount: Int
  scheduleID: ID!
  start: SegmentStartTimeInput
  timezone: String!
  title: String
}

type CreateScheduleSegmentPayload {
  error: CreateScheduleSegmentError
  schedule: Schedule
}

enum CreateSocialMediaError {
  FAILED_TITLE_MODERATION
  TITLE_TOO_LONG
  INVALID_URL
  TOO_MANY
}

input CreateSocialMediaInput {
  channelID: ID!
  title: String!
  url: String!
}

type CreateSocialMediaPayload {
  channel: Channel
  error: CreateSocialMediaError
}

type CreateSquadStreamInvitationError {
  code: CreateSquadStreamInvitationErrorCode!
}

enum CreateSquadStreamInvitationErrorCode {
  SQUAD_FULL
  USER_CANNOT_ACCESS_SQUADS
  USER_ALREADY_IN_SQUAD
  INVITATION_ALREADY_EXISTS
  INVITATION_BLOCKED
  INVITATION_INVALID
  UNAUTHORIZED
}

input CreateSquadStreamInvitationInput {
  recipientUserID: ID!
  senderUserID: ID!
}

type CreateSquadStreamInvitationPayload {
  error: CreateSquadStreamInvitationError
  squadStream: SquadStream
}

input CreateStuccoInput {
  channelID: ID!
  description: String!
  imageData1x: String!
  imageData2x: String!
  imageData4x: String!
  suffix: String!
}

input CreateStuccoPackInput {
  channelID: ID!
  stuccos: [CreateStuccoPackItemInput!]
}

input CreateStuccoPackItemInput {
  slotIndex: Int!
  stuccoID: ID!
}

type CreateStuccoPackPayload {
  stuccoPack: StuccoPack
}

type CreateStuccoPayload {
  stucco: Stucco
}

type CreateUnbanRequestError {
  code: CreateUnbanRequestErrorCode!
}

enum CreateUnbanRequestErrorCode {
  ALREADY_CREATED
  NOT_BANNED
  TOO_SOON_SINCE_BAN
  UNBAN_REQUESTS_DISABLED
  UNKNOWN
}

input CreateUnbanRequestInput {
  channelID: ID!
  requesterMessage: String!
}

type CreateUnbanRequestPayload {
  error: CreateUnbanRequestError
  unbanRequest: UnbanRequest
}

input CreateVideoAppealInput {
  city: String!
  country: String!
  fullName: String!
  state: String!
  streetAddress1: String!
  streetAddress2: String
  trackAppeals: [TrackAppealRequestInput!]!
  videoID: ID!
  zipcode: String!
}

type CreateVideoAppealPayload {
  videoID: ID
}

type CreateVideoBookmarkError {
  code: CreateVideoBookmarkErrorCode
}

enum CreateVideoBookmarkErrorCode {
  BROADCASTER_NOT_LIVE
  ARCHIVES_DISABLED
  BROADCAST_FORMAT_INVALID_RERUN
  BROADCAST_FORMAT_INVALID_PREMIERE
  VOD_NOT_READY
  INTERNAL_SERVER_ERROR
  USER_UNAUTHORIZED
  MAX_DESCRIPTION_LENGTH_EXCEEDED
}

input CreateVideoBookmarkInput {
  broadcastID: ID
  channelID: ID
  description: String
  medium: String!
  platform: String!
}

type CreateVideoBookmarkPayload {
  error: CreateVideoBookmarkError
  videoBookmark: VideoBookmark
}

input CreateVideoCommentInput {
  commentID: ID
  contentOffsetSeconds: Int!
  message: String!
  videoID: ID!
}

type CreateVideoCommentPayload {
  comment: VideoComment!
}

input CreateVideoHighlightInput {
  endOffsetSeconds: Int!
  metadata: CreateVideoHighlightMetadata!
  sourceVideoID: ID!
  startOffsetSeconds: Int!
}

input CreateVideoHighlightMetadata {
  description: String!
  game: ID
  language: String!
  tags: [String!]!
  title: String!
}

type CreateVideoHighlightPayload {
  highlight: Video!
}

input CreateVideoThumbnailUploadRequestInput {
  cropH: Int!
  cropW: Int!
  cropX: Int!
  cropY: Int!
  videoID: ID!
}

type CreateVideoThumbnailUploadRequestPayload {
  url: String
}

type CreatorBadgeFlair {
  setting: CreatorBadgeFlairSetting
  assets: [CreatorBadgeFlairAsset!]
}

type CreatorBadgeFlairAsset {
  tier: CreatorBadgeFlairTier!
  image1xURL: String!
  image2xURL: String!
  image4xURL: String!
}

enum CreatorBadgeFlairSetting {
  NONE
  DEFAULT
  CUSTOM
}

enum CreatorBadgeFlairTier {
  TIER_2
  TIER_3
}

type CreatorCampArticle {
  id: ID!
  locale: String!
  previewImage: String
  previewText: String
  title: String!
  url: String!
  videoDurationSeconds: Int
  videoURL: String
}

type CreatorCampCategory {
  articles: [CreatorCampArticle!]!
  id: ID!
  title: String!
}

type CreatorDashboard {
  channelAnalytics: ChannelAnalytics
}

type CreatorGifting {
  id: ID!
  subscriptionsBalance: Int
}

type CreatorHome {
  id: ID!
  clusters: [CreatorHomeCluster!]
  panels: [CreatorHomePanel!]
}

interface CreatorHomeCard {
  type: String!
  error: CreatorHomeError
}

type CreatorHomeCluster {
  id: ID!
}

type CreatorHomeError {
  code: CreatorHomeErrorCode!
}

enum CreatorHomeErrorCode {
  UNKNOWN
  LOADER_FAILED
}

type CreatorHomePanel {
  type: CreatorHomePanelType!
  cards: [CreatorHomeCard!]!
}

enum CreatorHomePanelType {
  HERO
  SHORTCUTS
  ACTIONS
  TIPS
}

type CreatorMetricsByInterval {
  items: [CreatorMetricsByIntervalItem]
}

type CreatorMetricsByIntervalItem {
  adBreaksInSecondsString: String!
  adSecondsPerHour: Float!
  averageViewers: Float!
  clipViewsString: String!
  clipsCreatedString: String!
  followsString: String!
  hostRaidsPercentage: Float!
  liveViewsString: String!
  maxViewersString: String!
  minutesStreamedString: String!
  minutesWatchedString: String!
  newSubscriptionsString: String!
  promotionClickString: String!
  promotionDisplayString: String!
  timestamp: Time!
  totalChatMessagesString: String!
  totalChattersString: String!
  uniqueViewersString: String!
}

type CreatorOnboardingContent {
  firstSeenAt: Time
  id: ID!
}

type CreatorReferralLink {
  description: String!
  id: ID!
  imageURL: String!
  title: String!
  url: String!
}

type CreatorReferralLinkConnection {
  edges: [CreatorReferralLinkEdge!]!
  pageInfo: PageInfo!
}

type CreatorReferralLinkEdge {
  cursor: Cursor!
  node: CreatorReferralLink!
}

type CreatorReferralLinkStat {
  link: CreatorReferralLink!
  referralCount: Int!
}

type CreatorReferralSummary {
  averageReferrals: Int!
  days: [CreatorReferralSummaryDay!]!
  totalReferrals: Int!
  trend: CreatorReferralTrend!
}

type CreatorReferralSummaryDay {
  date: Time!
  linkStats: [CreatorReferralLinkStat!]!
  referralCountSum: Int!
}

enum CreatorReferralTrend {
  POSITIVE
  NEUTRAL
  NEGATIVE
}

type CreatorTimeseriesItem {
  minutesStreamed: Int
  timestamp: Time!
  value: Float!
}

type CreatorTimeseriesMetric {
  items: [CreatorTimeseriesItem!]
  total: Int!
}

type CreatorTimeseriesMetrics {
  adBreaksInSeconds: CreatorTimeseriesMetric!
  adTimePerHour: CreatorTimeseriesMetric!
  averageViewers: CreatorTimeseriesMetric!
  chatMessages: CreatorTimeseriesMetric!
  clipViews: CreatorTimeseriesMetric!
  clipsCreated: CreatorTimeseriesMetric!
  follows: CreatorTimeseriesMetric!
  granularity: Granularity!
  hostRaidViewers: CreatorTimeseriesMetric!
  liveViews: CreatorTimeseriesMetric!
  maxViewers: CreatorTimeseriesMetric!
  minutesWatched: CreatorTimeseriesMetric!
  newSubscriptions: CreatorTimeseriesMetric!
  promotionClick: CreatorTimeseriesMetric!
  promotionDisplay: CreatorTimeseriesMetric!
  timeStreamed: CreatorTimeseriesMetric!
  uniqueChatters: CreatorTimeseriesMetric!
  uniqueViewers: CreatorTimeseriesMetric!
}

type CreditChargeModel {
  amount: Int!
  creditType: CreditType!
}

enum CreditType {
  NO_CREDIT_TYPE
  SUB_TOKEN
}

type CrowdChant {
  createdAt: Time!
  createdBy: User!
  endsAt: Time!
  id: ID!
  chatMessageID: ID!
  text: String!
}

type CrowdChants {
  settings: ChannelCrowdChantSettings
  activeChant: CrowdChant
}

enum CSATActionPrompted {
  CLIENT_APP_REGISTER
  DROP_CREATE_CAMPAIGN
  DROP_MOVE_STATE_TO_ACTIVE
  DROP_MOVE_STATE_TO_TESTING
  EXTENSION_CREATE
  EXTENSION_STATE_CHANGE
  GAMES_VIEW_ANALYTICS
  GAMES_SUBMIT_BOX_ART
  ORGANIZATION_CREATE
  ORGANIZATION_ADD_USER
}

enum CSATRating {
  VERY_DISSATISFIED
  SOMEWHAT_DISSATISFIED
  NEUTRAL
  SOMEWHAT_SATISFIED
  VERY_SATISFIED
}

enum Currency {
  AFN
  EUR
  ALL
  DZD
  USD
  AOA
  XCD
  ARS
  AMD
  AWG
  AUD
  AZN
  BSD
  BHD
  BDT
  BBD
  BYN
  BZD
  XOF
  BMD
  INR
  BTN
  BOB
  BOV
  BAM
  BWP
  NOK
  BRL
  BND
  BGN
  BIF
  CVE
  KHR
  XAF
  CAD
  KYD
  CLP
  CLF
  CNY
  COP
  COU
  KMF
  CDF
  NZD
  CRC
  HRK
  CUP
  CUC
  ANG
  CZK
  DKK
  DJF
  DOP
  EGP
  SVC
  ERN
  ETB
  FKP
  FJD
  XPF
  GMD
  GEL
  GHS
  GIP
  GTQ
  GBP
  GNF
  GYD
  HTG
  HNL
  HKD
  HUF
  ISK
  IDR
  IRR
  IQD
  ILS
  JMD
  JPY
  JOD
  KZT
  KES
  KRW
  KWD
  KGS
  LAK
  LBP
  LSL
  ZAR
  LRD
  LYD
  CHF
  MOP
  MKD
  MGA
  MWK
  MYR
  MVR
  MRU
  MUR
  XUA
  MXN
  MXV
  MDL
  MNT
  MAD
  MZN
  MMK
  NAD
  NPR
  NIO
  NGN
  OMR
  PKR
  PAB
  PGK
  PYG
  PEN
  PHP
  PLN
  QAR
  RON
  RUB
  RWF
  SHP
  WST
  STN
  SAR
  RSD
  SCR
  SLL
  SGD
  XSU
  SBD
  SOS
  SSP
  LKR
  SDG
  SRD
  SZL
  SEK
  CHE
  CHW
  TWD
  TJS
  TZS
  THB
  TOP
  TTD
  TND
  TRY
  TMT
  UGX
  UAH
  AED
  UYU
  UYI
  UYW
  UZS
  VUV
  VES
  VND
  YER
  ZMW
  ZWL
}

type CurrentPrimePayout {
  pastCyclePayoutAmount: Int!
  thisCyclePayoutAmount: Int!
  totalPayoutAmount: Int!
}

scalar Cursor

interface DashboardActivityFeedActivity {
  alertStatus: DashboardActivityFeedActivityAlertStatus
  id: ID!
  timestamp: Time!
}

enum DashboardActivityFeedActivityAlertStatus {
  FAILED
  OFFLINE
  PLAYED
  PLAYING
  QUEUED
  REJECTED
  SKIPPED
  PURGED
}

type DashboardActivityFeedActivityAutoHosting implements DashboardActivityFeedActivity {
  alertStatus: DashboardActivityFeedActivityAlertStatus
  host: User
  id: ID!
  timestamp: Time!
  viewerCount: Int!
}

type DashboardActivityFeedActivityBitsUsage implements DashboardActivityFeedActivity {
  alertStatus: DashboardActivityFeedActivityAlertStatus
  amount: Int!
  id: ID!
  isAnonymous: Boolean!
  timestamp: Time!
  user: User
}

type DashboardActivityFeedActivityBoostComplete implements DashboardActivityFeedActivity {
  alertStatus: DashboardActivityFeedActivityAlertStatus
  goalProgress: Int!
  goalTarget: Int!
  id: ID!
  purchaser: User
  quantity: Int!
  timestamp: Time!
}

type DashboardActivityFeedActivityBoostStart implements DashboardActivityFeedActivity {
  alertStatus: DashboardActivityFeedActivityAlertStatus
  goalProgress: Int!
  goalTarget: Int!
  id: ID!
  purchaser: User
  quantity: Int!
  timestamp: Time!
}

type DashboardActivityFeedActivityCelebrationPurchaseEvent implements DashboardActivityFeedActivity {
  alertStatus: DashboardActivityFeedActivityAlertStatus
  effect: CelebrationEffect!
  id: ID!
  intensity: CelebrationIntensity!
  purchasingUser: User
  timestamp: Time!
}

type DashboardActivityFeedActivityCommunityPointsReward implements DashboardActivityFeedActivity {
  alertStatus: DashboardActivityFeedActivityAlertStatus
  id: ID!
  redeemingUser: User
  redemption: CommunityPointsCustomRewardRedemption
  timestamp: Time!
  title: String!
  userInput: String
}

type DashboardActivityFeedActivityCommunitySubscriptionGifting implements DashboardActivityFeedActivity {
  alertStatus: DashboardActivityFeedActivityAlertStatus
  giftQuantity: Int!
  giftedMonths: Int!
  gifter: User
  id: ID!
  isAnonymous: Boolean!
  recipients: [User!]
    @deprecated(reason: "Use giftQuantity for total subscriptions")
  tier: SubscriptionTier!
  timestamp: Time!
}

type DashboardActivityFeedActivityConnection {
  edges: [DashboardActivityFeedActivityEdge!]!
  pageInfo: PageInfo!
}

type DashboardActivityFeedActivityCopoGoalEnd implements DashboardActivityFeedActivity {
  alertStatus: DashboardActivityFeedActivityAlertStatus
  goalAmount: Int!
  goalID: ID!
  goalStatus: CommunityPointsCommunityGoalStatus!
  goalTitle: String!
  goalType: CommunityPointsCommunityGoalType!
  id: ID!
  pointsContributed: Int!
  pointsName: String
  timestamp: Time!
}

type DashboardActivityFeedActivityDropClaimWindowOpen implements DashboardActivityFeedActivity {
  alertStatus: DashboardActivityFeedActivityAlertStatus
  drop: DropObject!
  id: ID!
  timestamp: Time!
}

type DashboardActivityFeedActivityEdge {
  cursor: Cursor!
  node: DashboardActivityFeedActivity!
}

type DashboardActivityFeedActivityFollowing implements DashboardActivityFeedActivity {
  alertStatus: DashboardActivityFeedActivityAlertStatus
  follower: User
  id: ID!
  timestamp: Time!
}

type DashboardActivityFeedActivityHosting implements DashboardActivityFeedActivity {
  alertStatus: DashboardActivityFeedActivityAlertStatus
  host: User
  id: ID!
  timestamp: Time!
  viewerCount: Int
}

type DashboardActivityFeedActivityHypeTrainEvent implements DashboardActivityFeedActivity {
  alertStatus: DashboardActivityFeedActivityAlertStatus
  completedLevel: Int
  hypeTrainID: ID!
  id: ID!
  timestamp: Time!
  totalBitsAmount: Int
  totalSubsCount: Int
  type: HypeTrainEventType!
}

type DashboardActivityFeedActivityIndividualSubscriptionGifting implements DashboardActivityFeedActivity {
  alertStatus: DashboardActivityFeedActivityAlertStatus
  giftedMonths: Int!
  gifter: User
  id: ID!
  isAnonymous: Boolean!
  recipient: User
  tier: SubscriptionTier!
  timestamp: Time!
}

type DashboardActivityFeedActivityIngestSessionStarting implements DashboardActivityFeedActivity {
  alertStatus: DashboardActivityFeedActivityAlertStatus
    @deprecated(reason: "ingest start has been removed from activity feed")
  id: ID!
    @deprecated(reason: "ingest start has been removed from activity feed")
  timestamp: Time!
    @deprecated(reason: "ingest start has been removed from activity feed")
}

type DashboardActivityFeedActivityPrimeResubscribing implements DashboardActivityFeedActivity {
  alertStatus: DashboardActivityFeedActivityAlertStatus
  durationMonths: Int!
  id: ID!
  message: String
    @deprecated(reason: "Use messageContent's fragments for enriching the text")
  messageContent: MessageContent
  resubscriber: User
  timestamp: Time!
}

type DashboardActivityFeedActivityPrimeSubscribing implements DashboardActivityFeedActivity {
  alertStatus: DashboardActivityFeedActivityAlertStatus
  id: ID!
  subscriber: User
  timestamp: Time!
}

type DashboardActivityFeedActivityRaiding implements DashboardActivityFeedActivity {
  alertStatus: DashboardActivityFeedActivityAlertStatus
  id: ID!
  partySize: Int! @deprecated(reason: "Renamed to viewerCount")
  raider: User
  timestamp: Time!
  viewerCount: Int!
}

type DashboardActivityFeedActivityResubscribing implements DashboardActivityFeedActivity {
  alertStatus: DashboardActivityFeedActivityAlertStatus
  durationMonths: Int!
  id: ID!
  message: String
    @deprecated(reason: "Use messageContent's fragments for enriching the text")
  messageContent: MessageContent
  multiMonthDuration: Int!
  multiMonthTenure: Int!
  resubscriber: User
  tier: SubscriptionTier!
  timestamp: Time!
}

type DashboardActivityFeedActivitySubscribing implements DashboardActivityFeedActivity {
  alertStatus: DashboardActivityFeedActivityAlertStatus
  id: ID!
  multiMonthDuration: Int!
  multiMonthTenure: Int!
  subscriber: User
  tier: SubscriptionTier!
  timestamp: Time!
}

type DashboardAlertQueueActivityConnection {
  edges: [DashboardAlertQueueActivityEdge!]!
  pageInfo: PageInfo!
}

type DashboardAlertQueueActivityEdge {
  cursor: Cursor!
  node: DashboardActivityFeedActivity!
}

type DashboardAlertQueuePreferences {
  isDNDModeEnabled: Boolean!
  lastModified: Time
  shouldHideBits: Boolean!
  shouldHideFollows: Boolean!
  shouldHideGiftSubscriptions: Boolean!
  shouldHideHosts: Boolean!
  shouldHideRaids: Boolean!
  shouldHideSubscriptions: Boolean!
}

type DateToken {
  time: Time!
}

input DeactivateExtensionInput {
  extensionInstallationID: ID!
}

type DeactivateExtensionPayload {
  installedExtension: ExtensionInstallation!
}

type DeclineOrganizationInviteError {
  code: DeclineOrganizationInviteErrorCode!
}

enum DeclineOrganizationInviteErrorCode {
  INTERNAL_ERROR
  NOT_FOUND
  PERMISSION_DENIED
}

input DeclineOrganizationInviteInput {
  organizationInviteID: ID!
}

type DeclineOrganizationInvitePayload {
  error: DeclineOrganizationInviteError
}

type DefaultPanel implements Panel {
  description: String
  id: ID!
  imageURL: String
  linkURL: String
  title: String
  type: PanelType!
}

type DeferredPrimePayout {
  totalPayoutAmount: Int!
}

input DeleteAllChannelVideosInput {
  channelID: ID!
}

type DeleteAllChannelVideosPayload {
  status: DeleteAllChannelVideosStatus
}

type DeleteAllChannelVideosStatus {
  code: DeleteAllChannelVideosStatusCode!
}

enum DeleteAllChannelVideosStatusCode {
  SUCCESS
  FORBIDDEN
  INTERNAL_ERROR
  INVALID_ARGUMENT
  UNKNOWN
}

input DeleteBitsBadgeTierEmoticonInput {
  channelID: ID!
  emoteID: ID!
  text: String!
  threshold: Int!
}

type DeleteBitsBadgeTierEmoticonPayload {
  deletedAt: Time
}

input DeleteCelebrationInput {
  celebrationID: ID!
  channelID: ID!
}

type DeleteCelebrationPayload {
  error: CelebrationError
}

input DeleteChannelBlockedTermByIDInput {
  channelID: ID!
  id: ID!
  isPrivateAction: Boolean = false
}

type DeleteChannelBlockedTermByIDPayload {
  error: DeleteChannelBlockedTermError
}

type DeleteChannelBlockedTermError {
  code: DeleteChannelBlockedTermErrorCode!
}

enum DeleteChannelBlockedTermErrorCode {
  NO_PERMISSIONS
}

input DeleteChannelClipsInput {
  channelID: ID!
}

type DeleteChannelClipsPayload {
  channelID: ID!
}

input DeleteChannelPermittedTermByIDInput {
  channelID: ID!
  id: ID!
}

type DeleteChannelPermittedTermByIDPayload {
  error: DeleteChannelPermittedTermError
}

type DeleteChannelPermittedTermError {
  code: DeleteChannelPermittedTermErrorCode!
}

enum DeleteChannelPermittedTermErrorCode {
  NO_PERMISSIONS
}

input DeleteChatMessageInput {
  channelID: ID!
  messageID: ID!
}

type DeleteChatMessagePayload {
  message: DeletedMessage
  responseCode: DeleteChatMessageStatusCode!
}

enum DeleteChatMessageStatusCode {
  SUCCESS
  SUCCESS_STAFF
  FORBIDDEN
  TARGET_IS_BROADCASTER
  TARGET_IS_MODERATOR
}

type DeleteCheermoteTierError {
  code: DeleteCheermoteTierErrorCode!
}

enum DeleteCheermoteTierErrorCode {
  PERMISSION_DENIED
  UNKNOWN
}

input DeleteCheermoteTierInput {
  tierThreshold: CheermoteTierThreshold!
  userID: ID!
}

type DeleteCheermoteTierPayload {
  deletedAt: Time
  error: DeleteCheermoteTierError
}

input DeleteClipsInput {
  broadcastID: ID
  slugs: [ID!]
  videoID: ID
}

type DeleteClipsPayload {
  clips: [Clip]!
  count: Int!
}

input DeleteCollectionInput {
  collectionID: ID!
}

type DeleteCollectionPayload {
  collection: Collection!
}

type DeleteCommunityPointsCommunityGoalError {
  code: DeleteCommunityPointsCommunityGoalErrorCode!
}

enum DeleteCommunityPointsCommunityGoalErrorCode {
  NOT_FOUND
  FORBIDDEN
  UNKNOWN
}

input DeleteCommunityPointsCommunityGoalInput {
  channelID: ID!
  goalID: ID!
}

type DeleteCommunityPointsCommunityGoalPayload {
  error: DeleteCommunityPointsCommunityGoalError
  goal: CommunityPointsCommunityGoal
}

type DeleteCommunityPointsCustomRewardError {
  code: DeleteCommunityPointsCustomRewardErrorCode!
}

enum DeleteCommunityPointsCustomRewardErrorCode {
  UNKNOWN
  FORBIDDEN
  NOT_FOUND
}

input DeleteCommunityPointsCustomRewardInput {
  channelID: ID!
  rewardID: ID!
  unfulfilledRedemptionsNewStatus: CommunityPointsCustomRewardRedemptionStatus = FULFILLED
}

type DeleteCommunityPointsCustomRewardPayload {
  error: DeleteCommunityPointsCustomRewardError
  reward: CommunityPointsCustomReward
}

input DeleteCompetitionInput {
  id: ID!
}

type DeleteCompetitionPayload {
  competition: Competition
  error: CompetitionError
}

input DeleteContentTagsInput {
  authorID: ID!
  contentID: ID!
  contentType: ContentType!
  tagIDs: [ID!]!
}

type DeleteContentTagsPayload {
  content: TaggedContent
}

enum DeleteDashboardViewErrorCode {
  UNKNOWN
  INVALID_ARGUMENT_LAYOUTID
  INVALID_ARGUMENT_USERID
  INVALID_ARGUMENT
}

input DeleteDashboardViewInput {
  id: ID!
}

type DeleteDashboardViewPayload {
  errorCode: DeleteDashboardViewErrorCode
}

input DeleteDefaultPaymentMethodInput {
  provider: PaymentProvider!
  userID: ID!
}

type DeleteDefaultPaymentMethodPayload {
  updatedAt: Time
  user: User
}

input DeleteDeviceTokenInput {
  deviceToken: ID!
  userID: ID!
}

type DeleteDeviceTokenPayload {
  deviceToken: ID!
}

type DeletedMessage {
  content: RoomMessageContent!
  id: ID!
  sender: User
}

enum DeletedMessageDisplaySetting {
  LEGACY
  BRIEF
  DETAILED
}

input DeleteDropCampaignInput {
  campaignID: ID!
}

type DeleteDropCampaignPayload {
  error: DropsError
}

input DeleteDropInput {
  dropID: ID!
}

type DeleteDropPayload {
  error: DropsError
}

type DeleteEmoteError {
  code: DeleteEmoteErrorCode!
}

enum DeleteEmoteErrorCode {
  EMOTE_NOT_FOUND
  PERMISSION_DENIED
  UNKNOWN
}

input DeleteEmoteInput {
  id: ID!
}

type DeleteEmotePayload {
  error: DeleteEmoteError
}

enum DeleteExtensionError {
  MISSING_EXTENSION_ID
  EXTENSION_NOT_FOUND
  UNAUTHORIZED
}

enum DeleteExtensionImageError {
  UNAUTHORIZED
  INVALID_VERSION
  CANNOT_FIND_URL_IN_MANIFEST
  INVALID_IMAGE_URL
}

input DeleteExtensionImageInput {
  extensionID: ID!
  urls: [String!]!
}

type DeleteExtensionImagePayload {
  error: DeleteExtensionImageError
  manifest: ExtensionManifest
}

input DeleteExtensionInput {
  id: ID!
}

type DeleteExtensionPayload {
  error: DeleteExtensionError
}

enum DeleteExtensionSecretsError {
  UNAUTHORIZED
}

input DeleteExtensionSecretsInput {
  extensionID: ID!
}

type DeleteExtensionSecretsPayload {
  error: DeleteExtensionSecretsError
}

input DeleteLoyaltyBadgeInput {
  badgeID: ID!
  channelID: ID!
  channelTenureMethodID: ID!
}

type DeleteLoyaltyBadgePayload {
  badge: LoyaltyBadge
}

input DeleteModeratorCommentInput {
  ID: ID!
}

type DeleteModeratorCommentPayload {
  comment: ModLogsComment
}

input DeleteMultiviewContentAttributesInput {
  IDs: [ID!]!
}

type DeleteMultiviewContentAttributesPayload {
  failedDeletes: [MultiviewContentAttribute!]!
  succeededDeletes: [MultiviewContentAttribute!]!
}

input DeleteNotificationInput {
  id: ID!
}

type DeleteNotificationPayload {
  notification: OnsiteNotification!
}

input DeletePanelInput {
  id: ID!
}

type DeletePanelPayload {
  panel: Panel!
}

input DeletePostInput {
  postID: ID!
}

type DeletePostPayload {
  post: Post
}

input DeleteRecommendationFeedbackInput {
  feedbackID: ID!
  sourceItemPage: String!
}

type DeleteRecommendationFeedbackPayload {
  feedbackID: ID!
}

input DeleteRoomInput {
  roomID: ID!
}

input DeleteRoomMessageInput {
  messageID: ID!
  roomID: ID!
}

type DeleteRoomMessagePayload {
  message: RoomMessage
}

type DeleteRoomPayload {
  room: Room
}

enum DeleteScheduleError {
  PERMISSION_DENIED
}

input DeleteScheduleInput {
  channelID: ID!
  scheduleID: ID!
}

type DeleteSchedulePayload {
  channel: Channel
  error: DeleteScheduleError
}

enum DeleteScheduleSegmentError {
  PERMISSION_DENIED
}

input DeleteScheduleSegmentInput {
  scheduleID: ID!
  segmentID: ID!
}

type DeleteScheduleSegmentPayload {
  error: DeleteScheduleSegmentError
  schedule: Schedule
}

input DeleteSocialMediaInput {
  channelID: ID!
  id: ID!
}

type DeleteSocialMediaPayload {
  channel: Channel
}

type DeleteSquadStreamInvitationError {
  code: DeleteSquadStreamInvitationErrorCode!
}

enum DeleteSquadStreamInvitationErrorCode {
  INVITATION_NOT_FOUND
  SQUAD_NOT_FOUND
  UNAUTHORIZED
  INVITATION_CANNOT_BE_DELETED
}

input DeleteSquadStreamInvitationInput {
  invitationID: ID!
}

type DeleteSquadStreamInvitationPayload {
  error: DeleteSquadStreamInvitationError
  invitation: SquadStreamInvitation
}

type DeleteStreamAuthorizedUserError {
  code: DeleteStreamAuthorizedUserErrorCode!
}

enum DeleteStreamAuthorizedUserErrorCode {
  TARGET_USER_UNRETURNABLE
  CHANNEL_NOT_FOUND
  MAX_ACCOUNT_LIMIT
  PERMISSION_DENIED
  INVALID_ARGUMENT
}

input DeleteStreamAuthorizedUserInput {
  authorizedUserID: ID!
  channelID: ID!
}

type DeleteStreamAuthorizedUserPayload {
  channel: Channel
  error: AddStreamAuthorizedUserError
}

input DeleteUserClipsInput {
  userID: ID!
}

type DeleteUserClipsPayload {
  userID: ID!
}

input DeleteUserColorsInput {
  userID: ID!
}

type DeleteUserColorsPayload {
  user: User
}

type DeleteVideoCommentPayload {
  comment: VideoComment!
}

input DeleteVideosInput {
  videoIDs: [ID!]!
}

type DeleteVideosPayload {
  videos: [Video!]
}

input DeleteVideoThumbnailInput {
  path: String!
  videoID: ID!
}

type DeleteVideoThumbnailPayload {
  video: Video
}

type Density {
  adSchedule: [AdSlot!]
  autoAdLengthSeconds: Int
  autoAdPeriodMinutes: Int
  isCCP: Boolean!
  minutesElapsed: Int
  shouldEnforceContract: Boolean!
  targetAdMinutes: Int
  totalAdSeconds: Int
  isAdScheduleEnabled: Boolean!
  interval: AdScheduleConfig!
  duration: AdScheduleConfig!
  startDelay: AdScheduleConfig!
  reminder: AdReminderConfig!
  snooze: AdSnoozeConfig!
}

input DenyRejectedChatMessageInput {
  id: ID!
}

type DenyRejectedChatMessagePayload {
  message: RejectedChatMessage
}

input DenyRejectedCheerInput {
  id: ID!
  targetUserID: ID!
}

type DenyRejectedCheerPayload {
  id: ID!
}

input DenyUnbanRequestInput {
  id: ID!
  resolverMessage: String
}

type DenyUnbanRequestPayload {
  error: UnbanRequestError
  unbanRequest: UnbanRequest
}

input DeselectChannelBadgeInput {
  channelID: ID!
}

type DeselectChannelBadgePayload {
  user: User
}

type DeselectGlobalBadgePayload {
  user: User
}

type DetailedAutoModConfiguration {
  ableismLevel: Int
  aggressionLevel: Int
  homophobiaLevel: Int
  misogynyLevel: Int
  nameCallingLevel: Int
  profanityLevel: Int
  racismLevel: Int
  sexualityLevel: Int
  nWordLevel: Int @deprecated
  whiteNationalistLevel: Int @deprecated
}

input DetailedAutoModLevelsInput {
  ableismLevel: Int
  aggressionLevel: Int
  homophobiaLevel: Int
  misogynyLevel: Int
  nameCallingLevel: Int
  profanityLevel: Int
  racismLevel: Int
  sexualityLevel: Int
}

interface Directory {
  avatarURL(width: Int, height: Int): String
  broadcastersCount: Int
  coverURL(width: Int, height: Int): String
  directoryType: DirectoryType
  displayName: String!
  followersCount: Int
  id: ID!
  name: String!
  streams(
    first: Int = 10
    after: Cursor
    languages: [String!]
    tags: [String!]
  ): StreamConnection
  viewersCount: Int
}

type DirectoryConnection {
  edges: [DirectoryEdge]!
  pageInfo: PageInfo!
}

type DirectoryEdge {
  cursor: Cursor
  node: Directory
}

enum DirectoryType {
  GAME
}

type DisablePrerollsAbility {
  disablePrerollsTimeEarned: [DisablePrerollsFreeTime!]
  hasDisablePrerollsAbilityAccess: Boolean
  hasDisablePrerollsAbilityEnabled: Boolean
  hasDisablePrerollsNotificationsEnabled: Boolean
  maxDisablePrerollsCapacity: Int
}

type DisablePrerollsFreeTime {
  midrollLengthSeconds: Int!
  prerollFreeTimeSeconds: Int!
}

type DisableTwoFactorError {
  code: DisableTwoFactorErrorCode!
  message: String!
}

enum DisableTwoFactorErrorCode {
  REAUTH_NEEDED
  UNKNOWN_ERROR
}

input DisableTwoFactorInput {
  userID: ID!
}

type DisableTwoFactorPayload {
  error: DisableTwoFactorError
}

type DisableUserAccountError {
  code: DisableUserAccountErrorCode!
}

enum DisableUserAccountErrorCode {
  INVALID_USER_ID
  UNAUTHORIZED
}

input DisableUserAccountInput {
  description: String
  isDelete: Boolean
  userID: ID!
}

type DisableUserAccountPayload {
  error: DisableUserAccountError
  user: User
}

type DiscountBreakdown {
  price: Int!
  tax: Int!
  total: Int!
}

enum DiscountType {
  PERCENT_OFF
}

input DismissFriendRecommendationInput {
  targetID: ID!
}

type DismissFriendRecommendationPayload {
  user: User
}

type DismissRitualTokenError {
  code: DismissRitualTokenErrorCode!
}

enum DismissRitualTokenErrorCode {
  TOKEN_NOT_AVAILABLE
  TOKEN_NOT_FOUND
}

input DismissRitualTokenInput {
  channelID: ID!
  type: RitualTokenType!
}

type DismissRitualTokenPayload {
  error: DismissRitualTokenError
  token: RitualToken
}

input DismissVideoSuggestedHighlightInput {
  videoID: ID!
}

type DismissVideoSuggestedHighlightPayload {
  video: Video
}

type Drop {
  game: Game @deprecated
  id: ID! @deprecated
  imageURL: String! @deprecated
  name: String! @deprecated
}

type DropAccountLink {
  clientID: ID!
  updatedAt: Time!
}

type DropAction {
  claimDurationSeconds: Int! @deprecated
  description: String! @deprecated
  id: ID! @deprecated
  type: DropActionType! @deprecated
}

enum DropActionType {
  UNKNOWN_ACTION_TYPE @deprecated
  USER_CLAIM_FLOW @deprecated
}

type DropAward {
  awardedAt: Time @deprecated
  node: Drop @deprecated
  reason: String @deprecated
}

type DropBenefit {
  accountLinkURL: String!
  createdAt: Time!
  description: String! @deprecated
  entitlementLimit: Int!
  game: Game
  id: ID!
  imageAssetURL: String!
  isIosAvailable: Boolean!
  name: String!
  owner: User! @deprecated(reason: "Use DropBenefit.ownerOrganization instead")
  ownerOrganization: Organization
}

type DropBenefitEdge {
  benefit: DropBenefit!
  claimCount: Int
  entitlementLimit: Int!
}

type DropCampaign {
  accountLinkURL: String!
  allow: DropCampaignACL
  applicableChannels: [User!] @deprecated
  applicableGames: [Game!] @deprecated
  awardableDrops: [Drop!] @deprecated
  block: DropCampaignACL
  connectionURL: String! @deprecated(reason: "Use accountLinkURL instead")
  description: String!
  detailsURL: String!
  endAt: Time!
  eventBasedDrops: [EventBasedDrop!]
  game: Game
  id: ID!
  imageURL: String!
  isAvailableToAllChannels: Boolean! @deprecated
  isEnabled: Boolean! @deprecated
  manualTriggerBasedDrops: [ManualTriggerBasedDrop!]
  name: String!
  owner: Organization
  self: DropCampaignSelfEdge!
  startAt: Time!
  status: DropCampaignStatus!
  testViewers: [User!]
  timeBasedDrops: [TimeBasedDrop!]
  type: CampaignType!
}

type DropCampaignACL {
  channels: [Channel!]
  isEnabled: Boolean!
}

type DropCampaignSelfEdge {
  isAccountConnected: Boolean!
}

enum DropCampaignStatus {
  ACTIVE
  EXPIRED
  TEST
  UPCOMING
  DISABLED
}

type DropChannelSetting {
  isUserAccountConnected: Boolean!
}

type DropCurrentSession {
  channel: Channel
  currentMinutesWatched: Int!
  dropID: ID!
  game: Game
  requiredMinutesWatched: Int!
}

type DropEligibility {
  claimSecondsRemaining: Int!
  drop: DropObject!
    @deprecated(reason: "No longer supported. Use dropType instead.")
  dropInstanceID: ID!
  dropType: DropType!
  rewards: [DropReward!]!
  status: DropInstanceEligibilityStatus!
}

type DropEventCondition {
  key: String!
  operator: DropEventConditionOperator!
  value: String!
}

input DropEventConditionInput {
  key: String!
  operator: DropEventConditionOperator!
  value: String!
}

enum DropEventConditionOperator {
  UNKNOWN
  SMALLER
  SMALLER_EQUAL
  EQUAL
  GREATER
  GREATER_EQUAL
}

enum DropImageType {
  LINK_NOTIFICATION
  ITEM
}

input DropImageUploadInput {
  ownerID: ID!
  referenceID: ID!
  scope: Scope!
}

type DropImageUploadPayload {
  uploadID: ID
  uploadURL: String
}

enum DropInstanceEligibilityStatus {
  ELIGIBLE_FOR_ALL
  LIMITED
  ENTITLEMENT_LIMIT_REACHED
  DROP_INSTANCE_ALREADY_CLAIMED
  EXPIRED
  UNKNOWN
}

type DropObject {
  accountLinkURL: String! @deprecated
  actions: [DropAction!]! @deprecated
  description: String! @deprecated
  detailsURL: String! @deprecated
  endDate: Time! @deprecated
  game: Game! @deprecated
  id: ID! @deprecated
  imageURL: String! @deprecated
  name: String! @deprecated
  ownerID: ID! @deprecated
  ownerName: String! @deprecated
  questName: String! @deprecated
  rules: [DropRule!]! @deprecated
  startDate: Time! @deprecated
}

input DropPrecondition {
  dropID: ID!
  dropPreconditionID: ID!
}

type DropReward {
  accountLinkURL: String! @deprecated(reason: "use benefit.accountLinkURL")
  availability: DropRewardAvailability!
  benefit: DropBenefit!
  description: String! @deprecated(reason: "no longer used")
  id: ID! @deprecated(reason: "use benefit.id")
  imageAssetURL: String! @deprecated(reason: "use benefit.imageAssetURL")
  isIosAvailable: Boolean! @deprecated(reason: "use benefit.isIosAvailable")
  name: String! @deprecated(reason: "use benefit.name")
  ownerID: ID! @deprecated(reason: "use benefit.ownerOrganization.id")
  ownerName: String! @deprecated(reason: "use benefit.ownerOrganization.name")
}

enum DropRewardAvailability {
  AVAILABLE
  LIMIT_REACHED
  UNKNOWN
}

type DropRule {
  description: String! @deprecated
  id: ID! @deprecated
}

enum DropRuleType {
  EVENT_BASED
  TIME_BASED
  MANUAL_TRIGGER_BASED
}

type DropsError {
  code: DropsErrorCode!
  message: String
}

enum DropsErrorCode {
  UNKNOWN
  UNAUTHORIZED
  INVALID_ARGUMENT
  FAILED_PRECONDITION
  NOT_FOUND
  ALREADY_EXISTS
}

interface DropType {
  benefitEdges: [DropBenefitEdge!]
  campaign: DropCampaign!
  endAt: Time!
  id: ID!
  name: String!
  startAt: Time!
}

scalar Duration

type EditableChannelConnection {
  edges: [EditableChannelEdge!]!
  pageInfo: PageInfo!
}

type EditableChannelEdge {
  cursor: Cursor!
  node: User
}

type EditorConnection {
  edges: [EditorEdge!]!
  pageInfo: PageInfo!
}

type EditorEdge {
  cursor: Cursor!
  grantedAt: Time!
  node: User
}

input EditRoomMessageInput {
  message: String!
  messageID: ID!
  roomID: ID!
}

type EditRoomMessagePayload {
  message: RoomMessage
}

type EligiblePaymentMethod {
  availabilityStatus: PaymentMethodAvailabilityStatus!
  name: EligiblePaymentMethodName!
}

enum EligiblePaymentMethodName {
  AMAZON_PAY
  PAYPAL
  CREDIT_CARD
  XSOLLA
  WALLET
  DIRECT_DEBIT
}

type EmbeddedEmote {
  emoteID: ID
  from: Int
  id: ID
  setID: ID
  to: Int
}

input EmitCampaignDiscoveryEventInput {
  channelID: ID!
  discoveryType: CampaignDiscoveryEventType!
}

type EmitCampaignDiscoveryEventPayload {
  isSuccess: Boolean!
}

type Emote {
  assetType: EmoteAssetType
  bitsBadgeTierSummary: EmoteBitsBadgeTierSummary
  createdAt: Time
  id: ID
  modifiers: [EmoteModifier!]
  order: Int
  owner: User
  setID: ID
  state: EmoteState!
  subscriptionProduct: SubscriptionProduct
  subscriptionSummaries: [SubscriptionSummary!]
  subscriptionTier: SubscriptionSummaryTier
  suffix: String
  text: String
  token: String
  type: EmoteType
}

enum EmoteAssetType {
  ANIMATED
  STATIC
  UNKNOWN
}

type EmoteBitsBadgeTierSummary {
  self: EmoteBitsBadgeTierSummarySelfEdge
  threshold: Int!
}

type EmoteBitsBadgeTierSummarySelfEdge {
  isUnlocked: Boolean!
  numberOfBitsUntilUnlock: Int!
}

enum EmoteDashboardStatus {
  UNKNOWN
  NOT_ALLOWED
  NO_UPLOAD
  ALLOWED
}

enum EmoteGroupAssetType {
  STATIC
  ANIMATED
}

input EmoteImageAssetInput {
  assetType: EmoteAssetType!
  id: ID!
  size: EmoteImageSize!
}

enum EmoteImageSize {
  SIZE_1X
  SIZE_2X
  SIZE_4X
  SIZE_ORIGINAL
}

type EmoteImageUploadConfiguration {
  uploadID: ID
  uploadURL: String
}

type EmoteLimits {
  maxOwnedAnimated: Int!
  maxOwnedStatic: Int!
}

type EmoteModifier {
  code: String!
  name: PermanentEmoteModifier!
  subscriptionTier: SubscriptionSummaryTier
}

input EmoteModifierGroupInput {
  modifiers: [PermanentEmoteModifier!]!
  productID: ID!
}

type EmoteModifierGroupPayload {
  modifiers: [PermanentEmoteModifier!]
  product: SubscriptionProduct
}

input EmoteOrder {
  emoteID: ID!
  groupID: ID!
  order: Int!
}

enum EmoteResizePlan {
  AUTO_RESIZE
  NO_RESIZE
}

type EmoteSet {
  emotes: [Emote]
  id: ID
  owner: User
  assetType: EmoteGroupAssetType
}

enum EmoteSetDomain {
  CRATE
}

type EmoteSettings {
  emoteLimits: EmoteLimits
  ownedEmotes: [Emote!]
}

enum EmoteState {
  ACTIVE
  PENDING
  ARCHIVED
  PENDING_ARCHIVED
  INACTIVE
  UNKNOWN
}

enum EmoteStateFilter {
  ALL
  ACTIVE
}

enum EmoteType {
  CHANNEL_POINTS
  BITS_BADGE_TIERS
  SUBSCRIPTIONS
  PRIME
  TURBO
  TWO_FACTOR
  SMILIES
  GLOBALS
  LIMITED_TIME
  HYPE_TRAIN
  MEGA_COMMERCE
  ARCHIVE
  FOLLOWER
  UNKNOWN
}

type EmoteUploadConfiguration {
  imageUploadConfig1X: EmoteImageUploadConfiguration
  imageUploadConfig2X: EmoteImageUploadConfiguration
  imageUploadConfig4X: EmoteImageUploadConfiguration
}

type EmoticonPrefix {
  isEditable: Boolean!
  name: String!
  state: EmoticonPrefixState!
}

enum EmoticonPrefixState {
  UNKNOWN
  UNSET
  ACTIVE
  REJECTED
  PENDING
}

type EndorsedChannelConnection {
  edges: [EndorsedChannelEdge!]
  pageInfo: PageInfo!
}

type EndorsedChannelEdge {
  cursor: Cursor!
  node: Channel!
  trackingID: ID!
}

input EndUseBitsInExtensionInput {
  transactionID: ID!
}

type EndUseBitsInExtensionPayload {
  balance: Int
}

type EnhancedExperiencesClient {
  id: ID!
  name: String!
  onboardedAt: Time
}

type EpisodeDetails {
  durationSeconds: Int
  episode: Int
  season: Int
  series: String
}

type EquipHeroAssetsError {
  code: EquipHeroAssetsErrorCode!
}

enum EquipHeroAssetsErrorCode {
  FORBIDDEN
  INVALID_ASSET_ID
  MULTIPLE_ASSETS_PER_TYPE
  UNKNOWN_ERROR
}

input EquipHeroAssetsInput {
  assetIDs: [ID!]!
}

type EquipHeroAssetsPayload {
  error: EquipHeroAssetsError
  hero: Hero
}

enum ESRBRating {
  UNSET
  RP
  EC
  E
  E10
  T
  M
  AO
}

type EventBasedDrop implements DropType {
  benefitEdges: [DropBenefitEdge!]
  campaign: DropCampaign!
  claimDurationSeconds: Int!
  conditions: [DropEventCondition!]!
  endAt: Time!
  id: ID!
  missionDescription: String!
  missionName: String!
  name: String!
  startAt: Time!
}

type EventNotificationSetting {
  category: String!
  platforms: [PlatformEventSetting!]!
}

type Experiment {
  promotedStream(promoLocation: Int!): Stream
  localEmoteDashboard: LocalEmoteDashboard
}

type ExpiredSubscription {
  channelOwner: User
  id: ID!
  product: SubscriptionProduct
  tenure: SubscriptionTenure!
}

type ExpiredSubscriptionConnection {
  edges: [ExpiredSubscriptionEdge!]
  pageInfo: PageInfo!
}

type ExpiredSubscriptionEdge {
  cursor: Cursor!
  node: ExpiredSubscription
}

input ExportVideoToYoutubeInput {
  description: String
  doSplit: Boolean
  private: Boolean
  tags: [String!]
  title: String
  videoID: ID!
}

type ExportVideoToYoutubePayload {
  video: Video
}

type Extension {
  anchor: ExtensionAnchor!
  assetURLs: [String!]!
  authorName: String!
  bitsSupportLevel: ExtensionBitsSupportLevel!
  categories: [ExtensionCategory!]!
  challengeCondition(
    input: ExtensionChallengeConditionByIDInput!
  ): ChallengeCondition @deprecated
  challengeConditionParticipants(
    first: Int = 100
    after: Cursor
    input: ExtensionChallengeConditionParticipantsInput!
  ): ExtensionChallengeConditionParticipantConnection @deprecated
  challengeConditions(
    first: Int = 100
    after: Cursor
    input: ExtensionChallengeConditionsInput!
  ): ExtensionChallengeConditionConnection @deprecated
  clientID: ID!
  configURL: String!
    @deprecated(
      reason: "configURL should be captured from the config ExtensionView: Extension.views.config.viewerURL"
    )
  contentMatchedGames: [Game!]
  description: String!
  games: [Game!]
  hasChatSupport: Boolean!
  hasIdentityLinking: Boolean!
  iconURLs: ExtensionIcons!
  id: ID!
  isBitsEnabled: Boolean!
  liveConfigURL: String!
    @deprecated(
      reason: "liveConfigURL should be captured from the liveConfig ExtensionView: Extension.views.liveConfig.viewerURL"
    )
  name: String!
  panelHeight: Int!
    @deprecated(
      reason: "panelHeight should be captured from the panel ExtensionView: Extension.views.panel.height"
    )
  privacyPolicyURL: String!
  screenshotURLs: [String!]!
  self: ExtensionSelfConnection
  sku: String!
  state: ExtensionState!
  subscriptionsSupportLevel: ExtensionSubscriptionsSupportLevel!
  summary: String!
  supportEmail: String!
  termsURL: String!
  vendorCode: String!
  version: String!
  viewerURL: String!
    @deprecated(
      reason: "viewerURL should be captured from the ExtensionView corresponding with the Extension's specified anchor"
    )
  views: ExtensionViews!
  whitelistedConfigURLs: [String!]!
  whitelistedPanelURLs: [String!]!
}

type ExtensionActivationConfig {
  anchor: ExtensionAnchor
  slot: String
  state: ActivationState!
  x: Int
  y: Int
}

input ExtensionActivationInput {
  component: ComponentActivationInput
  installationID: ID!
  panel: PanelActivationInput
  videoOverlay: VideoOverlayActivationInput
}

enum ExtensionAnchor {
  COMPONENT
  HIDDEN
  PANEL
  VIDEO_OVERLAY
}

type ExtensionAssetManifest {
  assetHash: String!
  baseURI: String
  fileName: String
  fileSize: String
  uploadedAt: Time
  uploader: User
}

input ExtensionAssetManifestInput {
  assetHash: String!
}

enum ExtensionBitsSupportLevel {
  NONE
  OPTIONAL
  REQUIRED
}

type ExtensionCapabilities {
  bitsSupportLevel: ExtensionBitsSupportLevel!
  configurationLocation: ExtensionConfigurationLocation!
  hasBitsSupport: Boolean!
  hasChatSupport: Boolean!
  requiredConfiguration: String!
  subscriptionsSupportLevel: ExtensionSubscriptionsSupportLevel!
  whitelists: ExtensionWhitelists
  willRequestIdentityLink: Boolean!
}

input ExtensionCapabilitiesInput {
  bitsSupportLevel: ExtensionBitsSupportLevel = NONE
  configurationLocation: ExtensionConfigurationLocation!
  hasBitsSupport: Boolean!
  hasChatSupport: Boolean!
  requiredConfiguration: String!
  subscriptionsSupportLevel: ExtensionSubscriptionsSupportLevel
  whitelists: ExtensionWhitelistsInput!
  willRequestIdentityLink: Boolean!
}

type ExtensionCarousel {
  entries: [ExtensionCarouselEntry!]!
  id: ID!
}

type ExtensionCarouselEntry {
  clickThroughURL: String!
  id: ID!
  imageURL: String!
  title: String!
}

type ExtensionCategory {
  description: String!
  extensions(first: Int = 10, after: Cursor): ExtensionConnection
  id: ID!
  isDeleted: Boolean!
  isReadOnly: Boolean!
  isVisible: Boolean!
  name: String!
  order: Float!
  slug: ID
  sortKey: ExtensionCategorySortKey!
  type: ExtensionCategoryType!
}

type ExtensionCategoryConnection {
  edges: [ExtensionCategoryEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ExtensionCategoryEdge {
  cursor: Cursor!
  node: ExtensionCategory!
}

enum ExtensionCategorySortKey {
  MANUAL
  POPULARITY
  TIME
}

enum ExtensionCategoryType {
  CURATED
  DEVELOPER
  PSEUDO
}

input ExtensionChallengeConditionByIDInput {
  conditionID: ID!
  conditionOwnerID: ID!
}

type ExtensionChallengeConditionConnection {
  edges: [ExtensionChallengeConditionEdge!]!
  pageInfo: PageInfo!
}

type ExtensionChallengeConditionEdge {
  cursor: Cursor!
  node: ChallengeCondition!
}

type ExtensionChallengeConditionParticipantConnection {
  edges: [ExtensionChallengeConditionParticipantEdge!]!
  pageInfo: PageInfo!
}

type ExtensionChallengeConditionParticipantEdge {
  cursor: Cursor!
  node: ChallengeConditionParticipant!
}

input ExtensionChallengeConditionParticipantsInput {
  conditionOwnerID: ID!
  conditionParticipantOwnerID: ID!
  endState: ChallengeConditionParticipantEndState!
}

input ExtensionChallengeConditionsInput {
  conditionOwnerID: ID!
  state: ChallengeConditionState!
}

type ExtensionClient {
  assignedBillingManager: OrganizationMember
  createdAt: Time!
  id: ID!
  name: String!
  organization: Organization
  redirectURI: String!
}

type ExtensionClientConnection {
  edges: [ExtensionClientEdge!]!
  pageInfo: PageInfo!
}

type ExtensionClientEdge {
  cursor: Cursor!
  node: ExtensionClient!
}

type ExtensionComment {
  content: String!
  id: ID!
}

type ExtensionConfiguration {
  broadcaster: ExtensionConfigurationRecord
  developer: ExtensionConfigurationRecord
  extensionID: ID!
  global: ExtensionConfigurationRecord
}

enum ExtensionConfigurationLocation {
  NONE
  HOSTED
  CUSTOM
}

type ExtensionConfigurationRecord {
  content: String!
  version: String!
}

type ExtensionConnection {
  edges: [ExtensionEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ExtensionDeveloperManifest {
  authorEmail: String!
  createdAt: String!
  lastTransitionedAt: Time
  testingBaseURI: String!
  versionState: ExtensionState!
}

input ExtensionDeveloperManifestInput {
  authorEmail: String!
  testingBaseURI: String!
}

type ExtensionDiscoveryManifest {
  authorName: String!
  categories: [ExtensionCategory!]!
  contentMatchedGames: [Game!]
  description: String!
  games: [Game!]!
  iconURLs: ExtensionIcons
  name: String!
  privacyPolicyURL: String!
  screenshotURLs: [String!]!
  summary: String!
  supportEmail: String!
  termsURL: String!
  viewerSummary: String!
}

input ExtensionDiscoveryManifestInput {
  authorName: String!
  categories: [ID!]!
  description: String!
  games: [ID!]!
  name: String!
  privacyPolicyURL: String!
  summary: String!
  supportEmail: String!
  termsURL: String!
  viewerSummary: String
}

input ExtensionDynamicManagementInput {
  gameID: ID!
  isManaged: Boolean!
}

type ExtensionEdge {
  cursor: Cursor!
  node: Extension!
}

type ExtensionIcons {
  discoverySplash: String!
  square100: String!
  square24: String!
}

type ExtensionImageUploadResponse {
  uploadID: ID!
  url: String!
}

type ExtensionInstallation {
  abilities: ExtensionInstallationAbilities!
  activationConfig: ExtensionActivationConfig!
  extension: Extension!
  id: ID!
  permittedFeatures: ExtensionInstallationFeatureFlags!
  requiredActions: [ExtensionRequiredAction!]
  self: ExtensionInstallationSelfConnection
}

type ExtensionInstallationAbilities {
  isBitsEnabled: Boolean!
  isChatEnabled: Boolean!
  isSubscriptionStatusAvailable: Boolean!
}

type ExtensionInstallationDynamicManagement {
  game: Game
  isManaged: Boolean!
}

type ExtensionInstallationFeatureFlags {
  canRetrieveSubscriptionStatus: Boolean!
  canSendChat: Boolean!
  canUseBits: Boolean!
  dynamicManagement: [ExtensionInstallationDynamicManagement!]
}

type ExtensionInstallationSelfConnection {
  canActivate: Boolean!
}

type ExtensionInstallationSelfEdge {
  installation: ExtensionInstallation
  token: ExtensionToken
  configuration: ExtensionConfiguration
  issuedAt: Time
}

type ExtensionLinkUserError {
  code: ExtensionLinkUserErrorCode
}

enum ExtensionLinkUserErrorCode {
  UNAUTHORIZED
  BAD_REQUEST
  UNKNOWN
}

input ExtensionLinkUserInput {
  channelID: ID!
  extensionID: ID!
  jwt: String
  showUser: Boolean!
}

type ExtensionLinkUserPayload {
  error: ExtensionLinkUserError
  token: ExtensionToken
}

type ExtensionManifest {
  assetManifest: ExtensionAssetManifest!
  capabilities: ExtensionCapabilities!
  developerManifest: ExtensionDeveloperManifest!
  discoveryManifest: ExtensionDiscoveryManifest!
  id: ID!
  version: String!
  views: ExtensionViews!
}

type ExtensionManifestConnection {
  edges: [ExtensionManifestEdge!]!
  pageInfo: PageInfo!
}

type ExtensionManifestEdge {
  cursor: Cursor!
  node: ExtensionManifest
}

type ExtensionManifestsSummary {
  isDeleted: Boolean!
  manifests: ExtensionManifestConnection
}

type ExtensionPanel implements Panel {
  id: ID!
  slotID: ID!
  type: PanelType!
}

type ExtensionRating {
  id: ID!
  isRecommended: Boolean!
  location: ExtensionRatingLocation!
}

enum ExtensionRatingLocation {
  NOTIFICATION
}

type ExtensionRatingsCSVReportPresignedURL {
  presignedURL: String
}

type ExtensionRecommendation {
  extension: Extension
}

type ExtensionRequiredAction {
  redirectURI: String
    @deprecated(
      reason: "PROMPT_FOR_PERMISSIONS is no longer a valid required action"
    )
  type: ExtensionRequiredActionType!
}

enum ExtensionRequiredActionType {
  PROMPT_FOR_PERMISSIONS
  REQUIRES_CONFIGURATION
}

type ExtensionSecret {
  activeAt: Time!
  content: String!
  expiresAt: Time!
}

type ExtensionSecretsInfo {
  error: GetExtensionSecretsError
  secrets: [ExtensionSecret!]
}

type ExtensionSelfConnection {
  canInstall: Boolean!
}

enum ExtensionState {
  IN_TEST
  READY_FOR_REVIEW
  IN_REVIEW
  REJECTED
  APPROVED
  RELEASED
  DEPRECATED
  PENDING_ACTION
  UPLOADING
  ASSETS_UPLOADED
  DELETED
}

enum ExtensionStateFilter {
  RELEASED
}

enum ExtensionSubscriptionsSupportLevel {
  NONE
  OPTIONAL
}

type ExtensionToken {
  extensionID: ID!
  jwt: String!
}

type ExtensionVersionDiscoveryManifest {
  discoveryManifest: ExtensionDiscoveryManifest!
  id: ID!
  version: String!
}

interface ExtensionView {
  viewerPath: String!
  viewerURL: String!
}

type ExtensionViews {
  component: ComponentView
  config: ConfigView
  hidden: HiddenView
  liveConfig: LiveConfigView
  mobile: MobileView
  panel: PanelView
  videoOverlay: VideoOverlayView
}

input ExtensionViewsInput {
  component: ComponentViewInput
  config: ConfigViewInput
  liveConfig: LiveConfigViewInput
  mobile: MobileViewInput
  panel: PanelViewInput
  videoOverlay: VideoOverlayViewInput
}

type ExtensionWhitelists {
  broadcasters: [ID!]!
  configURLs: [String!]!
  panelURLs: [String!]!
  testers: [ID!]!
}

input ExtensionWhitelistsInput {
  broadcasters: [ID!]!
  configURLs: [String!]!
  panelURLs: [String!]!
  testers: [ID!]!
}

type ExtensionZipUploadResponse {
  uploadID: ID!
  url: String!
}

type ExternalChargeModel {
  previewSKU: String!
  provider: String!
  sku: String! @deprecated(reason: "Use 'previewSKU' instead")
  self: ExternalChargeModelSelfEdge
}

type ExternalChargeModelSelfEdge {
  checkoutSKU: String!
}

type FeaturedContentSection {
  id: ID!
  items: [FeaturedItem!]
}

type FeaturedItem {
  content: FeaturedItemContent
  description: String!
  id: ID!
  imageURL: String!
  isScheduled: Boolean!
  isSponsored: Boolean!
  priorityLevel: Int!
  title: String!
}

union FeaturedItemContent = Stream | User | Video
type FeaturedStream {
  broadcaster: User
  channel: Channel
    @deprecated(reason: "Use featuredStream.broadcaster instead.")
  description: String
  descriptionHTML: String
    @deprecated(reason: "Use featuredStream.description instead")
  imageURL: String
  isScheduled: Boolean
  isSponsored: Boolean
  priorityLevel: Int
  stream: Stream
  title: String
}

type FeaturedVideo {
  description: String!
  imageURL: String!
  isScheduled: Boolean!
  isSponsored: Boolean!
  priorityLevel: Int!
  title: String!
  video: Video
}

type FeatureFlags {
  isPulseEnabled: Boolean @deprecated(reason: "Enabled for everyone.")
}

type Feed {
  id: ID!
  items(first: Int = 5, after: Cursor): FeedItemConnection
}

union FeedEmbed =
    Clip
  | LinkOEmbed
  | PhotoOEmbed
  | RichOEmbed
  | Video
  | VideoOEmbed
type FeedItem {
  content: FeedItemContent
  reasons: [FeedItemReason]
  tracking: FeedItemTracking
}

type FeedItemConnection {
  edges: [FeedItemEdge]
  pageInfo: PageInfo
}

union FeedItemContent = Clip | Post | Share | Stream | Video
type FeedItemEdge {
  cursor: Cursor
  node: FeedItem
}

type FeedItemReason {
  reason: String
}

type FeedItemTracking {
  batchID: String
  cardImpressionID: String
  recGenerationID: String
  recGenerationIndex: Int
}

input FinalizeCompetitionLobbyInput {
  competitionID: ID!
  lobbyID: ID!
  phaseID: ID!
}

type FinalizeCompetitionLobbyPayload {
  competition: Competition
  error: CompetitionError
}

type FirstCheerTutorial {
  hasAbandoned: Boolean
  hasSkipped: Boolean
}

type FlaggedTrack {
  albumTitle: String!
  appeal: FlaggedTrackAppeal
  id: ID!
  muteDurationSeconds: Int
  muteOffsetSeconds: Int
  performer: String!
  title: String!
}

type FlaggedTrackAppeal {
  id: ID!
  reason: String!
  status: FlaggedTrackAppealStatus!
}

enum FlaggedTrackAppealStatus {
  PENDING
  RESOLVED
}

type Follow {
  disableNotifications: Boolean
  followedAt: Time
  user: User
}

type FollowConnection {
  edges: [FollowEdge]
  pageInfo: PageInfo
  totalCount: Int
}

type FollowedGameConnection {
  nodes: [Game!]
}

enum FollowedGamesType {
  LIVE
  ALL
}

type FollowEdge {
  cursor: Cursor!
  disableNotifications: Boolean
    @deprecated(reason: "use notificationSettings.isEnabled instead.")
  followedAt: Time
  node: User
  notificationSettings: ChannelNotificationSettings
}

type FollowedHostConnection {
  nodes: [User]
}

type FollowedLiveUserConnection {
  edges: [FollowedLiveUserEdge]!
  nodes: [User]
    @deprecated(
      reason: "Use FollowedLiveUserConnection.edges instead for pagination support"
    )
  pageInfo: PageInfo!
}

type FollowedLiveUserEdge {
  cursor: Cursor!
  node: User
}

type FollowerConnection {
  edges: [FollowerEdge]
  pageInfo: PageInfo
  totalCount: Int
}

type FollowerEdge {
  cursor: Cursor!
  disableNotifications: Boolean
  followedAt: Time
  node: User
  notificationSettings: ChannelNotificationSettings
}

input FollowGameInput {
  gameID: ID!
}

type FollowGamePayload {
  game: Game
}

enum FollowsFilter {
  ALL
  SUBBABLE
}

type FollowUserError {
  code: FollowUserErrorCode!
}

enum FollowUserErrorCode {
  FORBIDDEN
  TOO_MANY_FOLLOWS
}

input FollowUserInput {
  disableNotifications: Boolean!
  targetID: ID!
}

type FollowUserPayload {
  error: FollowUserError
  follow: Follow
}

enum FormatType {
  DOUBLE_ELIM
  SINGLE_ELIM
  ROUND_ROBIN
  LEADERBOARD
  CUSTOM
  UNKNOWN
}

union FormatTypeDetails = LeaderboardDetails
union FragmentContent =
    AutoMod
  | CheermoteToken
  | Emote
  | RoomMessageGroupMention
  | User
type FriendConnection {
  edges: [FriendEdge]
  totalCount: Int!
}

type FriendEdge {
  activity: Activity
  availability: Availability!
  lastStatusChangeAt: Time
  node: User
}

union FriendRelationship =
    FriendEdge
  | IncomingFriendRequestEdge
  | OutgoingFriendRequestEdge
enum FriendSort {
  ASC
  DESC
}

type Game implements Directory {
  activeDropCampaigns: [DropCampaign!]
    @deprecated(reason: "Functionality not supported in Drops 2.0")
  avatarURL(width: Int, height: Int): String
  boxArtURL(width: Int, height: Int): String
  broadcastersCount: Int
  channelsCount: Int @deprecated(reason: "Use broadcastersCount instead.")
  clips(
    first: Int = 10
    after: Cursor
    criteria: GameClipsInput
  ): ClipConnection
  coverURL(width: Int, height: Int): String
  description: String
  developers: [String!]
  directoryType: DirectoryType
  displayName: String!
  dropAccountLink: DropAccountLink
  enhancedExperiencesClients(organizationID: ID!): [EnhancedExperiencesClient!]
  esrbRating: ESRBRating!
  esrbDescriptions: [String!]
  extensionRecommendations: [ExtensionRecommendation!]
  upcomingStreams(
    first: Int = 10
    utcOffsetMinutes: Int = 0
  ): GameUpcomingStreamConnection
  followersCount: Int
  franchises: [String!]
  giantBombID: ID @deprecated
  id: ID!
  logoURL(width: Int, height: Int): String
  name: String!
  originalReleaseDate: String
  platforms: [String!]
  popularityScore: Int
  prestoID: ID
  publishers: [String!]
  self: GameSelfConnection

  streams(
    first: Int = 10
    after: Cursor
    options: GameStreamOptions
    languages: [String!]
    filters: StreamMetadataFilterInput
    sort: StreamSort = VIEWER_COUNT
    requestID: ID
    tags: [String!]
  ): StreamConnection
  tags(limit: Int = 5, tagType: TagType!): [Tag!]
  videos(
    first: Int = 10
    after: Cursor
    languages: [String!]
    types: [BroadcastType!]
    sort: VideoSort = TIME
  ): VideoConnection
  viewersCount: Int
}

type GameApplication {
  createdAt: Time!
  game: Game!
  id: ID!
  organization: Organization!
}

type GameChangeMomentDetails {
  game: Game
}

input GameClipsInput {
  broadcasterID: ID
  curatorID: ID
  endAt: Time
  filter: ClipsFilter
  languages: [Language!]
  period: ClipsPeriod = LAST_WEEK
  sort: ClipsSort = VIEWS_DESC
  startAt: Time
}

type GameConnection {
  edges: [GameEdge!]
  pageInfo: PageInfo!
}

type GameEdge {
  cursor: Cursor
  node: Game
  trackingID: ID
}

type GameFollow {
  followedAt: Time!
  game: Game
  user: User
}

input GameOptions {
  locale: String
  recommendationsContext: RecommendationsContext
  requestID: ID
  sort: GameSort = VIEWER_COUNT
  tags: [String!]
}

type GameOverlap {
  score: Float!
  viewersAlsoWatch: Game
}

type GameSelfConnection {
  follow: GameFollow
  isDropsLinked: Boolean
}

enum GameSort {
  VIEWER_COUNT
  RELEVANCE
}

input GameStreamOptions {
  includeRestricted: [StreamRestrictionType!]
  languages: [String!]
  locale: String
  recommendationsContext: RecommendationsContext
  requestID: ID
  sort: StreamSort = VIEWER_COUNT
  tags: [String!]
}

type GameUpcomingStreamConnection {
  nodes: [ScheduleSegment!]!
}

input GDPRConsent {
  allowAmazon: Boolean
  allowComscore: Boolean
  allowGoogle: Boolean
  allowNielsen: Boolean
  allowSalesforce: Boolean
}

union GDPRCookieVendor = NonTCFCookieVendor | TCFCookieVendor
type GDPRVendorConsent {
  status: [GDPRCookieVendor!]!
}

input GenerateAnimatedEmoteInput {
  image4xID: ID!
  preset: AnimatedEmotePreset!
}

type GenerateAnimatedEmotePayload {
  id: ID
  animatedAssets: [AnimatedImageAsset!]
}

input GenerateExtensionRatingsCSVReportInput {
  endAt: Time!
  extensionID: ID!
  startAt: Time!
}

type GenerateExtensionRatingsCSVReportPayload {
  reportFilename: String
}

type GenerateSecondFactorQRCodeError {
  code: GenerateSecondFactorQRCodeErrorCode!
  message: String!
}

enum GenerateSecondFactorQRCodeErrorCode {
  REAUTH_NEEDED
  NO_TWO_FACTOR
  REQUEST_THROTTLED
  USER_NOT_FOUND
  UNKNOWN_ERROR
}

input GenerateSecondFactorQRCodeInput {
  userID: ID!
}

type GenerateSecondFactorQRCodePayload {
  error: GenerateSecondFactorQRCodeError
  qrCode: String
}

input GenerateSubscribersCSVInput {
  channelID: String!
}

type GenerateSubscribersCSVPayload {
  channelID: ID!
}

type GenericCreatorHomeCard implements CreatorHomeCard {
  type: String!
  error: CreatorHomeError
}

input GetEmoteUploadConfigInput {
  assetType: EmoteAssetType
  generateStaticVersionOfAnimatedAssets: Boolean
  resizePlan: EmoteResizePlan!
  sizes: [EmoteImageSize!]
}

type GetEmoteUploadConfigPayload {
  uploadConfig: UploadConfig @deprecated(reason: "Use uploadConfigs instead.")
  uploadConfig1x: UploadConfig @deprecated(reason: "Use uploadConfigs instead.")
  uploadConfig2x: UploadConfig @deprecated(reason: "Use uploadConfigs instead.")
  uploadConfig4x: UploadConfig @deprecated(reason: "Use uploadConfigs instead.")
  uploadConfigs: [UploadConfig!]
}

enum GetExtensionSecretsError {
  INVALID_CLIENT
  UNAUTHORIZED
  INTERNAL
}

type GiftCardCode implements Claimable {
  description: String!
  id: ID!
  self: SelfClaimEdge
  type: ClaimableType!
}

type GiftCardCodeSelfClaimEdge implements SelfClaimEdge {
  canClaim: Boolean!
  countryOfResidence: String
  id: ID!
  statusCode: String
}

enum GiftType {
  SINGLE_RECIPIENT
  COMMUNITY
}

type GlobalCheerConfig {
  displayConfig: CheermoteDisplayConfig!
  groups: [CheermoteGroup!]!
}

type GoLiveNotification {
  customText: String!
  engagements: Int!
  followerCount: Int!
  followersNotified: Int!
  streamStartTime: Time!
}

type GoLiveNotificationConnection {
  edges: [GoLiveNotificationEdge!]!
  pageInfo: PageInfo!
}

type GoLiveNotificationEdge {
  cursor: Cursor!
  node: GoLiveNotification
}

type GoLiveNotificationTimeseries {
  items: [GoLiveNotificationTimeseriesItem!]
  total: Int!
}

type GoLiveNotificationTimeseriesItem {
  engagements: Int!
  timestamp: Time!
}

type GoRaidError {
  code: GoRaidErrorCode!
}

enum GoRaidErrorCode {
  INVALID_CHANNEL
  NO_ACTIVE_RAID
}

input GoRaidInput {
  sourceID: ID!
}

type GoRaidPayload {
  error: GoRaidError
  raid: Raid
}

enum GrantType {
  AUTHORIZATION_CODE
  REFRESH_TOKEN
}

type GrantVIPError {
  code: GrantVIPErrorCode!
}

enum GrantVIPErrorCode {
  CHANNEL_NOT_FOUND
  FORBIDDEN
  GRANTEE_ALREADY_VIP
  GRANTEE_CHAT_BANNED
  GRANTEE_NOT_FOUND
  MAX_VIPS_REACHED
  VIP_ACHIEVEMENT_INCOMPLETE
}

input GrantVIPInput {
  channelID: ID!
  granteeID: ID
  granteeLogin: String
}

type GrantVIPPayload {
  channel: User
  error: GrantVIPError
  grantee: User
}

enum Granularity {
  FIVE_MINUTE
  TWENTY_MINUTE
  FORTY_MINUTE
  DAY
  WEEK
  MONTH
}

type HearthsoneMomentGameMode {
  type: String!
  value: String
}

type HearthstoneMomentDetails {
  broadcasterHero: HearthstoneMomentHero
  gameMode: HearthsoneMomentGameMode
  opponentHero: HearthstoneMomentHero
}

type HearthstoneMomentHero {
  class: String!
  id: ID!
  name: String!
}

type Hero {
  id: ID!
  imageURI: String!
  self: HeroConfiguration
}

type HeroAsset {
  color: String
  colorMaskURI: String
  expiresAt: Time
  isNew: Boolean
  lineArtURI: String
  supportedSkeletons: [HeroSkeleton!]
  type: HeroAssetType!
}

type HeroAssetPosition {
  assetType: HeroAssetType!
  x: Int!
  y: Int!
}

enum HeroAssetType {
  BACKGROUND
  HAT
  HAIR
  EYEBROWS
  EYES
  GLASSES
  NOSE
  MOUTH
  FACIAL_HAIR
  FRECKLES
  UNDERSHIRT
  JACKET
  GLOVES
  PANTS
  SOCKS
  SHOES
}

type HeroConfiguration {
  assets: [HeroAsset!]
  skeleton: HeroSkeleton
  skeletonColor: String
}

enum HeroPreset {
  PRESET_1
  PRESET_2
}

type HeroSkeleton {
  assetPositions: [HeroAssetPosition!]!
  colorMaskURI: String!
  id: ID!
  lineArtURI: String!
}

type HiddenView implements ExtensionView {
  canLinkExternalContent: Boolean!
  viewerPath: String!
  viewerURL: String!
}

input HiddenViewInput {
  viewerPath: String!
}

input HighlightRange {
  endMs: Int!
  startMs: Int!
  vodID: ID!
}

type HistoricalCompetitionLobby {
  id: ID!
  winner: CompetitionLobbyParticipant
}

type HostConnection {
  edges: [HostEdge!]
  pageInfo: PageInfo!
  totalCount: Int
}

type HostEdge {
  cursor: Cursor!
  node: User
}

type HostTargetChannelError {
  code: HostTargetChannelErrorCode!
}

enum HostTargetChannelErrorCode {
  TARGET_CHANNEL_ALREADY_HOSTED
  UNHOSTABLE_CHANNEL
  TARGET_CHANNEL_IN_BAD_STANDING
  CANNOT_HOST_SELF
}

input HostTargetChannelInput {
  channelID: ID!
  targetID: ID!
}

type HostTargetChannelPayload {
  error: HostTargetChannelError
  source: User
  target: User
}

type HypeTrain {
  config: HypeTrainConfig
  execution: HypeTrainExecution
}

type HypeTrainBadgeReward implements HypeTrainReward {
  badge: Badge
  id: ID!
  type: HypeTrainRewardType!
}

type HypeTrainConductor {
  participation: [HypeTrainParticipation!]!
  source: HypeTrainParticipationSource!
  user: User!
}

type HypeTrainConductorReward {
  rewards: [HypeTrainReward!]!
  source: HypeTrainParticipationSource!
  type: HypeTrainConductorType!
}

enum HypeTrainConductorType {
  CURRENT
  FORMER
  UNKNOWN
}

type HypeTrainConfig {
  calloutEmote: Emote
  conductorRewards: [HypeTrainConductorReward!]!
  cooldownPeriodMinutes: Int!
  difficulty: HypeTrainDifficulty!
  difficultySettings: [HypeTrainDifficultySettings!]!
  id: ID!
  isEnabled: Boolean!
  kickoff: HypeTrainKickoffConfig!
  levelDurationSeconds: Int!
  notificationThresholds: [HypeTrainNotificationThreshold!]!
  participationConversionRates: [HypeTrainParticipationConversionRate!]!
  primaryHexColor: String
  shouldUsePersonalizedSettings: Boolean!
  willUseCreatorColor: Boolean!
}

enum HypeTrainDifficulty {
  EASY
  MEDIUM
  HARD
  SUPER_HARD
  INSANE
  UNKNOWN
}

type HypeTrainDifficultySettings {
  difficulty: HypeTrainDifficulty!
  levels: [HypeTrainLevel!]!
}

type HypeTrainEmoteReward implements HypeTrainReward {
  emote: Emote
  id: ID!
  type: HypeTrainRewardType!
}

enum HypeTrainEndReason {
  EXPIRED
  IN_PROGRESS
  COMPLETED
  UNKNOWN
}

enum HypeTrainEventType {
  HYPE_TRAIN_STARTED
  HYPE_TRAIN_ENDED
  HYPE_TRAIN_COOL_DOWN_EXPIRED
}

type HypeTrainExecution {
  conductors: [HypeTrainConductor!]!
  config: HypeTrainConfig!
  endReason: HypeTrainEndReason
  endedAt: Time
  expiresAt: Time!
  id: ID!
  isActive: Boolean!
  participations: [HypeTrainParticipation!]!
  progress: HypeTrainProgress!
  startedAt: Time!
  updatedAt: Time!
}

type HypeTrainKickoffConfig {
  eventsThreshold: Int!
  minPoints: Int!
  periodSeconds: Int!
}

input HypeTrainKickoffInput {
  eventsThreshold: Int
}

type HypeTrainLevel {
  goal: Int!
  id: ID!
  rewards: [HypeTrainReward!]!
  value: Int!
}

type HypeTrainNotificationThreshold {
  action: HypeTrainParticipationAction!
  source: HypeTrainParticipationSource!
  value: Int!
}

type HypeTrainParticipation {
  action: HypeTrainParticipationAction!
  quantity: Int!
  source: HypeTrainParticipationSource!
}

enum HypeTrainParticipationAction {
  CHEER
  BITS_ON_EXTENSION
  POLLS
  TIER_1_SUB
  TIER_2_SUB
  TIER_3_SUB
  TIER_1_GIFTED_SUB
  TIER_2_GIFTED_SUB
  TIER_3_GIFTED_SUB
  UNKNOWN
}

type HypeTrainParticipationConversionRate {
  action: HypeTrainParticipationAction!
  source: HypeTrainParticipationSource!
  value: Int!
}

enum HypeTrainParticipationSource {
  BITS
  SUBS
  UNKNOWN
}

type HypeTrainProgress {
  goal: Int!
  level: HypeTrainLevel!
  progression: Int!
  remainingSeconds: Int!
  total: Int!
}

interface HypeTrainReward {
  id: ID!
  type: HypeTrainRewardType!
}

enum HypeTrainRewardType {
  EMOTE
  BADGE
  UNKNOWN
}

type Image {
  height: Int!
  imageURL: String! @deprecated(reason: "Use the 'url' query instead.")
  url(width: Int, height: Int): String!
  width: Int!
}

input ImageOptions {
  height: Int
  width: Int
}

type IncomingFriendRequestConnection {
  edges: [IncomingFriendRequestEdge!]!
  newestEdge: IncomingFriendRequestEdge
  pageInfo: PageInfo!
  totalCount: Int!
  totalUnreadCount: Int!
}

type IncomingFriendRequestEdge {
  createdAt: Time!
  cursor: Cursor!
  node: User
}

enum IncomingRaidsPolicy {
  NONE
  NETWORK
  ALL
}

type IngestFrameDrop {
  durationSeconds: Float!
  startedAt: Time!
}

type IngestSession {
  broadcastFormat: BroadcastFormat!
  ingestHost: String
  ingestProxy: String!
  streamDelaySeconds: Int!
  streamDownAt: Time
  streamUpAt: Time
}

type IngestStarvationEvent {
  durationSeconds: Float!
  startedAt: Time!
}

type IngestStreamHealth {
  reasons: [IngestStreamHealthReason!]
  status: IngestStreamHealthStatus!
}

enum IngestStreamHealthReason {
  UNKNOWN
  ALL_GOOD
  INCOMP_AUDIO_CODEC
  INCOMP_VIDEO_CODEC
  INCOMP_MP3_DEPRECATED
  HIGH_BITRATE
  DROPPED_FRAMES
  STARVATION
  HIGH_KEY_FRAME_INTERVAL
}

enum IngestStreamHealthStatus {
  UNKNWON @deprecated(reason: "Use UNKNOWN instead")
  OK
  WARN
  UNSTABLE
  UNKNOWN
}

type InsightCreatorHomeCard implements CreatorHomeCard {
  type: String!
  currentValue: Float!
  error: CreatorHomeError
}

type InstallExtensionError {
  code: InstallExtensionErrorCode!
  installationID: ID
}

enum InstallExtensionErrorCode {
  UNAUTHORIZED
  INVALID_CHANNEL_ID
}

input InstallExtensionInput {
  channelID: ID!
  extensionID: ID!
}

type InstallExtensionPayload {
  error: InstallExtensionError
  installedExtension: ExtensionInstallation
}

type IntegerToken {
  value: Int!
}

type InternalChargeModel {
  plan: ChargeModelPlan
  previewPrice: PriceInfo
  priceID: ID!
  self: InternalChargeModelSelfEdge
}

type InternalChargeModelSelfEdge {
  checkoutPrice(
    quantity: Int!
    paymentProvider: PaymentProvider!
  ): ProductPurchase
}

type InterruptScheduleBoundsError implements InterruptScheduleError {
  code: InterruptScheduleErrorCode!
  maximum: Int
  minimum: Int
}

interface InterruptScheduleError {
  code: InterruptScheduleErrorCode!
}

enum InterruptScheduleErrorCode {
  FORBIDDEN
  NOT_FOUND
  END_TOO_FAR_IN_FUTURE
  INVALID_ARGUMENT
}

input InterruptScheduleInput {
  endAt: Time!
  reason: ScheduleInterruptionReason!
  scheduleID: ID!
  startAt: Time!
  timezone: String!
}

type InterruptSchedulePayload {
  error: InterruptScheduleError
  schedule: Schedule
}

type InterruptScheduleStandardError implements InterruptScheduleError {
  code: InterruptScheduleErrorCode!
}

input InvalidateAuthenticatedSessionsInput {
  keepSession: String
  userID: ID!
}

type InvalidateAuthenticatedSessionsPayload {
  user: User
}

input InvalidateEmailAssociationInput {
  email: String!
  emailAssociationOpaqueID: ID!
}

type InvalidateEmailAssociationPayload {
  hasSucceeded: Boolean!
}

type Inventory {
  dropCampaignsInProgress: [DropCampaign!]
  drops: UserDropAwardConnection
  gameEventDrops: [UserDropReward]
}

enum InvitationType {
  TOP
  PAYOUT
  UPGRADE
}

input IOSPaymentTrackingDataInput {
  deviceID: ID
  locale: String
}

input IOSReceiptDataInput {
  signedReceipt: String!
  extTransactionID: ID!
}

type ItBegins {
  badgeURL: String
  completedAt: Time
  hasStreamed: Boolean
  hasUpdatedCategory: Boolean
  hasUpdatedStreamTitle: Boolean
  hasVisitedDashboard: Boolean
}

input JoinChannelRoomsInput {
  channelID: ID!
}

type JoinChannelRoomsPayload {
  channel: User
}

input JoinRaidInput {
  raidID: ID!
}

type JoinRaidPayload {
  raidID: ID
}

type KeyBatchConnection {
  edges: [KeyBatchEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type KeyBatchEdge {
  cursor: Cursor!
  node: KeyBatchNode
}

type KeyBatchNode {
  id: ID!
  numKeys: Int!
  status: KeyBatchStatus!
}

enum KeyBatchStatus {
  ACTIVE
  INACTIVE
  INVALIDATED
}

type KeyPoolConnection {
  edges: [KeyPoolEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type KeyPoolEdge {
  cursor: Cursor!
  node: KeyPoolNode
}

type KeyPoolNode {
  batches(after: String): KeyBatchConnection
  description: String!
  id: ID!
  productType: String!
  sku: String!
  status: KeyPoolStatus!
}

enum KeyPoolStatus {
  ACTIVE
  INACTIVE
  INVALIDATED
}

enum Language {
  AR
  ASL
  BG
  CA
  CS
  DA
  DE
  EL
  EN
  ES
  FI
  FR
  HI
  HU
  ID
  IT
  JA
  KO
  MS
  NL
  NO
  OTHER
  PL
  PT
  RO
  RU
  SK
  SV
  TH
  TL
  TR
  UK
  VI
  ZH
  ZH_HK
}

enum LanguageTag {
  AR
  BG
  CS
  DA
  DE
  EL
  EN
  EN_GB
  ES
  ES_MX
  FI
  FR
  HI
  HU
  IT
  JA
  KO
  NL
  NO
  PL
  PT
  PT_BR
  RO
  RU
  SK
  SV
  TH
  TR
  VI
  ZH_CN
  ZH_TW
  ZH
}

type LeaderboardDetails {
  lobbyMaxSize: Int!
  phaseCount: Int!
  tiebreakerLabel: TiebreakerLabel
}

type LeaderboardSet {
  bits: UserLeaderboard
  subGift: UserLeaderboard
}

type LeaderboardSettings {
  defaultLeaderboard: LeaderboardType!
  isCheerEnabled: Boolean!
  isSubGiftEnabled: Boolean!
  timePeriod: LeaderboardTimePeriodType!
}

enum LeaderboardTimePeriodType {
  DAY
  WEEK
  MONTH
  ALLTIME
}

enum LeaderboardType {
  CHEER
  SUBGIFT
}

input LeaveChannelRoomsInput {
  channelID: ID!
}

type LeaveChannelRoomsPayload {
  channel: User
}

input LeaveRaidInput {
  raidID: ID!
}

type LeaveRaidPayload {
  raidID: ID
}

type LeaveSquadStreamError {
  code: LeaveSquadStreamErrorCode!
}

enum LeaveSquadStreamErrorCode {
  USER_NOT_IN_SQUAD
  UNAUTHORIZED
}

input LeaveSquadStreamInput {
  memberID: ID!
  squadStreamID: ID!
}

type LeaveSquadStreamPayload {
  error: LeaveSquadStreamError
  squadStream: SquadStream
}

type LinkOEmbed implements OEmbed {
  authorName: String
  authorURL: String
  cacheAge: Int
  inputURL: String!
  providerName: String
  providerURL: String
  thumbnail: ThumbnailOEmbed
  title: String
  type: String!
  version: String!
}

type LinkSSOError {
  code: LinkSSOErrorCode! @deprecated(reason: "To be removed.")
}

enum LinkSSOErrorCode {
  CODE_INCORRECT @deprecated(reason: "To be removed.")
  CODE_EXPIRED @deprecated(reason: "To be removed.")
  ALREADY_LINKED @deprecated(reason: "To be removed.")
}

input LinkSSOInput {
  code: String!
}

type LinkSSOPayload {
  error: LinkSSOError @deprecated(reason: "To be removed.")
  link: SSOLink @deprecated(reason: "To be removed.")
}

enum LinkType {
  NO_LINK
  CATEGORIES_DIRECTORY
  STREAMS_DIRECTORY
}

type LiveConfigView implements ExtensionView {
  canLinkExternalContent: Boolean!
  viewerPath: String!
  viewerURL: String!
}

input LiveConfigViewInput {
  viewerPath: String!
}

type LiveRecommendationConnection {
  edges: [StreamRecommendationEdge!]
  generationID: String!
  nodes: [Stream]!
    @deprecated(
      reason: "To be replaced by edges which also includes a required trackingID."
    )
  responseID: String!
}

type LiveUpNotificationInfo {
  isDefault: Boolean
  liveUpNotification: String
}

enum LobbyState {
  PREP
  READY
  ACTIVE
  DONE
  UNKNOWN
}

type LocalEmoteDashboard {
  status: EmoteDashboardStatus
}

type LockPredictionEventError {
  code: LockPredictionEventErrorCode!
}

enum LockPredictionEventErrorCode {
  FORBIDDEN
  EVENT_NOT_ACTIVE
  UNKNOWN
}

input LockPredictionEventInput {
  id: ID!
}

type LockPredictionEventPayload {
  error: LockPredictionEventError
  predictionEvent: PredictionEvent
}

type LoyaltyBadge {
  channelTenureMethodID: ID!
  id: ID!
  image1xURL: String!
  image2xURL: String!
  image4xURL: String!
  requiredTenureMonths: Int!
  title: String!
}

type LoyaltyBadgeUploadConfig {
  imageID: ID
  imageURL: String
  uploadID: ID
  uploadURL: String
}

type LWAToken {
  accessToken: String!
  expiresIn: Int!
  refreshToken: String!
}

input MakeKeyBatchDownloadURLInput {
  batchID: String!
}

type MakeKeyBatchDownloadURLPayload {
  decryptionKey: String!
  url: String!
}

type MakePredictionError {
  code: MakePredictionErrorCode!
  maxPointsPerEvent: Int
  userPointsSpent: Int
}

enum MakePredictionErrorCode {
  FORBIDDEN
  NOT_FOUND
  EVENT_NOT_ACTIVE
  DUPLICATE_TRANSACTION
  TRANSACTION_IN_PROGRESS
  NOT_ENOUGH_POINTS
  MAX_POINTS_PER_EVENT
  MULTIPLE_OUTCOMES
  REGION_LOCKED
  MUST_ACCEPT_TOS
  RATE_LIMITED
  CATEGORY_REGION_LOCKED
  EVENT_MANAGER
  SPECTATOR_MODE_INELIGIBLE
  SPECTATOR_MODE_DUPLICATE
  UNKNOWN
}

input MakePredictionInput {
  eventID: ID!
  outcomeID: ID!
  points: Int!
  transactionID: ID!
}

type MakePredictionPayload {
  error: MakePredictionError
  prediction: Prediction
}

type ManualChannelChallenge implements ChannelChallenge {
  bitsAmount: Int!
  createdAt: Time!
  createdBy: User
  durationSeconds: Int!
  id: ID!
  ownedBy: User
  remainingDurationMilliseconds: Int!
  self: ChannelChallengeSelfEdge
  status: ChannelChallengeStatus!
  title: String!
  updatedAt: Time!
}

input ManuallyTriggerDropInput {
  campaignID: ID!
  dropID: ID!
  ownerID: ID!
}

type ManuallyTriggerDropPayload {
  error: DropsError
  triggerResults: [TriggerResult!]
}

enum ManuallyTriggerDropResultStatus {
  SUCCESS
  VERIFICATION_FAILURE
  ERROR
}

type ManualTriggerBasedDrop implements DropType {
  benefitEdges: [DropBenefitEdge!]
  campaign: DropCampaign!
  claimDurationSeconds: Int!
  endAt: Time!
  id: ID!
  name: String!
  startAt: Time!
}

input MarkAllCreatorNotificationsAsReadInput {
  userID: ID!
}

type MarkAllCreatorNotificationsAsReadPayload {
  hasSucceeded: Boolean
}

input MarkAllViewerNotificationsAsReadInput {
  userID: ID!
}

type MarkAllViewerNotificationsAsReadPayload {
  hasSucceeded: Boolean
}

enum MemberMetricsRevealedParams {
  NONE
  STATS
  REVENUE
  STATS_AND_REVENUE
}

type Message {
  content: MessageContent!
  deletedAt: Time
  id: ID!
  parentMessage: Message
  replies: MessageReplyConnection
  sender: User
  sentAt: Time!
}

type MessageBody {
  content: String
  emotes: [EmbeddedEmote]
}

type MessageContent {
  fragments: [MessageFragment!]!
  text: String!
}

type MessageFragment {
  content: FragmentContent
  text: String!
}

type MessageReplyConnection {
  nodes: [Message!]!
  totalCount: Int!
}

type Milestone {
  endDate: String! @deprecated
  id: ID! @deprecated
  isPrimeOnly: Boolean! @deprecated
  objectiveTag: String! @deprecated
  participationThreshold: Int! @deprecated
  requiredSubscriptions: [SubscriptionProduct!] @deprecated
  rewards: [TournamentReward!]! @deprecated
  startDate: String! @deprecated
  threshold: Int! @deprecated
}

input MobileAdIdentityInput {
  deviceInfo: MobileDeviceInfo!
  lmt: Boolean!
  mAID: ID!
  platform: AdPlatform!
  userAgent: String!
}

input MobileDeviceInfo {
  make: String!
  model: String!
  os: String!
  osVersion: String!
}

type MobileView implements ExtensionView {
  viewerPath: String!
  viewerURL: String!
}

input MobileViewInput {
  viewerPath: String!
}

type ModConnection {
  edges: [ModEdge!]!
  pageInfo: PageInfo!
}

type ModEdge {
  cursor: Cursor!
  grantedAt: Time!
  isActive: Boolean
  node: User!
}

enum ModerationAction {
  AUTOMOD_LEVEL_CHANGE
  ALLOW_MESSAGE
  APPROVE_UNBAN_REQUEST
  BAN_USER
  BLOCKED_TERM_ADD
  BLOCKED_TERM_REMOVE
  CHAT_CLEAR
  COMMENT
  DELETE_MESSAGE
  DENY_MESSAGE
  DENY_UNBAN_REQUEST
  EMOTES_ONLY_OFF
  EMOTES_ONLY_ON
  FOLLOWERS_ONLY_OFF
  FOLLOWERS_ONLY_ON
  HOST
  INVALID_ACTION
  UNMOD_USER
  MOD_USER
  PERMITTED_TERM_ADD
  PERMITTED_TERM_REMOVE
  RAID
  SLOW_OFF
  SLOW_ON
  SUBS_ONLY_OFF
  SUBS_ONLY_ON
  TIMEOUT_USER
  UNBAN_USER
  UNHOST
  UNIQUE_OFF
  UNIQUE_ON
  UNRAID
  UNTIMEOUT_USER
  UNVIP_USER
  VIP_USER
}

type ModerationLogs {
  actions(
    first: Int = 100
    after: Cursor
    order: SortOrder = DESC
  ): ChannelModerationActionConnection
}

type ModLogs {
  comments(
    targetID: ID!
    after: Cursor
    first: Int = 100
    order: SortOrder = DESC
  ): ModLogsCommentConnection
  messagesBySender(
    senderID: ID!
    first: Int = 100
    after: Cursor
    order: SortOrder = DESC
    includeMessageCount: Boolean = true
    includeTargetedActions: Boolean = true
    includeAutoModCaughtMessages: Boolean = false
  ): ModLogsMessageConnection
  targetedModActions(
    targetID: ID!
    actionType: ModLogsAction!
  ): ModLogsTargetedModActionsConnection
}

type ModLogsAccess {
  accessLevel: ModLogsAccessLevel!
  channelRole: ChannelUserRole!
}

enum ModLogsAccessLevel {
  NONE
  READ
  WRITE
}

enum ModLogsAction {
  INVALID_ACTION
  BAN_USER
  TIMEOUT_USER
  UNBAN_USER
  SET_CHANNEL_MODE
  CHANGE_CHANNEL_RULES
  ALLOW_MESSAGE
  DENY_MESSAGE
  UPDATE_MODERATED_TERMS
  COMMENT
  UNTIMEOUT_USER
}

type ModLogsComment {
  author: User
  channel: User
  details: ModLogsCommentDetails
  id: ID!
  target: User
  timestamp: Time!
}

type ModLogsCommentConnection {
  edges: [ModLogsCommentEdge!]
  pageInfo: PageInfo!
}

type ModLogsCommentDetails {
  text: String
}

type ModLogsCommentEdge {
  cursor: Cursor!
  node: ModLogsComment
}

type ModLogsMessage {
  content: ModLogsMessageContent!
  id: ID!
  sender: User
  sentAt: Time!
}

type ModLogsMessageConnection {
  edges: [ModLogsMessageEdge!]!
  messageCount: Int
  pageInfo: PageInfo!
}

type ModLogsMessageContent {
  fragments: [ModLogsMessageFragment!]!
  text: String!
}

type ModLogsMessageEdge {
  cursor: Cursor!
  node: ModLogsMessageResult
}

type ModLogsMessageFragment {
  content: FragmentContent
  text: String!
}

union ModLogsMessageResult =
    AutoModCaughtMessage
  | ModLogsMessage
  | ModLogsTargetedModActionsEntry
type ModLogsTargetedModActionsConnection {
  actionCount: Int!
  edges: [ModLogsTargetedModActionsEdge!]
  pageInfo: PageInfo!
}

type ModLogsTargetedModActionsEdge {
  cursor: Cursor!
  node: ModLogsTargetedModActionsEntry
}

type ModLogsTargetedModActionsEntry {
  action: ModLogsAction!
  channel: User
  details: TargetedModActionDetails
  id: ID!
  target: User
  timestamp: Time!
  user: User
}

type ModUserError {
  code: ModUserErrorCode!
}

enum ModUserErrorCode {
  FORBIDDEN
  TARGET_NOT_FOUND
  CHANNEL_NOT_FOUND
  TARGET_IS_CHAT_BANNED
  TARGET_ALREADY_MOD
}

input ModUserInput {
  channelID: ID!
  targetID: ID
  targetLogin: String
}

type ModUserPayload {
  channel: User
  error: ModUserError
  target: User
}

type ModViewNewsfeedEntry {
  content: String!
  iconURL: String
  id: ID!
  linkText: String
  linkURL: String
  position: Int!
  publishedAt: Time
  title: String!
}

type ModViewSettings {
  tutorialSeenAt: Time
  tutorialState: TutorialState
}

scalar MosaicData

type MovieDetails {
  durationSeconds: Int
}

type MultiplayerAdOffer {
  adDurationSeconds: Int!
  brandName: String
  broadcasterMessage: String
  creditDurationSeconds: Int
  expiresAt: Time!
  id: ID!
  rewardsMaxRate: Float
  rewardsMinRate: Float
}

type MultiviewContentAttribute {
  childIDs: [ID!]
  createdAt: Time
  id: ID!
  imageURL: String
  key: String!
  name: String!
  ownerChannel: Channel
  parentID: ID
  parentKey: String
  updatedAt: Time
  value: String!
  valueShortName: String
}

input MultiviewContentAttributeParams {
  childIDs: [ID!]
  id: ID
  imageURL: String
  key: String!
  name: String!
  ownerChannelID: ID
  parentID: ID
  parentKey: String
  value: String!
  valueShortName: String
}

type Mutation {
  acceptFriendRequest(
    input: AcceptFriendRequestInput!
  ): AcceptFriendRequestPayload
  acceptOrganizationInvite(
    input: AcceptOrganizationInviteInput!
  ): AcceptOrganizationInvitePayload
  acceptProgramAgreement(
    input: AcceptProgramAgreementInput!
  ): AcceptProgramAgreementPayload
  acceptSquadStreamInvitation(
    input: AcceptSquadStreamInvitationInput!
  ): AcceptSquadStreamInvitationPayload
  acknowledgePredictionResult(
    input: AcknowledgePredictionResultInput!
  ): AcknowledgePredictionResultPayload
  acknowledgeSubscriptionState(
    input: AcknowledgeSubscriptionStateInput!
  ): AcknowledgeSubscriptionStatePayload
  acknowledgeUnbanRequest(
    input: AcknowledgeUnbanRequestInput!
  ): AcknowledgeUnbanRequestPayload
  activateExtension(input: ActivateExtensionInput!): ActivateExtensionPayload
    @deprecated(reason: "Should use applyExtensionActivations instead")
  addAutohostChannels(
    input: AddAutohostChannelsInput!
  ): AddAutohostChannelsPayload
  addBrowserPushSubscription(
    input: AddBrowserPushSubscriptionInput!
  ): AddBrowserPushSubscriptionPayload
  addChannelBlockedTerm(
    input: AddChannelBlockedTermInput!
  ): AddChannelBlockedTermPayload
  addChannelPermittedTerm(
    input: AddChannelPermittedTermInput!
  ): AddChannelPermittedTermPayload
  addCollectionItem(input: AddCollectionItemInput!): AddCollectionItemPayload
  addCompetitionPhase(
    input: AddCompetitionPhaseInput!
  ): AddCompetitionPhasePayload
  addCompetitionPlayer(
    input: AddCompetitionPlayerInput!
  ): AddCompetitionPlayerPayload
  addCompetitionTeam(input: AddCompetitionTeamInput!): AddCompetitionTeamPayload
  addDeviceToken(input: AddDeviceTokenInput!): AddDeviceTokenPayload
  addDropToCampaign(input: AddDropToCampaignInput!): AddDropToCampaignPayload
  addEditor(input: AddEditorInput!): AddEditorPayload
  addRadioRecentlyPlayed(
    input: AddRadioRecentlyPlayedInput!
  ): AddRadioRecentlyPlayedPayload
  addReaction(input: AddReactionInput!): AddReactionPayload @deprecated
  addRecommendationFeedback(
    input: AddRecommendationFeedbackInput!
  ): AddRecommendationFeedbackPayload
  addStreamAuthorizedUser(
    input: AddStreamAuthorizedUserInput!
  ): AddStreamAuthorizedUserPayload
  allocateKeysForBounty(
    input: AllocateKeysForBountyInput!
  ): AllocateKeysForBountyPayload
  allowRejectedChatMessage(
    input: AllowRejectedChatMessageInput!
  ): AllowRejectedChatMessagePayload
  allowRejectedCheer(
    input: AllowRejectedCheerInput!
  ): AllowRejectedCheerPayload
    @deprecated(reason: "logic handled by allowRejectedChatMessage")
  applyExtensionActivations(
    input: ApplyExtensionActivationsInput!
  ): ApplyExtensionActivationsPayload
  approveUnbanRequest(
    input: ApproveUnbanRequestInput!
  ): ApproveUnbanRequestPayload
  archiveChanlet(input: ArchiveChanletInput!): ArchiveChanletPayload
  archiveCommunityPointsCommunityGoal(
    input: ArchiveCommunityPointsCommunityGoalInput!
  ): ArchiveCommunityPointsCommunityGoalPayload
  archivePoll(input: ArchivePollInput!): ArchivePollPayload
  archivePollInChannel(
    input: ArchivePollInChannelInput!
  ): ArchivePollInChannelPayload
  assignEmoteToBitsTier(
    input: AssignEmoteToBitsTierInput!
  ): AssignEmoteToBitsTierPayload
  assignEmoteToSubscriptionProduct(
    input: AssignEmoteToSubscriptionProductInput!
  ): AssignEmoteToSubscriptionProductPayload
  assignExtensionBillingManager(
    input: AssignExtensionBillingManagerInput!
  ): AssignExtensionBillingManagerPayload
  banUserFromChatRoom(
    input: BanUserFromChatRoomInput!
  ): BanUserFromChatRoomPayload
  banVideoCommenter(input: BanVideoCommenterInput!): BanVideoCommenterPayload
  beginUseBitsInExtension(
    input: BeginUseBitsInExtensionInput!
  ): BeginUseBitsInExtensionPayload
  blockUser(input: BlockUserInput!): BlockUserPayload
  bulkApproveUnbanRequest(
    input: BulkApproveUnbanRequestInput!
  ): BulkApproveUnbanRequestPayload
  bulkDenyUnbanRequest(
    input: BulkDenyUnbanRequestInput!
  ): BulkDenyUnbanRequestPayload
  cancelActiveBoostOrders(
    input: CancelActiveBoostOrdersInput!
  ): CancelActiveBoostOrdersPayload
  cancelBounty(input: CancelBountyInput!): CancelBountyPayload
  cancelFriendRequest(
    input: CancelFriendRequestInput!
  ): CancelFriendRequestPayload
  cancelPayoutOnboardingWorkflow(
    input: CancelPayoutOnboardingWorkflowInput!
  ): CancelPayoutOnboardingWorkflowPayload
  cancelPredictionEvent(
    input: CancelPredictionEventInput!
  ): CancelPredictionEventPayload
  cancelRaid(input: CancelRaidInput!): CancelRaidPayload
  cancelSubscriptionGift(
    input: CancelSubscriptionGiftInput!
  ): CancelSubscriptionGiftPayload
  cancelUnbanRequest(input: CancelUnbanRequestInput!): CancelUnbanRequestPayload
  changeUsername(input: ChangeUsernameInput!): ChangeUsernamePayload
  claimBounty(input: ClaimBountyInput!): ClaimBountyPayload
  claimCommunityPoints(
    input: ClaimCommunityPointsInput!
  ): ClaimCommunityPointsPayload
  claimDropRewards(input: ClaimDropRewardsInput!): ClaimDropRewardsPayload
  claimPrimeOffer(input: ClaimPrimeOfferInput!): ClaimPrimeOfferPayload
  clearUnreadFriendRequests: ClearUnreadFriendRequestsPayload
  cloneExtensionDiscoveryData(
    input: CloneExtensionDiscoveryDataInput!
  ): CloneExtensionDiscoveryDataPayload
  cloneExtensionManifest(
    input: CloneExtensionManifestInput!
  ): CloneExtensionManifestPayload
  connectAdIdentity(input: ConnectAdIdentityInput!): ConnectAdIdentityPayload
  contributeCommunityPointsCommunityGoal(
    input: ContributeCommunityPointsCommunityGoalInput!
  ): ContributeCommunityPointsCommunityGoalPayload
  contributeToChallenge(
    input: ContributeToChallengeInput!
  ): ContributeToChallengePayload
  createArchivedEmote(
    input: CreateArchivedEmoteInput!
  ): CreateArchivedEmotePayload
  createBadgeFlair(input: CreateBadgeFlairInput!): CreateBadgeFlairPayload
  createBitsChallengeConditionForExtension(
    input: CreateBitsChallengeConditionForExtensionInput!
  ): CreateBitsChallengeConditionForExtensionPayload @deprecated
  createBitsChallengeConditionParticipantForExtension(
    input: CreateBitsChallengeConditionParticipantForExtensionInput!
  ): CreateBitsChallengeConditionParticipantForExtensionPayload @deprecated
  createBountyCampaign(
    input: CreateBountyCampaignInput!
  ): CreateBountyCampaignPayload
  createBountyCampaignUploadConfig(
    input: CreateBountyCampaignUploadConfigInput!
  ): CreateBountyCampaignUploadConfigPayload
  createCelebration(input: CreateCelebrationInput!): CreateCelebrationPayload
  createChanlet(input: CreateChanletInput!): CreateChanletPayload
  createClip(input: CreateClipInput!): CreateClipPayload
  createCollection(input: CreateCollectionInput!): CreateCollectionPayload
  createCommunityPointsCommunityGoal(
    input: CreateCommunityPointsCommunityGoalInput!
  ): CreateCommunityPointsCommunityGoalPayload
  createCommunityPointsCustomReward(
    input: CreateCommunityPointsCustomRewardInput!
  ): CreateCommunityPointsCustomRewardPayload
  createCommunityPointsImageUploadInfo(
    input: CreateCommunityPointsImageUploadInfoInput!
  ): CreateCommunityPointsImageUploadInfoPayload
  createCompetition(input: CreateCompetitionInput!): CreateCompetitionPayload
  createContentTags(input: CreateContentTagsInput!): CreateContentTagsPayload
  createCrowdChant(input: CreateCrowdChantInput!): CreateCrowdChantPayload
  createDropBenefit(input: CreateDropBenefitInput!): CreateDropBenefitPayload
  createDropCampaign(input: CreateDropCampaignInput!): CreateDropCampaignPayload
  createDropImageUploadURL(
    input: CreateDropImageUploadURLInput!
  ): CreateDropImageUploadURLPayload @deprecated(reason: "use dropImageUpload")
  createExtensionClient(
    input: CreateExtensionClientInput!
  ): CreateExtensionClientPayload
  createExtensionImageUploadInfo(
    input: CreateExtensionImageUploadInfoInput!
  ): CreateExtensionImageUploadInfoPayload
  createExtensionZipUploadInfo(
    input: CreateExtensionZipUploadInfoInput!
  ): CreateExtensionZipUploadInfoPayload
  createFriendRequest(
    input: CreateFriendRequestInput!
  ): CreateFriendRequestPayload
  createFollowerEmote(
    input: CreateFollowerEmoteInput!
  ): CreateFollowerEmotePayload
  createGameApplication(
    input: CreateGameApplicationInput!
  ): CreateGameApplicationPayload
  createGameBoxArtUploadURL(
    input: CreateGameBoxArtUploadURLInput!
  ): CreateGameBoxArtUploadURLPayload
  createLoyaltyBadge(input: CreateLoyaltyBadgeInput!): CreateLoyaltyBadgePayload
  createLoyaltyBadgeUploadConfig(
    input: CreateLoyaltyBadgeUploadConfigInput!
  ): CreateLoyaltyBadgeUploadConfigPayload
  createModeratorComment(
    input: CreateModeratorCommentInput!
  ): CreateModeratorCommentPayload
  createDashboardViewMosaicLayout(
    input: CreateDashboardViewMosaicLayoutInput!
  ): CreateDashboardViewMosaicLayoutPayload
  createMultiVideoHighlight(
    input: CreateMultiVideoHighlightInput!
  ): CreateMultiVideoHighlightPayload
  createMultiviewContentAttributeImageUploadConfig(
    input: CreateMultiviewContentAttributeImageUploadConfigInput!
  ): CreateMultiviewContentAttributeImageUploadConfigPayload
  createMultiviewContentAttributes(
    input: CreateMultiviewContentAttributesInput!
  ): CreateMultiviewContentAttributesPayload
  createOrganizationApplication(
    input: CreateOrganizationApplicationInput!
  ): CreateOrganizationApplicationPayload
  createOrganizationInvite(
    input: CreateOrganizationInviteInput!
  ): CreateOrganizationInvitePayload
  createOrganizationJWT(
    input: CreateOrganizationJWTInput!
  ): CreateOrganizationJWTPayload
  createOrganizationMember(
    input: CreateOrganizationMemberInput!
  ): CreateOrganizationMemberPayload
  createPanel(input: CreatePanelInput!): CreatePanelPayload
  createPanelImageUploadInfo(
    input: CreatePanelImageUploadInfoInput!
  ): CreatePanelImageUploadInfoPayload
  createPartnershipApplication(
    input: CreatePartnershipApplicationInput!
  ): CreatePartnershipApplicationPayload
  createPoll(input: CreatePollInput!): CreatePollPayload
  createPost(input: CreatePostInput!): CreatePostPayload @deprecated
  createPredictionEvent(
    input: CreatePredictionEventInput!
  ): CreatePredictionEventPayload
  createRaid(input: CreateRaidInput!): CreateRaidPayload
  createRewardedVideoToken(
    input: CreateRewardedVideoTokenInput!
  ): CreateRewardedVideoTokenPayload
  createRoom(input: CreateRoomInput!): CreateRoomPayload @deprecated
  createSchedule(input: CreateScheduleInput!): CreateSchedulePayload
  createScheduleSegment(
    input: CreateScheduleSegmentInput!
  ): CreateScheduleSegmentPayload
  createSocialMedia(input: CreateSocialMediaInput!): CreateSocialMediaPayload
  createSquadStreamInvitation(
    input: CreateSquadStreamInvitationInput!
  ): CreateSquadStreamInvitationPayload
  createStucco(input: CreateStuccoInput!): CreateStuccoPayload
  createStuccoPack(input: CreateStuccoPackInput!): CreateStuccoPackPayload
  createUnbanRequest(input: CreateUnbanRequestInput!): CreateUnbanRequestPayload
  createVideoAppeal(input: CreateVideoAppealInput!): CreateVideoAppealPayload
  createVideoBookmark(
    input: CreateVideoBookmarkInput!
  ): CreateVideoBookmarkPayload
  createVideoComment(input: CreateVideoCommentInput!): CreateVideoCommentPayload
  createVideoHighlight(
    input: CreateVideoHighlightInput!
  ): CreateVideoHighlightPayload
  createVideoThumbnailUploadRequest(
    input: CreateVideoThumbnailUploadRequestInput!
  ): CreateVideoThumbnailUploadRequestPayload
  deactivateExtension(
    input: DeactivateExtensionInput!
  ): DeactivateExtensionPayload
    @deprecated(reason: "Should use applyExtensionActivations instead")
  declineOrganizationInvite(
    input: DeclineOrganizationInviteInput!
  ): DeclineOrganizationInvitePayload
  deleteAllChannelVideos(
    input: DeleteAllChannelVideosInput
  ): DeleteAllChannelVideosPayload
  deleteBitsBadgeTierEmoticon(
    input: DeleteBitsBadgeTierEmoticonInput!
  ): DeleteBitsBadgeTierEmoticonPayload
  deleteCelebration(input: DeleteCelebrationInput!): DeleteCelebrationPayload
  deleteChannelBlockedTermByID(
    input: DeleteChannelBlockedTermByIDInput!
  ): DeleteChannelBlockedTermByIDPayload
  deleteChannelClips(input: DeleteChannelClipsInput!): DeleteChannelClipsPayload
  deleteChannelPermittedTermByID(
    input: DeleteChannelPermittedTermByIDInput!
  ): DeleteChannelPermittedTermByIDPayload
  deleteChatMessage(input: DeleteChatMessageInput!): DeleteChatMessagePayload
  deleteCheermoteTier(
    input: DeleteCheermoteTierInput!
  ): DeleteCheermoteTierPayload
  deleteClips(input: DeleteClipsInput!): DeleteClipsPayload
  deleteCollection(input: DeleteCollectionInput!): DeleteCollectionPayload
  deleteCommunityPointsCommunityGoal(
    input: DeleteCommunityPointsCommunityGoalInput!
  ): DeleteCommunityPointsCommunityGoalPayload
  deleteCommunityPointsCustomReward(
    input: DeleteCommunityPointsCustomRewardInput
  ): DeleteCommunityPointsCustomRewardPayload
  deleteCompetition(input: DeleteCompetitionInput!): DeleteCompetitionPayload
  deleteContentTags(input: DeleteContentTagsInput!): DeleteContentTagsPayload
  deleteDashboardView(
    input: DeleteDashboardViewInput!
  ): DeleteDashboardViewPayload
  deleteDefaultPaymentMethod(
    input: DeleteDefaultPaymentMethodInput!
  ): DeleteDefaultPaymentMethodPayload
  deleteDeviceToken(input: DeleteDeviceTokenInput!): DeleteDeviceTokenPayload
  deleteDrop(input: DeleteDropInput!): DeleteDropPayload
  deleteDropCampaign(input: DeleteDropCampaignInput!): DeleteDropCampaignPayload
  deleteEmote(input: DeleteEmoteInput!): DeleteEmotePayload
  deleteExtension(input: DeleteExtensionInput!): DeleteExtensionPayload
  deleteExtensionImage(
    input: DeleteExtensionImageInput!
  ): DeleteExtensionImagePayload
  deleteExtensionSecrets(
    input: DeleteExtensionSecretsInput!
  ): DeleteExtensionSecretsPayload
  deleteLoyaltyBadge(input: DeleteLoyaltyBadgeInput!): DeleteLoyaltyBadgePayload
  deleteModeratorComment(
    input: DeleteModeratorCommentInput!
  ): DeleteModeratorCommentPayload
  deleteMultiviewContentAttributes(
    input: DeleteMultiviewContentAttributesInput!
  ): DeleteMultiviewContentAttributesPayload
  deleteNotification(input: DeleteNotificationInput!): DeleteNotificationPayload
  deletePanel(input: DeletePanelInput!): DeletePanelPayload
  deletePost(input: DeletePostInput!): DeletePostPayload @deprecated
  deleteRecommendationFeedback(
    input: DeleteRecommendationFeedbackInput!
  ): DeleteRecommendationFeedbackPayload
  deleteRoom(input: DeleteRoomInput!): DeleteRoomPayload @deprecated
  deleteRoomMessage(input: DeleteRoomMessageInput!): DeleteRoomMessagePayload
  deleteSchedule(input: DeleteScheduleInput!): DeleteSchedulePayload
  deleteScheduleSegment(
    input: DeleteScheduleSegmentInput!
  ): DeleteScheduleSegmentPayload
  deleteSocialMedia(input: DeleteSocialMediaInput!): DeleteSocialMediaPayload
  deleteSquadStreamInvitation(
    input: DeleteSquadStreamInvitationInput!
  ): DeleteSquadStreamInvitationPayload
  deleteStreamAuthorizedUser(
    input: DeleteStreamAuthorizedUserInput!
  ): DeleteStreamAuthorizedUserPayload
  deleteUserClips(input: DeleteUserClipsInput!): DeleteUserClipsPayload
  deleteUserColors(input: DeleteUserColorsInput!): DeleteUserColorsPayload
  deleteVideoComment(commentID: ID!): DeleteVideoCommentPayload
  deleteVideos(input: DeleteVideosInput!): DeleteVideosPayload
  deleteVideoThumbnail(
    input: DeleteVideoThumbnailInput!
  ): DeleteVideoThumbnailPayload
  denyRejectedChatMessage(
    input: DenyRejectedChatMessageInput!
  ): DenyRejectedChatMessagePayload
  denyRejectedCheer(input: DenyRejectedCheerInput!): DenyRejectedCheerPayload
    @deprecated(reason: "logic handled by denyRejectedChatMessage")
  denyUnbanRequest(input: DenyUnbanRequestInput!): DenyUnbanRequestPayload
  deselectChannelBadge(
    input: DeselectChannelBadgeInput!
  ): DeselectChannelBadgePayload
  deselectGlobalBadge: DeselectGlobalBadgePayload
  disableTwoFactor(input: DisableTwoFactorInput!): DisableTwoFactorPayload
  disableUserAccount(input: DisableUserAccountInput!): DisableUserAccountPayload
  dismissFriendRecommendation(
    input: DismissFriendRecommendationInput!
  ): DismissFriendRecommendationPayload
  dismissRitualToken(input: DismissRitualTokenInput!): DismissRitualTokenPayload
  dismissVideoSuggestedHighlight(
    input: DismissVideoSuggestedHighlightInput!
  ): DismissVideoSuggestedHighlightPayload
  dropImageUpload(input: DropImageUploadInput!): DropImageUploadPayload
  editRoomMessage(input: EditRoomMessageInput!): EditRoomMessagePayload
    @deprecated
  emitCampaignDiscoveryEvent(
    input: EmitCampaignDiscoveryEventInput!
  ): EmitCampaignDiscoveryEventPayload @deprecated
  endUseBitsInExtension(
    input: EndUseBitsInExtensionInput!
  ): EndUseBitsInExtensionPayload
  equipHeroAssets(input: EquipHeroAssetsInput!): EquipHeroAssetsPayload
  exportVideoToYoutube(
    input: ExportVideoToYoutubeInput!
  ): ExportVideoToYoutubePayload
  extensionLinkUser(input: ExtensionLinkUserInput!): ExtensionLinkUserPayload
  finalizeCompetitionLobby(
    input: FinalizeCompetitionLobbyInput!
  ): FinalizeCompetitionLobbyPayload
  followGame(input: FollowGameInput!): FollowGamePayload
  followUser(input: FollowUserInput!): FollowUserPayload
  generateAnimatedEmote(
    input: GenerateAnimatedEmoteInput!
  ): GenerateAnimatedEmotePayload
  generateExtensionRatingsCSVReport(
    input: GenerateExtensionRatingsCSVReportInput!
  ): GenerateExtensionRatingsCSVReportPayload
  generateSecondFactorQRCode(
    input: GenerateSecondFactorQRCodeInput!
  ): GenerateSecondFactorQRCodePayload
  generateSubscribersCSV(
    input: GenerateSubscribersCSVInput!
  ): GenerateSubscribersCSVPayload
  getEmoteUploadConfig(
    input: GetEmoteUploadConfigInput!
  ): GetEmoteUploadConfigPayload
  goRaid(input: GoRaidInput!): GoRaidPayload
  grantVIP(input: GrantVIPInput!): GrantVIPPayload
  hostTargetChannel(input: HostTargetChannelInput!): HostTargetChannelPayload
  installExtension(input: InstallExtensionInput!): InstallExtensionPayload
  interruptSchedule(input: InterruptScheduleInput!): InterruptSchedulePayload
  invalidateAuthenticatedSessions(
    input: InvalidateAuthenticatedSessionsInput!
  ): InvalidateAuthenticatedSessionsPayload
  invalidateEmailAssociation(
    input: InvalidateEmailAssociationInput!
  ): InvalidateEmailAssociationPayload
  joinChannelRooms(input: JoinChannelRoomsInput!): JoinChannelRoomsPayload
    @deprecated
  joinRaid(input: JoinRaidInput!): JoinRaidPayload
  leaveChannelRooms(input: LeaveChannelRoomsInput!): LeaveChannelRoomsPayload
    @deprecated
  leaveRaid(input: LeaveRaidInput!): LeaveRaidPayload
  leaveSquadStream(input: LeaveSquadStreamInput!): LeaveSquadStreamPayload
  linkSSO(input: LinkSSOInput!): LinkSSOPayload
    @deprecated(reason: "Service has been shutdown")
  lockPredictionEvent(
    input: LockPredictionEventInput!
  ): LockPredictionEventPayload
  makeKeyBatchDownloadURL(
    input: MakeKeyBatchDownloadURLInput!
  ): MakeKeyBatchDownloadURLPayload
  makePrediction(input: MakePredictionInput!): MakePredictionPayload
  manuallyTriggerDrop(
    input: ManuallyTriggerDropInput!
  ): ManuallyTriggerDropPayload
  markAllCreatorNotificationsAsRead(
    input: MarkAllCreatorNotificationsAsReadInput!
  ): MarkAllCreatorNotificationsAsReadPayload
  markAllViewerNotificationsAsRead(
    input: MarkAllViewerNotificationsAsReadInput
  ): MarkAllViewerNotificationsAsReadPayload
  modUser(input: ModUserInput!): ModUserPayload
  orderPanels(input: OrderPanelsInput!): OrderPanelsPayload
  presignDevInsightsReportURL(
    input: PresignDevInsightsReportURLInput!
  ): PresignDevInsightsReportURLPayload
  processAndroidPayment(
    input: ProcessAndroidPaymentInput!
  ): ProcessAndroidPaymentPayload
  processIOSPayment(input: ProcessIOSPaymentInput!): ProcessIOSPaymentPayload
  publishClip(input: PublishClipInput!): PublishClipPayload
  publishCompetition(input: PublishCompetitionInput!): PublishCompetitionPayload
  publishSubscriptionEmote(
    input: PublishSubscriptionEmoteInput!
  ): PublishSubscriptionEmotePayload
  purchaseOffer(input: PurchaseOfferInput!): PurchaseOfferPayload
  rateExtension(input: RateExtensionInput!): RateExtensionPayload
  readNotifications(input: ReadNotificationsInput!): ReadNotificationsPayload
  recordAdEvent(input: RecordAdEventInput!): RecordAdEventPayload
  redeemClaimable(input: RedeemClaimableInput!): RedeemClaimablePayload
  redeemCommunityPointsCustomReward(
    input: RedeemCommunityPointsCustomRewardInput!
  ): RedeemCommunityPointsCustomRewardPayload
  redeemCreatorGifts(input: RedeemCreatorGiftsInput!): RedeemCreatorGiftsPayload
  redeemRitualToken(input: RedeemRitualTokenInput!): RedeemRitualTokenPayload
  redeemSubscription(input: RedeemSubscriptionInput!): RedeemSubscriptionPayload
  redeemTrueXAd(input: RedeemTrueXAdInput!): RedeemTrueXAdPayload
  refreshExtensionToken(
    input: RefreshExtensionTokenInput!
  ): RefreshExtensionTokenPayload
  regenerateStreamKey(
    input: RegenerateStreamKeyInput!
  ): RegenerateStreamKeyPayload
  regenerateVerificationCode(
    input: RegenerateVerificationCodeInput!
  ): RegenerateVerificationCodePayload
  registerPayoutInformation(
    input: RegisterPayoutInformationInput!
  ): RegisterPayoutInformationPayload
  registerTwoFactor(input: RegisterTwoFactorInput!): RegisterTwoFactorPayload
  registerTwoFactorConfirmation(
    input: RegisterTwoFactorConfirmationInput!
  ): RegisterTwoFactorConfirmationPayload
  rejectFriendRequest(
    input: RejectFriendRequestInput!
  ): RejectFriendRequestPayload
  rejectSquadStreamInvitation(
    input: RejectSquadStreamInvitationInput!
  ): RejectSquadStreamInvitationPayload
  rejectSquadStreamOutOfNetworkInvitations(
    input: RejectSquadStreamOutOfNetworkInvitationsInput!
  ): RejectSquadStreamOutOfNetworkInvitationsPayload
  removeAutohostChannels(
    input: RemoveAutohostChannelsInput!
  ): RemoveAutohostChannelsPayload
  removeCollectionItem(
    input: RemoveCollectionItemInput!
  ): RemoveCollectionItemPayload
  removeCompetitionPhase(
    input: RemoveCompetitionPhaseInput!
  ): RemoveCompetitionPhasePayload
  removeCompetitionPlayer(
    input: RemoveCompetitionPlayerInput!
  ): RemoveCompetitionPlayerPayload
  removeCompetitionTeam(
    input: RemoveCompetitionTeamInput!
  ): RemoveCompetitionTeamPayload
  removeEditor(input: RemoveEditorInput!): RemoveEditorPayload
  removeEmoteFromGroup(
    input: RemoveEmoteFromGroupInput!
  ): RemoveEmoteFromGroupPayload
  removeOrganizationMember(
    input: RemoveOrganizationMemberInput!
  ): RemoveOrganizationMemberPayload
  removeReaction(input: RemoveReactionInput!): RemoveReactionPayload @deprecated
  removeSquadStreamMember(
    input: RemoveSquadStreamMemberInput!
  ): RemoveSquadStreamMemberPayload
  removeStucco(input: RemoveStuccoInput!): RemoveStuccoPayload
  reorderCollectionItem(
    input: ReorderCollectionItemInput!
  ): ReorderCollectionItemPayload
  reportContent(input: ReportContentInput!): ReportContentPayload
  reportWhisper(input: ReportWhisperInput!): ReportWhisperPayload
  reportWhisperThread(
    input: ReportWhisperThreadInput!
  ): ReportWhisperThreadPayload @deprecated(reason: "Use reportWhisper")
  requestRitualToken(input: RequestRitualTokenInput!): RequestRitualTokenPayload
  resendVerificationEmail(
    input: ResendVerificationEmailInput!
  ): ResendVerificationEmailPayload
  resetUsername(input: ResetUsernameInput!): ResetUsernamePayload
  resolvePredictionEvent(
    input: ResolvePredictionEventInput!
  ): ResolvePredictionEventPayload
  respondToTeamInvitation(
    input: RespondToTeamInvitationInput!
  ): RespondToTeamInvitationPayload
  resumeSchedule(input: ResumeScheduleInput!): ResumeSchedulePayload
  revokeVIP(input: RevokeVIPInput!): RevokeVIPPayload
  rotateExtensionSecrets(
    input: RotateExtensionSecretsInput!
  ): RotateExtensionSecretsPayload
  runMultiplayerAds(input: RunMultiplayerAdsInput!): RunMultiplayerAdsPayload
  saveExtensionManifest(
    input: SaveExtensionManifestInput!
  ): SaveExtensionManifestPayload
  seedCompetitionParticipant(
    input: SeedCompetitionParticipantInput!
  ): SeedCompetitionParticipantPayload
  selectChannelBadge(input: SelectChannelBadgeInput!): SelectChannelBadgePayload
  selectGlobalBadge(input: SelectGlobalBadgeInput!): SelectGlobalBadgePayload
  sendChatMessageThroughSubscriberMode(
    input: SendChatMessageThroughSubscriberModeInput!
  ): SendChatMessageThroughSubscriberModePayload
  sendCheer(input: SendCheerInput!): SendCheerPayload
  sendExtensionMessage(
    input: SendExtensionMessageInput!
  ): SendExtensionMessagePayload
  sendHighlightedChatMessage(
    input: SendHighlightedChatMessageInput!
  ): SendHighlightedChatMessagePayload
  sendRoomMessage(input: SendRoomMessageInput!): SendRoomMessagePayload
    @deprecated
  sendWhisper(input: SendWhisperInput!): SendWhisperPayload
  setAutoAdDensity(input: SetAutoAdDensityInput!): SetAutoAdDensityPayload
  setAutoRefillSettings(
    input: SetAutoRefillSettingsInput!
  ): SetAutoRefillSettingsPayload
  setAutohostChannels(
    input: SetAutohostChannelsInput!
  ): SetAutohostChannelsPayload
  setBitsUserSettings(
    input: SetBitsUserSettingsInput!
  ): SetBitsUserSettingsPayload
  setChannelAdSchedule(
    input: SetChannelAdScheduleInput!
  ): SetChannelAdSchedulePayload
  setChannelFeedEnabled(
    input: SetChannelFeedEnabledInput!
  ): SetChannelFeedEnabledPayload @deprecated
  setChannelNotificationSetting(
    input: SetChannelNotificationSettingInput!
  ): SetChannelNotificationSettingPayload
  setChannelTrailer(input: SetChannelTrailerInput!): SetChannelTrailerPayload
  setChatPauseSetting(
    input: SetChatPauseSettingInput!
  ): SetChatPauseSettingPayload
  setContentTags(input: SetContentTagsInput!): SetContentTagsPayload
  setCreatorBadgeFlair(
    input: SetCreatorBadgeFlairInput!
  ): SetCreatorBadgeFlairPayload
  setDashboardAlertQueueActivityStatus(
    input: SetDashboardAlertQueueActivityStatusInput!
  ): SetDashboardAlertQueueActivityStatusPayload
  setDashboardAlertQueuePreference(
    input: SetDashboardAlertQueuePreferenceInput!
  ): SetDashboardAlertQueuePreferencePayload
  setDefaultPaymentMethod(
    input: SetDefaultPaymentMethodInput!
  ): SetDefaultPaymentMethodPayload
  setDeletedMessageDisplaySetting(
    input: SetDeletedMessageDisplaySettingInput!
  ): SetDeletedMessageDisplaySettingPayload
  setDropBenefitsOnDrop(
    input: SetDropBenefitsOnDropInput!
  ): SetDropBenefitsOnDropPayload
  setDropCampaignAccess(
    input: SetDropCampaignAccessInput!
  ): SetDropCampaignAccessPayload
  setDropCampaignStatus(
    input: SetDropCampaignStatusInput!
  ): SetDropCampaignStatusPayload
  setDropCampaignSummary(
    input: SetDropCampaignSummaryInput!
  ): SetDropCampaignSummaryPayload
  setDropEventRule(input: SetDropEventRuleInput!): SetDropEventRulePayload
  setDropSummary(input: SetDropSummaryInput!): SetDropSummaryPayload
  setDropTimeBasedRule(
    input: SetDropTimeBasedRuleInput!
  ): SetDropTimeBasedRulePayload
  setEmoteAnimationsEnabled(
    input: SetEmoteAnimationsEnabledInput!
  ): SetEmoteAnimationsEnabledPayload
  setEmoteAnimationsSettingCalloutDismissed(
    input: SetEmoteAnimationsSettingCalloutDismissedInput!
  ): SetEmoteAnimationsSettingCalloutDismissedPayload
  setEmoteModifierGroups(
    input: SetEmoteModifierGroupsInput!
  ): SetEmoteModifierGroupsPayload
  setExtensionConfiguration(
    input: SetExtensionConfigurationInput!
  ): SetExtensionConfigurationPayload
  setExtensionFeatureFlags(
    input: SetExtensionFeatureFlagsInput!
  ): SetExtensionFeatureFlagsPayload
  setExtensionInstallationOAuth(
    input: SetExtensionInstallationOAuthInput!
  ): SetExtensionInstallationOAuthPayload
  setGameDropAccountLinkClient(
    input: SetGameDropAccountLinkClientInput!
  ): SetGameDropAccountLinkClientPayload
  setHeroAsAvatar(input: SetHeroAsAvatarInput!): SetHeroAsAvatarPayload
  setModLogsAccess(input: SetModLogsAccessInput!): SetModLogsAccessPayload
  setModViewSettings(input: SetModViewSettingsInput!): SetModViewSettingsPayload
  setNotificationSetting(
    input: SetNotificationSettingInput!
  ): SetNotificationSettingPayload
  setOverwatchLeagueTeamPreference(
    input: SetOverwatchLeagueTeamPreferenceInput!
  ): SetOverwatchLeagueTeamPreferencePayload
  setPreferredLanguageTag(
    input: SetPreferredLanguageTagInput!
  ): SetPreferredLanguageTagPayload
  setRadioCurrentlyPlaying(
    input: SetRadioCurrentlyPlayingInput!
  ): SetRadioCurrentlyPlayingPayload
  setReadableChatColorsEnabled(
    input: SetReadableChatColorsEnabledInput!
  ): SetReadableChatColorsEnabledPayload
  setResourceRestriction(
    input: SetResourceRestrictionInput!
  ): SetResourceRestrictionPayload
  setScheduleReminder(
    input: SetScheduleReminderInput!
  ): SetScheduleReminderPayload
  setSessionStatus(input: SetSessionStatusInput!): SetSessionStatusPayload
  setSquadStreamPrimaryPlayer(
    input: SetSquadStreamPrimaryPlayerInput!
  ): SetSquadStreamPrimaryPlayerPayload
  setUnbanRequestsSettings(
    input: SetUnbanRequestsSettingsInput!
  ): SetUnbanRequestsSettingsPayload
  setUserResidence(input: SetUserResidenceInput!): SetUserResidencePayload
  snoozeAd(input: SnoozeAdInput!): SnoozeAdPayload
  spendSubscriptionCredit(
    input: SpendSubscriptionCreditInput!
  ): SpendSubscriptionCreditPayload
  startAd(input: StartAdInput!): StartAdPayload
  startBounty(input: StartBountyInput!): StartBountyPayload
  startCloudBroadcast(
    input: StartCloudBroadcastInput!
  ): StartCloudBroadcastPayload
  startPayoutOnboardingWorkflow(
    input: StartPayoutOnboardingWorkflowInput!
  ): StartPayoutOnboardingWorkflowPayload
  startWatchParty(input: StartWatchPartyInput!): StartWatchPartyPayload
  stopBounty(input: StopBountyInput!): StopBountyPayload
  stopCloudBroadcast(input: StopCloudBroadcastInput!): StopCloudBroadcastPayload
  stopWatchParty(input: StopWatchPartyInput!): StopWatchPartyPayload
  submitCopyrightClaim(
    input: SubmitCopyrightClaimInput!
  ): SubmitCopyrightClaimPayload
  submitCSATFeedback(input: SubmitCSATFeedbackInput!): SubmitCSATFeedbackPayload
  submitEmotePrefix(input: SubmitEmotePrefixInput!): SubmitEmotePrefixPayload
  submitEmoticonPrefix(
    input: SubmitEmoticonPrefixInput!
  ): SubmitEmoticonPrefixPayload
    @deprecated(reason: "Use 'submitEmotePrefix' instead")
  submitExtensionFeedback(
    input: SubmitExtensionFeedbackInput!
  ): SubmitExtensionFeedbackPayload
  swapCompetitionLobbyParticipants(
    input: SwapCompetitionLobbyParticipantsInput!
  ): SwapCompetitionLobbyParticipantsPayload
  syncGameOnDropCampaign(
    input: SyncGameOnDropCampaignInput!
  ): SyncGameOnDropCampaignPayload
  terminatePoll(input: TerminatePollInput!): TerminatePollPayload
  terminatePollInChannel(
    input: TerminatePollInChannelInput!
  ): TerminatePollInChannelPayload
  toggleRitualsEnabled(
    input: ToggleRitualsEnabledInput!
  ): ToggleRitualsEnabledPayload
  transitionExtensionState(
    input: TransitionExtensionStateInput!
  ): TransitionExtensionStatePayload
  unbanUserFromChatRoom(
    input: UnbanUserFromChatRoomInput!
  ): UnbanUserFromChatRoomPayload
  unblockUser(input: UnblockUserInput!): UnblockUserPayload
  undoRecommendationFeedback(
    input: UndoRecommendationFeedbackInput!
  ): UndoRecommendationFeedbackPayload
  unfollowGame(input: UnfollowGameInput!): UnfollowGamePayload
  unfollowUser(input: UnfollowUserInput!): UnfollowUserPayload
  unfriendUser(input: UnfriendUserInput!): UnfriendUserPayload
  unhost(input: UnhostInput!): UnhostPayload
  uninstallExtension(input: UninstallExtensionInput!): UninstallExtensionPayload
  unlinkAmazonConnection(
    input: UnlinkAmazonConnectionInput!
  ): UnlinkAmazonConnectionPayload
  unlinkRiotConnection(
    input: UnlinkRiotConnectionInput!
  ): UnlinkRiotConnectionPayload
  unlinkSSO(input: UnlinkSSOInput!): UnlinkSSOPayload
    @deprecated(reason: "Service has been shutdown")
  unlockChosenModifiedSubscriberEmote(
    input: UnlockChosenModifiedSubscriberEmoteInput!
  ): UnlockChosenModifiedSubscriberEmotePayload
  unlockChosenSubscriberEmote(
    input: UnlockChosenSubscriberEmoteInput!
  ): UnlockChosenSubscriberEmotePayload
  unlockRandomSubscriberEmote(
    input: UnlockRandomSubscriberEmoteInput!
  ): UnlockRandomSubscriberEmotePayload
  unmodUser(input: UnmodUserInput!): UnmodUserPayload
  unsetHypeTrainConfig(
    input: UnsetHypeTrainConfigInput!
  ): UnsetHypeTrainConfigPayload
  unsubscribeEmail(input: UnsubscribeEmailInput!): UnsubscribeEmailPayload
  updateAdProperties(input: UpdateAdPropertiesInput!): UpdateAdPropertiesPayload
  updateAllChannelVideosViewability(
    input: UpdateAllChannelVideosViewabilityInput!
  ): UpdateAllChannelVideosViewabilityPayload
  updateAllWhisperThreads(
    input: UpdateAllWhisperThreadsInput!
  ): UpdateAllWhisperThreadsPayload
  updateAutoModLevels(
    input: UpdateAutoModLevelsInput!
  ): UpdateAutoModLevelsPayload
  updateAutoModProperties(
    input: UpdateAutoModPropertiesInput!
  ): UpdateAutoModPropertiesPayload
  updateAutohostSettings(
    input: UpdateAutohostSettingsInput!
  ): UpdateAutohostSettingsPayload
  updateBitsBadgeTierNotification(
    input: UpdateBitsBadgeTierNotificationInput!
  ): UpdateBitsBadgeTierNotificationPayload
  updateBitsBadgeTiers(
    input: UpdateBitsBadgeTiersInput!
  ): UpdateBitsBadgeTiersPayload
  updateBoostSettings(
    input: UpdateBoostSettingsInput!
  ): UpdateBoostSettingsPayload
  updateBroadcastSettings(
    input: UpdateBroadcastSettingsInput!
  ): UpdateBroadcastSettingsPayload
  updateCelebration(input: UpdateCelebrationInput!): UpdateCelebrationPayload
  updateCelebrationConfig(
    input: UpdateCelebrationConfigInput!
  ): UpdateCelebrationConfigPayload
  updateCelebrationProductConfig(
    input: UpdateCelebrationProductConfigInput!
  ): UpdateCelebrationProductConfigPayload
  updateCelebrationUserSettings(
    input: UpdateCelebrationUserSettingsInput!
  ): UpdateCelebrationUserSettingsPayload
  updateChangelogReadTime: UpdateChangelogReadTimePayload
  updateChanletContentAttributes(
    input: UpdateChanletContentAttributesInput!
  ): UpdateChanletContentAttributesPayload
  updateChannelClipsSetting(
    input: UpdateChannelClipsSettingInput!
  ): UpdateChannelClipsSettingPayload
  updateChannelHomePreferences(
    input: UpdateChannelHomePreferencesInput!
  ): UpdateChannelHomePreferencesPayload
  updateChannelPredictionSettings(
    input: UpdateChannelPredictionSettingsInput!
  ): UpdateChannelPredictionSettingsPayload
  updateChatColor(input: UpdateChatColorInput!): UpdateChatColorPayload
  updateChatSettings(input: UpdateChatSettingsInput!): UpdateChatSettingsPayload
  updateCheerPartnerSettings(
    input: UpdateCheerPartnerSettingsInput!
  ): UpdateCheerPartnerSettingsPayload
  updateCheermoteTier(
    input: UpdateCheermoteTierInput!
  ): UpdateCheermoteTierPayload
  updateClip(input: UpdateClipInput!): UpdateClipPayload
  updateClipViewCount(
    input: UpdateClipViewCountInput!
  ): UpdateClipViewCountPayload
    @deprecated(
      reason: "Will eventually be replaced by different viewcounting method"
    )
  updateCollection(input: UpdateCollectionInput!): UpdateCollectionPayload
  updateCommunityPointsAutomaticReward(
    input: UpdateCommunityPointsAutomaticRewardInput!
  ): UpdateCommunityPointsAutomaticRewardPayload
  updateCommunityPointsChannelSettings(
    input: UpdateCommunityPointsChannelSettingsInput!
  ): UpdateCommunityPointsChannelSettingsPayload
  updateCommunityPointsCommunityGoal(
    input: UpdateCommunityPointsCommunityGoalInput!
  ): UpdateCommunityPointsCommunityGoalPayload
  updateCommunityPointsCustomReward(
    input: UpdateCommunityPointsCustomRewardInput!
  ): UpdateCommunityPointsCustomRewardPayload
  updateCommunityPointsCustomRewardRedemptionStatus(
    input: UpdateCommunityPointsCustomRewardRedemptionStatusInput!
  ): UpdateCommunityPointsCustomRewardRedemptionStatusPayload
  updateCommunityPointsCustomRewardRedemptionStatusesByChannel(
    input: UpdateCommunityPointsCustomRewardRedemptionStatusesByChannelInput!
  ): UpdateCommunityPointsCustomRewardRedemptionStatusesByChannelPayload
  updateCommunityPointsCustomRewardRedemptionStatusesByRedemptions(
    input: UpdateCommunityPointsCustomRewardRedemptionStatusesByRedemptionsInput!
  ): UpdateCommunityPointsCustomRewardRedemptionStatusesByRedemptionsPayload
  updateCommunityPointsCustomRewardRedemptionStatusesByReward(
    input: UpdateCommunityPointsCustomRewardRedemptionStatusesByRewardInput!
  ): UpdateCommunityPointsCustomRewardRedemptionStatusesByRewardPayload
  updateCommunityPointsEarlyAccessSettings(
    input: UpdateCommunityPointsEarlyAccessSettingsInput!
  ): UpdateCommunityPointsEarlyAccessSettingsPayload
    @deprecated(reason: "Early access period is over.")
  updateCommunityPointsLastViewedContent(
    input: UpdateCommunityPointsLastViewedContentInput!
  ): UpdateCommunityPointsLastViewedContentPayload
  updateCommunityPointsSmartCostsAcknowledgements(
    input: UpdateCommunityPointsSmartCostsAcknowledgementsInput!
  ): UpdateCommunityPointsSmartCostsAcknowledgementsPayload
  updateCompetition(input: UpdateCompetitionInput!): UpdateCompetitionPayload
  updateCompetitionPlayer(
    input: UpdateCompetitionPlayerInput!
  ): UpdateCompetitionPlayerPayload
  updateCompetitionTeam(
    input: UpdateCompetitionTeamInput!
  ): UpdateCompetitionTeamPayload
  updateConsent(input: UpdateConsentInput!): UpdateConsentPayload
  updateContentTags(input: UpdateContentTagsInput!): UpdateContentTagsPayload
    @deprecated(reason: "Use setContentTags instead")
  updateDropBenefit(input: UpdateDropBenefitInput!): UpdateDropBenefitPayload
  updateDropBenefitOnDrop(
    input: UpdateDropBenefitOnDropInput!
  ): UpdateDropBenefitOnDropPayload
  updateDropPreconditions(
    input: UpdateDropPreconditionsInput!
  ): UpdateDropPreconditionsPayload
  updateDropsOptOutStatus(
    input: UpdateDropsOptOutStatusInput!
  ): UpdateDropsOptOutStatusPayload
  updateEmoteOrders(input: UpdateEmoteOrdersInput!): UpdateEmoteOrdersPayload
  updateExtensionDiscoveryData(
    input: UpdateExtensionDiscoveryDataInput!
  ): UpdateExtensionDiscoveryDataPayload
  updateExtensionManifest(
    input: UpdateExtensionManifestInput!
  ): UpdateExtensionManifestPayload
    @deprecated(reason: "Switching to saveExtensionManifest")
  updateHypeTrainConfig(
    input: UpdateHypeTrainConfigInput!
  ): UpdateHypeTrainConfigPayload
  updateIsSharingActivity(
    input: UpdateIsSharingActivityInput!
  ): UpdateIsSharingActivityPayload
  updateLWAToken(input: UpdateLWATokenInput!): UpdateLWATokenPayload
  updateLeaderboardSettings(
    input: UpdateLeaderboardSettingsInput!
  ): UpdateLeaderboardSettingsPayload
  updateLiveUpNotification(
    input: UpdateLiveUpNotificationInput!
  ): UpdateLiveUpNotificationPayload
  updateLobbyParticipantScore(
    input: UpdateLobbyParticipantScoreInput!
  ): UpdateLobbyParticipantScorePayload
  updateDashboardViewMosaicLayout(
    input: UpdateDashboardViewMosaicLayoutInput!
  ): UpdateDashboardViewMosaicLayoutPayload
  updateMultiviewContentAttributes(
    input: UpdateMultiviewContentAttributesInput!
  ): UpdateMultiviewContentAttributesPayload
  updateOnboardingSkippedChannels(
    input: UpdateOnboardingSkippedChannelsInput!
  ): UpdateOnboardingSkippedChannelsPayload
    @deprecated(reason: "This feature is retired")
  updateOrganizationMemberRole(
    input: UpdateOrganizationMemberRoleInput!
  ): UpdateOrganizationMemberRolePayload
  updateOwnerChanletAttributes(
    input: UpdateOwnerChanletAttributesInput!
  ): UpdateOwnerChanletAttributesPayload
  updatePanel(input: UpdatePanelInput!): UpdatePanelPayload
  updatePhoneNumber(input: UpdatePhoneNumberInput!): UpdatePhoneNumberPayload
  updatePhoneNumberConfirmation(
    input: UpdatePhoneNumberConfirmationInput!
  ): UpdatePhoneNumberConfirmationPayload
  updatePrimeOfferStatus(
    input: UpdatePrimeOfferStatusInput!
  ): UpdatePrimeOfferStatusPayload
  updatePrimeSettings(
    input: UpdatePrimeSettingsInput!
  ): UpdatePrimeSettingsPayload
  updateRaidSettings(input: UpdateRaidSettingsInput!): UpdateRaidSettingsPayload
  updateRoom(input: UpdateRoomInput!): UpdateRoomPayload @deprecated
  updateRoomModes(input: UpdateRoomModesInput!): UpdateRoomModesPayload
    @deprecated
  updateRoomView(input: UpdateRoomViewInput!): UpdateRoomViewPayload @deprecated
  updateScheduleSegment(
    input: UpdateScheduleSegmentInput!
  ): UpdateScheduleSegmentPayload
  updateSeenCreatorOnboardingContent(
    input: UpdateSeenCreatorOnboardingContentInput!
  ): UpdateSeenCreatorOnboardingContentPayload
  updateSocialMedia(input: UpdateSocialMediaInput!): UpdateSocialMediaPayload
  updateSquadInvitePolicy(
    input: UpdateSquadInvitePolicyInput!
  ): UpdateSquadInvitePolicyPayload
  updateSquadStream(input: UpdateSquadStreamInput!): UpdateSquadStreamPayload
  updateStucco(input: UpdateStuccoInput!): UpdateStuccoPayload
  updateStuccoPack(input: UpdateStuccoPackInput!): UpdateStuccoPackPayload
  updateSubscriptionProduct(
    input: UpdateSubscriptionProductInput!
  ): UpdateSubscriptionProductPayload
  updateUser(input: UpdateUserInput!): UpdateUserPayload
  updateUserColors(input: UpdateUserColorsInput!): UpdateUserColorsPayload
  updateUserCreateDateHidden(
    input: UpdateUserCreateDateHiddenInput!
  ): UpdateUserCreateDateHiddenPayload
  updateUserDirectoryHidden(
    input: UpdateUserDirectoryHiddenInput!
  ): UpdateUserDirectoryHiddenPayload
  updateUserEmailReusable(
    input: UpdateUserEmailReusableInput!
  ): UpdateUserEmailReusablePayload
  updateUserIsEmailRevertSuccess(
    input: UpdateUserIsEmailRevertSuccessInput!
  ): UpdateUserIsEmailRevertSuccessPayload
  updateUserPredictionSettings(
    input: UpdateUserPredictionSettingsInput!
  ): UpdateUserPredictionSettingsPayload
  updateUserSubscriptionSettings(
    input: UpdateUserSubscriptionSettingsInput!
  ): UpdateUserSubscriptionSettingsPayload
  updateUserTeamMembership(
    input: UpdateUserTeamMembershipInput!
  ): UpdateUserTeamMembershipPayload
  updateUserVideoShelves(
    input: UpdateUserVideoShelvesInput!
  ): UpdateUserVideoShelvesPayload
  updateUserViewedVideo(
    input: UpdateUserViewedVideoInput!
  ): UpdateUserViewedVideoPayload
  updateVideo(input: UpdateVideoInput!): UpdateVideoPayload
  updateVideoComment(input: UpdateVideoCommentInput!): UpdateVideoCommentPayload
  updateVideoStreamSettings(
    input: UpdateVideoStreamSettingsInput!
  ): UpdateVideoStreamSettingsPayload
  updateVideosViewability(
    input: UpdateVideosViewabilityInput!
  ): UpdateVideosViewabilityPayload
  updateVisibility(input: UpdateVisibilityInput!): UpdateVisibilityPayload
  updateWhisperSettings(
    input: UpdateWhisperSettingsInput!
  ): UpdateWhisperSettingsPayload
  updateWhisperThread(
    input: UpdateWhisperThreadInput!
  ): UpdateWhisperThreadPayload
  uploadCompetitionImage(
    input: UploadCompetitionImageInput!
  ): UploadCompetitionImagePayload
  useChatNotificationToken(
    input: UseChatNotificationTokenInput!
  ): UseChatNotificationTokenPayload
  validateVerificationCode(
    input: ValidateVerificationCodeInput!
  ): ValidateVerificationCodePayload
  verifyContactMethod(
    input: VerifyContactMethodInput!
  ): VerifyContactMethodPayload
  verifyOneTimePassword(
    input: VerifyOneTimePasswordInput!
  ): VerifyOneTimePasswordPayload
  verifyRewardedVideoEligibilityCaptcha(
    input: VerifyRewardedVideoEligibilityCaptchaInput!
  ): VerifyRewardedVideoEligibilityCaptchaPayload
  viewedNotifications: ViewedNotificationsPayload
  visitStreamManager(input: VisitStreamManagerInput!): VisitStreamManagerPayload
  voteInAdPoll(input: VoteInAdPollInput!): VoteInAdPollPayload
  voteInPoll(input: VoteInPollInput!): VoteInPollPayload
  voteInPollByChoiceIndex(
    input: VoteInPollByChoiceIndexInput!
  ): VoteInPollByChoiceIndexPayload
}

type NonTCFCookieVendor {
  consentStatus: ConsentStatus!
  cookieVendorType: CookieVendorType!
  hasUserSetConsent: Boolean!
  isVisible: Boolean!
  name: VendorName!
  policyURL: String!
}

type OAuthApp {
  category: OAuthAppCategory
  createdAt: Time!
  id: ID!
  name: String!
  otherDescription: String
  owner: User
  redirectURI: String!
  secret: String!
  updatedAt: Time!
  willTokensExpire: Boolean!
}

enum OAuthAppCategory {
  GAME_INTEGRATION
  WEBSITE_INTEGRATION
  APPLICATION_INTEGRATION
  BROWSER_EXTENSION
  BROADCASTER_SUITE
  CHAT_BOT
  GIVEAWAY_LOYALTY_TOOL
  ANALYTICS_TOOL
  OTHER
}

type OAuthAppConnection {
  edges: [OAuthAppEdge!]!
  pageInfo: PageInfo!
}

type OAuthAppEdge {
  cursor: Cursor!
  node: OAuthApp!
}

interface OEmbed {
  authorName: String
  authorURL: String
  cacheAge: Int
  inputURL: String!
  providerName: String
  providerURL: String
  thumbnail: ThumbnailOEmbed
  title: String
  type: String!
  version: String!
}

type Offer {
  eligibility: OfferEligibility!
  endAt: Time
  giftType: GiftType
  id: ID!
  listing: OfferListing
  platform: OfferPlatform!
  promotion: OfferPromotion
  quantity: Range
  self: OfferSelfEdge
  startAt: Time!
  tagBindings: [OfferTagBinding!]!
  tplr: String!
}

input OfferAndStatus {
  offerID: ID!
  status: String!
}

enum OfferDeliveryMethod {
  CLAIM_CODE
  DIRECT_ENTITLEMENT
  SES_ENTITLEMENT
  EXTERNAL @deprecated(reason: "Use EXTERNAL_OFFER instead")
  EXTERNAL_OFFER
}

type OfferEligibility {
  benefitsEndAt: Time
  benefitsStartAt: Time
  isEligible: Boolean!
  maxQuantityOverride: Int
  purchaseType: OfferPurchaseType!
  reasonCode: OfferIneligibilityReasonCode
}

enum OfferIneligibilityReasonCode {
  ALREADY_PURCHASED
  COULD_NOT_VERIFY
  MAX_TOKEN_BALANCE
  NONE
  OTHER
}

type OfferListing {
  cancellationPolicy: CancellationPolicyType!
  chargeModel: ChargeModel!
}

enum OfferPlatform {
  WEB
  IOS
  ANDROID
  DESKTOP
}

type OfferPromotion {
  endAt: Time
  id: ID!
  listing: OfferListing!
    @deprecated(
      reason: "No longer used, currently left for backwards compatibility"
    )
  name: String!
  priority: Int!
  promoDisplay: PromotionDisplay!
  startAt: Time!
}

enum OfferPurchaseType {
  DEFAULT_PURCHASE
  UPGRADE_RECURRING_SUB_TIER
  DOWNGRADE_RECURRING_SUB_TIER
  FUTURE_PURCHASE
}

type OfferSelfEdge {
  checkoutActions(
    quantity: Int!
    paymentSession: PaymentSession
  ): [CheckoutAction!]
  checkoutConfiguration: CheckoutConfiguration
  eligiblePaymentMethods: [EligiblePaymentMethod!]
}

enum OfferState {
  EXPIRED
  LIVE
  FUTURE
}

enum OfferStatus {
  UNSEEN
  SEEN
  CLAIMED
  DISMISSED
  OVERRIDDEN
  ERROR
}

type OfferTagBinding {
  key: String!
  value: String!
}

input OfferTagBindingInput {
  key: String!
  value: String!
}

type Onboarding {
  onboardingStreams(
    first: Int = 3
    locale: String
    languages: [Language!]
    games: [String!]
  ): [Stream] @deprecated(reason: "This feature has been sunset.")
  skippedChannelIDs: [ID!] @deprecated(reason: "This feature is retired")
}

type OnboardingInvitations {
  payout: PayoutInvite
  upgrade: PayoutInvite
}

type OnsiteNotification {
  actions: [OnsiteNotificationAction!]!
  body: String!
  category: String
  createdAt: Time!
  creators: [User]!
  destinationType: String
  displayType: OnsiteNotificationDisplayType!
  extra: OnsiteNotificationContent
  id: ID!
  isRead: Boolean!
  renderStyle: OnsiteNotificationRenderStyle!
  thumbnailURL: String!
  type: String!
  updatedAt: Time!
}

type OnsiteNotificationAction {
  body: String!
  id: ID!
  label: String!
  modalID: ID!
  type: String!
  url: String!
}

type OnsiteNotificationConnection {
  edges: [OnsiteNotificationEdge!]
  pageInfo: PageInfo
  summary: OnsiteNotificationsSummary
}

union OnsiteNotificationContent =
    Clip
  | Game
  | OnsiteNotificationExternalLink
  | User
  | Video
  | VideoComment
enum OnsiteNotificationDisplayType {
  VIEWER
  CREATOR
}

type OnsiteNotificationEdge {
  cursor: Cursor
  node: OnsiteNotification!
}

type OnsiteNotificationExternalLink {
  url: String!
}

enum OnsiteNotificationRenderStyle {
  DEFAULT
  TWO_BUTTONS
}

enum OnsiteNotificationsCapability {
  HOMEPAGE
  CHANNEL_PAGE
  NOTIFICATION_SETTINGS_PAGE
  BROADCASTER_DASHBOARD
  BROWSE_GAME
  EXTERNAL_LINK
  WEB_ONLY
  WHISPER_THREAD
  FRIEND_REQUEST
  HOT_CLIP
  HOT_CLIP_FOLLOWER
  VOD_UPLOAD
  VOD_COMMENT
  VOD_COMMENT_MOD
  VOD_COMMENT_REPLY
  SUB_GIFT_RECEIVED
  DROPS_AVAILABLE
  COMMUNITY_GUIDELINES_CHANGE
  SMART_ANNOUNCEMENT
  AFFILIATE_INVITE
}

type OnsiteNotificationsSummary {
  creatorUnreadSummary: OnsiteNotificationsUnreadSummary
  lastSeenAt: Time
  unseenCount: Int!
  viewerUnreadSummary: OnsiteNotificationsUnreadSummary
}

type OnsiteNotificationsUnreadSummary {
  lastReadAllAt: Time
  unreadCount: Int!
}

input OrderPanelsInput {
  ids: [ID!]!
}

type OrderPanelsPayload {
  panels: [Panel]
}

type Organization {
  bountyCampaigns(
    campaignID: ID
    status: BountyCampaignStatus
  ): BountyCampaignConnection
  brandPortalSettings: BrandPortalSettings
  curseCompanyID: ID
  dropCampaigns: [DropCampaign!]
    @deprecated(reason: "Use Organization.drops instead")
  drops: OrganizationDrops!
  estimatedBroadcasterViewerReach(
    gameNames: [String!]!
    targetAllBroadcasters: Boolean!
    targetVarietyBroadcasters: Boolean!
    streamLengthSeconds: Int
    targetAllCountries: Boolean = false
    targetAllGames: Boolean = false
    countries: [String!] = []
  ): BroadcasterViewerReach
  games(includeBountyBoardGames: Boolean = false): [Game!]
  id: ID!
  invites(first: Int = 10, after: Cursor): OrganizationInviteConnection
  isCampaignsEnabled: Boolean!
  isContractSigned: Boolean!
  isLegacy: Boolean!
  members(
    first: Int = 10
    after: Cursor
    input: OrganizationMembersInput
  ): OrganizationMemberConnection
  name: String!
  self: OrganizationSelfEdge
  type: OrganizationType!
  url: String!
}

enum OrganizationAppilcationStatus {
  PENDING
  REJECTED
  APPROVED
  DELETED
}

type OrganizationApplication {
  contactEmail: String
    @deprecated(reason: "No longer collecting contact email.")
  organizationName: String!
  status: OrganizationAppilcationStatus!
}

type OrganizationDrops {
  benefits: [DropBenefit!]
  campaigns: [DropCampaign!]
}

type OrganizationInvite {
  createdAt: Time!
  expiresAt: Time!
  id: ID!
  invitee: User
  inviter: User
  organizationID: ID!
  organizationName: String!
  role: OrganizationMemberRole!
}

type OrganizationInviteConnection {
  edges: [OrganizationInviteEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type OrganizationInviteEdge {
  cursor: Cursor!
  node: OrganizationInvite!
}

type OrganizationInviteUserConnection {
  edges: [OrganizationInviteEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
  isWithinOrganizationMembershipLimit: Boolean
}

type OrganizationMember {
  email: String!
  firstName: String!
  id: ID!
  lastName: String!
  role: OrganizationMemberRole!
  title: String!
  user: User
}

type OrganizationMemberConnection {
  edges: [OrganizationMemberEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type OrganizationMemberEdge {
  cursor: Cursor!
  joinedAt: Time!
  node: OrganizationMember!
}

enum OrganizationMemberRole {
  ADMINISTRATOR
  DEVELOPER
  MANAGER
  MARKETER
  OWNER
  BILLING_MANAGER
  SHADOW_ACCOUNT
}

input OrganizationMembersInput {
  role: OrganizationMemberRole
}

type OrganizationSelfEdge {
  canAddMember: Boolean!
  canLeaveOrganization: Boolean!
  canRemoveMember: Boolean!
  joinedAt: Time!
  role: OrganizationMemberRole!
}

enum OrganizationType {
  GAME_DEVELOPER
  GAME_PUBLISHER
  OTHER
  BRANDS_ADVERTISING
  BROADCASTER_TOOLS
}

type OutgoingFriendRequestConnection {
  edges: [OutgoingFriendRequestEdge!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type OutgoingFriendRequestEdge {
  createdAt: Time!
  cursor: Cursor!
  node: User
}

type OverwatchLeagueTeamPreference {
  availableTeamsSet: [OverwatchTeamPreferenceOption!]
  id: ID!
  selectedTeam: OverwatchTeamPreferenceOption
}

type OverwatchMomentDetails {
  event: String!
  heroName: String!
  role: String!
}

type OverwatchTeamPreferenceOption {
  id: ID!
  rewards: [TournamentReward!]
  teamName: String!
}

type OwnerChanletAttributes {
  isChanletFeatureEnabled: Boolean!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

type PaidUpgrade {
  originID: ID!
  price: String! @deprecated(reason: "Transitioning to priceInfo instead")
  priceInfo(taxCountry: String): PriceInfo!
  startsAt: Time!
  tier: String!
}

interface Panel {
  id: ID!
  type: PanelType!
}

input PanelActivationInput {
  slot: String!
}

enum PanelType {
  DEFAULT
  EXTENSION
}

type PanelView implements ExtensionView {
  canLinkExternalContent: Boolean!
  height: Int!
  viewerPath: String!
  viewerURL: String!
}

input PanelViewInput {
  height: Int!
  viewerPath: String!
}

type Partnership {
  isPartner: Boolean @deprecated
}

type PartnershipApplication {
  id: ID!
  resolvedAt: Time
}

enum PasswordStatus {
  NOT_EVALUATED
  VALID
  INVALID
  UNKNOWN
}

type PathToAffiliate {
  averageViewers: QuestGoalFloat
  badgeURL: String
  completedAt: Time
  followers: QuestGoalInt
  hoursStreamed: QuestGoalFloat
  uniqueDaysStreamed: QuestGoalInt
  affiliateInvitationStatus: AffiliateInvitationStatus
}

type PathToPartner {
  averageViewers: QuestGoalFloat
  badgeURL: String
  completedAt: Time
  hoursStreamed: QuestGoalFloat
  questEvaluationInterval: QuestEvaluationInterval
  uniqueDaysStreamed: QuestGoalInt
}

type PayableStatus {
  isPayable: Boolean!
}

enum PaymentCardType {
  VISA
  MASTERCARD
  AMERICAN_EXPRESS
  DISCOVER
}

type PaymentIncentiveMetricsRollup {
  advertisingDensity: Float!
  liveHoursBroadcast: Float!
  liveMinutesWatched: Float!
  timestamp: Time
  vodMinutesWatched: Float!
}

enum PaymentInstrumentType {
  CREDIT_CARD
  AMAZON
  PAYPAL
  GOOGLE_IAB
  APPLE_IAP
  SKRILL
  YANDEX
  WEBMONEY
  UNKNOWN
  WALLET
  DIRECT_DEBIT
}

type PaymentMethod {
  billingCountry: String
  billingEmail: String
  cardType: PaymentCardType
  chargeInstrumentID: ID!
  expirationMonth: Int
  expirationYear: Int
  extMethodID: ID
  isRestricted: Boolean!
  lastFour: String
  paymentScheme: PaymentScheme
  paymentType: PaymentInstrumentType!
  provider: PaymentProvider!
  purchaseProfiles: [PurchaseProfile!]
  recurringPaymentDetails: [RecurringPaymentDetail!]
}

enum PaymentMethodAvailabilityStatus {
  AVAILABLE
  DEGRADED
  FULL_OUTAGE
}

enum PaymentProvider {
  UNKNOWN
  PAYPAL
  PAYPAL_RT
  RECURLY
  XSOLLA
  XSOLLA_V3
  ZUORA
  PRIME
  GOOGLE_IAB
  APPLE_IAP
  SUB_TOKEN
}

type PaymentProviderConfigs {
  recurly: RecurlyConfigs!
  xsolla: XsollaConfigs!
  zuora: ZuoraConfigs!
}

enum PaymentScheme {
  SEPA
  BACS
}

input PaymentSession {
  checkoutSessionID: ID
  deviceID: ID
  localStorageDeviceID: ID
  offerSessionID: ID
  pageSessionID: ID
  tabSessionID: ID
}

type PaymentTransaction {
  currency: String
  grossAmount: Int
  grossAmountDivisor: Int
  id: ID!
  isGift: Boolean!
  paymentMethod: PaymentMethod!
  product: PaymentTransactionProduct!
  purchaseOrderID: ID
  purchasedAt: Time!
  quantity: Int!
  recipient: User
}

type PaymentTransactionConnection {
  edges: [PaymentTransactionEdge!]
  firstPurchasedAt: Time
  lastPurchasedAt: Time
  pageInfo: PageInfo!
  totalCount: Int
}

input PaymentTransactionConnectionCriteriaInput {
  purchasedAfter: Time
  purchasedBefore: Time
  sortBy: PaymentTransactionSort = PURCHASE_DATE_DESC
  type: PaymentTransactionTypeFilter = ALL
  userID: ID!
}

type PaymentTransactionEdge {
  cursor: Cursor!
  node: PaymentTransaction
}

type PaymentTransactionProduct {
  bundleSize: Int!
  name: String!
  owner: User
  tier: String
  type: PaymentTransactionType!
}

enum PaymentTransactionSort {
  PRICE_DESC
  PRICE_ASC
  PURCHASE_DATE_DESC
  PURCHASE_DATE_ASC
}

enum PaymentTransactionType {
  SUBSCRIPTION
  BITS
  SUB_TOKEN
  GIFT_CARD
  CELEBRATION
  UNKNOWN
}

enum PaymentTransactionTypeFilter {
  SUBSCRIPTIONS
  SUB_TOKEN
  ALL
}

type Payout {
  history: PayoutHistory
}

type PayoutBalance {
  currency: String!
  currentPayoutBalanceAmount: Float!
  month: Int!
  year: Int!
}

enum PayoutCategory {
  AFFILIATE
  EXTENSIONS_DEVELOPER
  PARTNER
}

type PayoutHistory {
  iframeURL: String
}

type PayoutInvite {
  category: PayoutOnboardingCategory
  id: ID!
  isForAffiliate: Boolean!
  isForExtensionsDeveloper: Boolean!
  isForPartner: Boolean!
  isLegacy: Boolean!
  workflow: PayoutOnboardingWorkflow
}

enum PayoutOnboardingCategory {
  AFFILIATE
  STANDARD_PARTNER
  PREMIUM_PARTNER
  CUSTOM_PARTNER
  EXTENSIONS_DEVELOPER
  UNPAID_PARTNER
}

enum PayoutOnboardingStep {
  REGISTRATION_NOT_STARTED
  AGREEMENT_NOT_STARTED
  ROYALTY_TAX_INTERVIEW_NOT_STARTED
  ROYALTY_TAX_INTERVIEW_PENDING
  ROYALTY_TAX_INTERVIEW_ACTION_REQUIRED
  ROYALTY_TAX_INTERVIEW_MISMATCH
  ROYALTY_TAX_INTERVIEW_FAILED
  SERVICE_TAX_INTERVIEW_NOT_STARTED
  SERVICE_TAX_INTERVIEW_PENDING
  SERVICE_TAX_INTERVIEW_ACTION_REQUIRED
  SERVICE_TAX_INTERVIEW_MISMATCH
  SERVICE_TAX_INTERVIEW_FAILED
  PAYOUT_METHOD_NOT_STARTED
  PAYOUT_METHOD_PENDING
  REVIEW_PENDING
  COMPLETED
  CANCELED
  AGREEMENT_PENDING_UPGRADE
}

type PayoutOnboardingWorkflow {
  currentStep: PayoutOnboardingStep!
  id: ID!
  payoutSettingsURL(redirectURL: String): String!
  registration: PayoutRegistration
  taxInterview(type: TaxInterviewType!, returnURL: String!): TaxInterview
  taxMismatchErrors: [TaxMismatchError!]
  timestamp: Time!
}

type PayoutPlan {
  category: PayoutCategory!
  isReceivingRevenue: Boolean!
  tags: [PayoutPlanTag!]
}

enum PayoutPlanTag {
  STANDARD
  PREMIUM
  CUSTOM
  LEGACY
  ESPORTS
}

type PayoutRegistration {
  birthdate: Time!
  city: String!
  companyName: String
  countryCode: String!
  email: String!
  firstName: String!
  lastName: String!
  middleName: String
  parentEmail: String
  parentName: String
  postal: String
  stateCode: String
  streetAddress: String!
  streetAddress2: String
}

type PayWithAmazonConfigs {
  clientID: ID!
  isProduction: Boolean!
  sellerID: ID!
}

type PendingSubscription {
  isCancelable: Boolean!
  originID: ID!
  price: String! @deprecated(reason: "Transitioning to priceInfo instead")
  priceInfo(taxCountry: String): PriceInfo!
  startsAt: Time!
  tier: String!
  type: PendingSubType!
}

enum PendingSubType {
  GIFT_TO_PAID
  DNR_TO_RESUB_RECURRING
  DNR_TO_RESUB_NONRECURRING
  PRIME_TO_PAID
}

enum PermanentEmoteModifier {
  UNKNOWN
  BLACK_WHITE
  HORIZONTAL_FLIP
  SUNGLASSES
  THINKING
  SQUISHED
}

type PersonalSection {
  items: [PersonalSectionItem!]
  title: PersonalSectionTitle!
  type: PersonalSectionType!
}

type PersonalSectionChannel {
  content: PersonalSectionChannelContent
  label: PersonalSectionChannelLabel!
  trackingID: ID!
  user: User
}

union PersonalSectionChannelContent = Stream | VideoConnection
enum PersonalSectionChannelLabel {
  NONE
  RECOMMENDED
  SIMILAR
  FOLLOWED
  POPULAR
}

input PersonalSectionInput {
  contextChannelName: String
  recommendationContext: RecommendationsContext
  sectionInputs: [PersonalSectionType!]!
}

union PersonalSectionItem = PersonalSectionChannel
type PersonalSectionTextToken {
  value: String!
}

type PersonalSectionTitle {
  localizedFallback: String!
  localizedTokens: [PersonalSectionTitleToken!]
}

union PersonalSectionTitleToken = PersonalSectionTextToken | User
enum PersonalSectionType {
  FOLLOWED_SECTION
  RECOMMENDED_SECTION
  POPULAR_SECTION
  SIMILAR_SECTION
}

enum PhaseState {
  UNSTARTED
  PLAYING
  FINISHED
  UNKNOWN
}

type PhotoOEmbed implements OEmbed {
  authorName: String
  authorURL: String
  cacheAge: Int
  height: Int!
  inputURL: String!
  providerName: String
  providerURL: String
  thumbnail: ThumbnailOEmbed
  title: String
  type: String!
  url: String!
  version: String!
  width: Int!
}

union Platform = PlayStation
type PlatformEventSetting {
  isEnabled: Boolean!
  platformName: String!
  settingState: String!
}

enum PlatformType {
  all
  ps4
  xbox
}

type PlaybackAccessToken {
  signature: String!
  value: String!
}

input PlaybackAccessTokenParams {
  disableHTTPS: Boolean
  hasAdblock: Boolean
  platform: String!
  playerBackend: String
  playerType: String!
}

type Playing implements Activity {
  game: Game
  type: ActivityType
}

type PlayStation {
  platform: String
  title: SCETitle
  updatedAt: Time
  user: SCEUser
}

type Poll {
  choice(id: ID!): PollChoice
  choices: [PollChoice!]!
  createdBy: User
  durationSeconds: Int!
  endedAt: Time
  endedBy: User
  id: ID!
  isViewable: Boolean!
  ownedBy: User
  remainingDurationMilliseconds: Int!
  self: PollSelfEdge
  settings: PollSettings!
  startedAt: Time!
  status: PollStatus!
  title: String!
  tokens: PollTokenBreakdown!
  topBitsContributor: PollTopBitsContributor
  topCommunityPointsContributor: PollTopCommunityPointsContributor
  topContributor: PollTopContributor
    @deprecated(reason: "Use topBitsContributor instead.")
  totalVoters: Int!
  votes: PollVoteBreakdown!
}

type PollChoice {
  id: ID!
  self: PollChoiceSelfEdge!
  title: String!
  tokens: PollTokenBreakdown!
  totalVoters: Int!
  voters(
    first: Int = 15
    after: Cursor
    sort: PollVoterConnectionSort = VOTES
    direction: PollVoterConnectionSortDirection = DESC
  ): PollChoiceVoterConnection
  votes: PollVoteBreakdown!
}

type PollChoiceSelfEdge {
  voter: PollVoter
}

type PollChoiceVoterConnection {
  nodes: [PollVoterConnectionEdge!]!
}

type PollConnection {
  edges: [PollEdge!]
  pageInfo: PageInfo!
}

type PollEdge {
  cursor: Cursor!
  node: Poll!
}

type PollSelfEdge {
  voter: PollVoter
}

type PollSettings {
  bitsVotes: PollSettingsBitsVotes!
  communityPointsVotes: PollSettingsCommunityPointsVotes!
  id: ID!
  multichoice: PollSettingsMultichoice!
  subscriberMultiplier: PollSettingsSubscriberMultiplier!
    @deprecated(reason: "Subscriber multipliers are no longer supported.")
  subscriberOnly: PollSettingsSubscriberOnly!
    @deprecated(reason: "Subscriber-only polls are no longer supported.")
}

type PollSettingsBitsVotes {
  cost: Int!
  isEnabled: Boolean!
}

type PollSettingsCommunityPointsVotes {
  cost: Int!
  isEnabled: Boolean!
}

type PollSettingsMultichoice {
  isEnabled: Boolean!
}

type PollSettingsSubscriberMultiplier {
  isEnabled: Boolean!
}

type PollSettingsSubscriberOnly {
  isEnabled: Boolean!
}

enum PollSort {
  START_TIME
}

enum PollStatus {
  UNKNOWN
  ACTIVE
  COMPLETED
  TERMINATED
  ARCHIVED
  MODERATED
}

type PollTokenBreakdown {
  bits: Int!
  communityPoints: Int!
  id: ID!
}

type PollTopBitsContributor {
  bitsAmount: Int!
  user: User
}

type PollTopCommunityPointsContributor {
  communityPointsAmount: Int!
  user: User
}

type PollTopContributor {
  bitsAmount: Int!
  user: User
}

type PollVoteBreakdown {
  base: Int!
  bits: Int!
  communityPoints: Int!
  id: ID!
  total: Int!
}

type PollVoter {
  choices: [PollVoterChoice!]!
  id: ID!
  poll: Poll
  tokens: PollTokenBreakdown!
  user: User
  votes: PollVoteBreakdown!
}

type PollVoterChoice {
  id: ID!
  pollChoice: PollChoice
  tokens: PollTokenBreakdown!
  votes: PollVoteBreakdown!
}

type PollVoterConnection {
  nodes: [PollVoterConnectionEdge!]!
}

type PollVoterConnectionEdge {
  cursor: Cursor!
  node: PollVoter!
}

enum PollVoterConnectionSort {
  VOTES
  CREATED_DATE
  BITS
  CHANNEL_POINTS
}

enum PollVoterConnectionSortDirection {
  DESC
  ASC
}

input PollVoteTokensInput {
  bits: Int!
  channelPoints: Int!
}

type Post {
  author: User
  body: MessageBody
  createdAt: Time
  embeds: [PostEmbed]
  id: ID!
  isDeleted: Boolean
  reactions: [Reaction]
  self: PostSelfConnection
}

union PostEmbed =
    Clip
  | LinkOEmbed
  | PhotoOEmbed
  | RichOEmbed
  | Video
  | VideoOEmbed
type PostPermissionSet {
  canDelete: Boolean!
}

type PostSelfConnection {
  permissions: PostPermissionSet
}

type Prediction {
  event: PredictionEvent
  id: ID!
  isResultAcknowledged: Boolean
  outcome: PredictionOutcome
  points: Int!
  pointsWon: Int
  predictedAt: Time!
  result: PredictionResult
  updatedAt: Time!
  user: User
}

type PredictionEvent {
  channel: Channel
  createdAt: Time!
  createdBy: PredictionEventActor
  endedAt: Time
  endedBy: PredictionEventActor
  id: ID!
  lockedAt: Time
  lockedBy: PredictionEventActor
  outcomes: [PredictionOutcome!]!
  predictionWindowSeconds: Int!
  self: PredictionEventSelfEdge
  status: PredictionEventStatus!
  title: String!
  winningOutcome: PredictionOutcome
}

union PredictionEventActor = ExtensionClient | User
type PredictionEventConnection {
  edges: [PredictionEventEdge!]!
  pageInfo: PageInfo!
}

type PredictionEventEdge {
  cursor: Cursor!
  node: PredictionEvent!
}

type PredictionEventSelfEdge {
  prediction: Prediction
  restriction: UserPredictionEventRestriction
}

enum PredictionEventStatus {
  ACTIVE
  LOCKED
  RESOLVE_PENDING
  RESOLVED
  CANCEL_PENDING
  CANCELED
}

type PredictionOutcome {
  color: PredictionOutcomeColor!
  id: ID!
  title: String!
  topPredictors: [Prediction!]!
  totalPoints: Int!
  totalUsers: Int!
}

enum PredictionOutcomeColor {
  BLUE
  PINK
  GREEN
  ORANGE
  GREY
  PURPLE
}

enum PredictionResult {
  LOSE
  REFUND
  WIN
}

type Premiere {
  id: ID! @deprecated(reason: "Premieres as a product has been deprecated")
  items(first: Int = 10, after: Cursor): PremiereConnection
    @deprecated(reason: "Premieres as a product has been deprecated")
  pastPremiere: Video
    @deprecated(reason: "Premieres as a product has been deprecated")
  status: PremiereStatus!
    @deprecated(reason: "Premieres as a product has been deprecated")
  user: User @deprecated(reason: "Premieres as a product has been deprecated")
}

type PremiereConnection {
  edges: [PremiereItemEdge]
    @deprecated(reason: "Premieres as a product has been deprecated")
  pageInfo: PageInfo
    @deprecated(reason: "Premieres as a product has been deprecated")
  totalCount: Int
    @deprecated(reason: "Premieres as a product has been deprecated")
}

union PremiereItem = Video
type PremiereItemEdge {
  cursor: Cursor!
    @deprecated(reason: "Premieres as a product has been deprecated")
  node: PremiereItem!
    @deprecated(reason: "Premieres as a product has been deprecated")
}

enum PremiereStatus {
  UNSCHEDULED @deprecated(reason: "Premieres as a product has been deprecated")
  SCHEDULED @deprecated(reason: "Premieres as a product has been deprecated")
  CANCELLED @deprecated(reason: "Premieres as a product has been deprecated")
  STARTED @deprecated(reason: "Premieres as a product has been deprecated")
  SUCCESS @deprecated(reason: "Premieres as a product has been deprecated")
  FAILED @deprecated(reason: "Premieres as a product has been deprecated")
  UNKNOWN @deprecated(reason: "Premieres as a product has been deprecated")
}

enum PresignDevInsightsReportURLDomain {
  GAME
  EXTENSION
  DROP
}

input PresignDevInsightsReportURLInput {
  domain: PresignDevInsightsReportURLDomain!
  id: ID!
  type: PresignDevInsightsReportURLReportType
  orgID: ID
}

type PresignDevInsightsReportURLPayload {
  url: String
}

enum PresignDevInsightsReportURLReportType {
  OVERVIEW_V2
  DROPS_CAMPAIGNS_TOP_STREAMERS
  DROPS_CAMPAIGNS_OVERVIEW
  DROPS_CAMPAIGNS_DROPS_OVERVIEW
}

type PriceInfo {
  currency: Currency!
  description: String!
  discount: DiscountBreakdown
  exponent: Int!
  id: ID!
  isTaxInclusive: Boolean!
  price: Int!
  tax: Int!
  total: Int!
}

type PrimeEmoticons {
  currentSetName: PrimeEmoticonsSetName!
  emoticonSets: [SmiliesSet!]
}

enum PrimeEmoticonsSetName {
  ROBOTS
  PURPLE
  MONKEYS
}

type PrimeOffer {
  catalogOfferID: ID!
  claimHint: ClaimHint!
  claimInstructions: String!
  content: PrimeOfferContent
  deliveryMethod: OfferDeliveryMethod!
  description: String!
  id: ID!
  imageURL: String!
  priority: Int!
  self: PrimeOfferSelfConnection
  tags: [String!]!
  title: String!
}

type PrimeOfferContent {
  categories: [String!]!
  externalURL: String
  game: Game
  publisher: String!
  skus: [String!]!
}

type PrimeOfferEligibility {
  canClaim: Boolean!
  hasRequiredAccount: Boolean!
  isClaimed: Boolean!
  isInEligibleMarketplace: Boolean!
  isPrimeGaming: Boolean!
  isUnderClaimLimit: Boolean!
  isWithinOfferWindow: Boolean!
  offerState: OfferState!
  status: OfferStatus!
}

type PrimeOfferSelfConnection {
  claimData: String!
  hasEntitlement: Boolean!
  status: String!
}

type PrimeOfferWithEligibility {
  catalogOfferID: ID!
  claimInstructions: String!
  content: PrimeOfferContent
  deliveryMethod: OfferDeliveryMethod!
  description: String!
  id: ID!
  imageURL: String!
  offerEligibility: PrimeOfferEligibility
  priority: Int!
  tags: [String!]!
  title: String!
}

type PrimePayoutDetail {
  currency: Currency!
  currentPrimePayout: CurrentPrimePayout!
  deferredPrimePayout: DeferredPrimePayout!
  month: Int!
  year: Int!
}

type PrimePayoutDetails {
  primePayoutHistory: [PrimePayoutDetail!]!
}

type PrimePromotion {
  externalURL: String
  id: ID!
  isExternalLink: Boolean!
  text: String!
}

type PrimeSettings {
  id: ID!
  isSubCreditChatNotificationEnabled: Boolean!
  primeEmoticons: PrimeEmoticons
}

type PrimeSubCreditBenefit {
  renewalDate: Time
  willRenew: Boolean
}

type PrimeVideoBenefit {
  error: WatchPartyError
  isValid: Boolean
}

type PrimeVideoRating {
  count: Int!
  stars: Float!
}

enum PrivacyLawName {
  CCPA
  GDPR
  ROW
}

enum ProcessAndroidPaymentErrorCode {
  INELIGIBLE
  INVALID_ARGUMENT
  INTERNAL_SERVER_ERROR
  UNAUTHENTICATED
  ALREADY_HANDLED
}

input ProcessAndroidPaymentInput {
  giftRecipientUserIDs: [ID!]
  offerID: ID!
  purchasingUserID: ID!
  quantity: Int!
  receiptData: AndroidReceiptDataInput!
  tagBindings: [OfferTagBindingInput!]!
  trackingData: AndroidPaymentTrackingDataInput
}

type ProcessAndroidPaymentPayload {
  error: ProcessAndroidPaymentErrorCode
  purchaseOrder: PurchaseOrder
}

enum ProcessIOSPaymentErrorCode {
  INELIGIBLE
  INVALID_ARGUMENT
  NOT_FOUND
  INTERNAL_SERVER_ERROR
  UNAUTHENTICATED
  ALREADY_HANDLED
}

input ProcessIOSPaymentInput {
  purchasingUserID: ID!
  offerID: ID!
  tagBindings: [OfferTagBindingInput!]!
  receiptData: IOSReceiptDataInput!
  trackingData: IOSPaymentTrackingDataInput
  giftRecipientUserIDs: [ID!]
  quantity: Int!
}

type ProcessIOSPaymentPayload {
  error: ProcessIOSPaymentErrorCode
  purchaseOrder: PurchaseOrder
}

interface ProductCatalogBenefit {
  id: ID!
}

interface ProductCatalogItem {
  benefits: [ProductCatalogBenefit!]
  description: String
  id: ID!
  offers: [Offer!]
  owner: ID!
  title: String!
}

type ProductPurchase {
  checkoutPriceSummary: CheckoutPriceSummary
  errorCode: ProductPurchaseErrorCode
  taxRegion: TaxRegion
}

enum ProductPurchaseErrorCode {
  USER_UNAUTHORIZED
  PRICING_ID_NOT_FOUND
  UNKNOWN_USER_RESIDENCE
  BILLING_INFO_NOT_FOUND
  PURCHASE_INELIGIBLE
  UNKNOWN
}

type ProgramAgreement {
  body: String!
  type: PayoutOnboardingCategory!
  version: String!
  startDate: Time!
  endDate: Time!
}

enum PromoDiscountType {
  DISCOUNT_TYPE_NONE
  DISCOUNT_TYPE_PERCENT
}

type PromotionDisplay {
  discountPercent: Float
  discountType: PromoDiscountType!
}

type PUBGMomentDetails {
  bucket: Int!
  event: String!
  gameMode: String!
  maxPlayerCount: Int!
  minPlayerCount: Int!
}

type PublishClipError {
  message: String
}

input PublishClipInput {
  previewOffsetSeconds: Float
  segments: [ClipSegmentInput!]!
  slug: ID!
  title: String
}

type PublishClipPayload {
  clip: Clip
  error: PublishClipError
}

input PublishCompetitionInput {
  id: ID!
}

type PublishCompetitionPayload {
  competition: Competition
}

type PublishSubscriptionEmoteError {
  code: PublishSubscriptionEmoteErrorCode!
}

enum PublishSubscriptionEmoteErrorCode {
  EMOTE_LIMIT_REACHED
  INVALID_OWNER
  EMOTE_CODE_ALREADY_EXISTS
  EMOTE_CODE_UNACCEPTABLE
  USER_OWNED_EMOTE_LIMIT_REACHED
  INCOMPLETE_EMOTE_IMAGE_DATA
  INVALID_CODE_SUFFIX
  INVALID_IMAGE_UPLOAD
  EMOTE_IMAGE_NOT_FOUND
  NOT_ENOUGH_EMOTE_IMAGE_ASSETS
  TOO_MANY_EMOTE_IMAGE_ASSETS
  INVALID_EMOTE_ASSET_TYPE
  EMOTE_MISSING_STATIC_ASSET
  EMOTE_MISSING_ANIMATED_ASSET
  UNKNOWN_ERROR
}

input PublishSubscriptionEmoteInput {
  assetType: EmoteAssetType
  codeSuffix: String!
  imageAssets: [EmoteImageAssetInput!]
  imageID1x: ID
  imageID2x: ID
  imageID4x: ID
  productID: ID!
}

type PublishSubscriptionEmotePayload {
  emote: Emote
  error: PublishSubscriptionEmoteError
}

input PurchasableOfferParams {
  countryCode: String
  giftRecipientIDs: [ID!]
  offerID: ID!
  promotionID: ID
  tagBindings: [OfferTagBindingInput!]
}

enum PurchaseableProductType {
  SUBSCRIPTION
  BITS
}

enum PurchaseIneligibilityReason {
  HAS_ACTIVE_SUBSCRIPTION
  NOT_APPLICABLE
}

enum PurchaseOfferErrorCode {
  INELIGIBLE
  INTERNAL_SERVER_ERROR
  INVALID_PAYMENT_METHOD
  UNAUTHENTICATED
}

input PurchaseOfferInput {
  billingAuthInfo: BillingAuthInfo
  giftRecipientUserIDs: [ID!]
  offerID: ID!
  paymentSession: PaymentSession!
  purchasingUserID: ID!
  quantity: Int!
  tagBindings: [OfferTagBindingInput!]!
  tenantTracking: String
}

type PurchaseOfferPayload {
  error: PurchaseOfferErrorCode
  purchaseOrder: PurchaseOrder
}

type PurchaseOrder {
  actionTokenID: ID
  failureReason: PurchaseOrderFailureReason
  id: ID!
  state: PurchaseOrderState!
}

enum PurchaseOrderFailureReason {
  BANK_DECLINED
  ENTITLEMENT_FAILED
  INELIGIBLE
  INVALID_PAYMENT_METHOD
  SYSTEM_ERROR
  UNKNOWN
}

enum PurchaseOrderState {
  UNKNOWN
  INITIATED
  PAYMENT_PENDING
  FULFILLMENT_INITIATED
  SUCCESS
  THREE_D_SECURE_CHALLENGE_REQUIRED
  FAILED
  CANCEL_BENEFITS_INITIATED
  BENEFITS_CANCELLED
  REFUND_INITIATED
  REFUND_APPLIED
  REFUND_FAILED
}

type PurchaseProfile {
  cancelledAt: Time
  createdAt: Time!
  expiresAt: Time
  extPurchaserID: ID
  extSubscriptionID: ID
  id: ID!
  isExpired: Boolean
  isGift: Boolean
  isPaying: Boolean!
  isRecurring: Boolean!
  isRefundable: Boolean
  paidAt: Time
  productType: SubscriptionProductType!
  purchasedAt: Time
  purchaserEmail: String!
  purchaserID: ID!
  purchaserName: String
  renewalCurrency: String
  renewalPrice: Int
  renewalStoppedAt: Time
  state: PurchaseProfileState!
  subscriptionBenefit: SubscriptionBenefit
  updatedAt: Time
  willRenew: Boolean!
}

enum PurchaseProfileState {
  ACTIVE
  CANCELLED
  INACTIVE
  MIGRATED
}

type Query {
  adContext(context: AdRequestContext!): AdContext
  adCreative(adSystem: String!, creativeID: ID!): AdCreative
  allTags(first: Int = 5, after: Cursor, tagScope: TagScope): TagConnection
  automodContent(input: AutoModContentInput!): AutoModContent
  badges: [Badge]
  bitsOffers: [BitsOffer!]
  challenge(id: ID!): ChannelChallenge @deprecated
  changelogEntries(limit: Int = 15): [ChangelogEntry!]
  channel(id: ID, name: String): Channel
  channelViewer(userLogin: String!, channelLogin: String!): ChannelViewer
  channels(ids: [ID!], names: [String!]): [Channel]
  chatRoomBanStatus(channelID: ID!, userID: ID!): ChatRoomBanStatus
  cheerConfig: GlobalCheerConfig!
  clientAuthorization(id: ID!): ClientAuthorization
  clip(slug: ID!): Clip
  cloudBroadcast(id: ID!): CloudBroadcast
  cloudBroadcastProvider(id: ID!): CloudBroadcastProvider
  collection(id: ID!, options: CollectionOptions): Collection
  competition(id: ID!): Competition
  competitionOrganizerCapabilities: CompetitionOrganizerCapability
  competitions(
    first: Int = 10
    after: Cursor
    state: CompetitionState = UPCOMING
  ): CompetitionConnection
  consent(consentSessionID: ID!): Consent
  contentTag(id: ID!): Tag
  contentTags(ids: [ID!]): [Tag!]
  copyrightClaim(id: ID!): CopyrightClaim
  copyrightClaims(
    channelID: ID!
    first: Int = 10
    after: Cursor
  ): CopyrightClaimConnection
  creatorCampArticle(id: ID!, category: String!): CreatorCampArticle
  creatorCampCategory(id: ID!): CreatorCampCategory
  creatorDashboard(
    startAt: Time!
    endAt: Time!
    period: TimeSeriesPeriod!
  ): CreatorDashboard
  creatorHome(channelID: ID): CreatorHome
  currentChannelViewer(channelID: ID!): ChannelViewer
  currentUser: User
  directory(name: String!, type: DirectoryType!): Directory
  drop(id: ID!): DropType
  dropBenefit(id: ID!, ownerID: ID!): DropBenefit
  dropCampaign(id: ID!): DropCampaign
  dropEligibility(dropInstanceID: ID!): DropEligibility
  emote(id: ID!): Emote
  emoteModifiers: [CommunityPointsEmoteModifier!]
  emoteSet(id: ID!): EmoteSet
  experiment: Experiment
  extension(id: ID!, version: String): Extension
  extensionCarousel(id: ID!): ExtensionCarousel
  extensionCategories(
    first: Int = 10
    after: Cursor
  ): ExtensionCategoryConnection
  extensionCategory(id: ID!): ExtensionCategory
  extensionClient(id: ID!): ExtensionClient
  extensionClients(organizationID: ID, after: Cursor): ExtensionClientConnection
  extensionManifest(id: ID!, version: String!): ExtensionManifest
  extensionManifests(id: ID!, after: Cursor): ExtensionManifestConnection
  extensionManifestsSummary(id: ID!, after: Cursor): ExtensionManifestsSummary
  extensionRatingsCSVReportPresignedURL(
    reportFilename: String!
  ): ExtensionRatingsCSVReportPresignedURL
  extensionSecrets(extensionID: ID!): ExtensionSecretsInfo
  extensionVersionDiscoveryManifest(
    id: ID!
    version: String!
  ): ExtensionVersionDiscoveryManifest
  extensions(
    first: Int = 10
    after: Cursor
    search: String
    state: ExtensionStateFilter
  ): ExtensionConnection
  featuredContentSections(language: String!): [FeaturedContentSection!]
  featuredStreams(
    first: Int = 6
    geolocation: String
    language: String
    acceptedMature: Boolean = true
  ): [FeaturedStream]
  featuredVideos(first: Int = 2, language: String!): [FeaturedVideo]
    @deprecated(reason: "Subject to change")
  feed(id: ID!): Feed @deprecated
  feedEmbed(url: String!): FeedEmbed @deprecated
  feedItemContent(id: ID!): FeedItemContent @deprecated
  game(name: String, id: ID): Game
  games(
    first: Int = 10
    after: Cursor
    options: GameOptions
    locale: String
    tags: [String!]
  ): GameConnection
  isUsernameAvailable(username: String!): Boolean
  key(code: String!, countryOfResidence: String): Claimable
  message(id: ID!): Message
  modViewNewsfeedEntries(first: Int = 10): [ModViewNewsfeedEntry!]
  organization(id: ID!): Organization
  pendingOrganizationApplication: OrganizationApplication
    @deprecated(reason: "Use pendingOrganizationApplications instead.")
  pendingOrganizationApplications: [OrganizationApplication!]
  personalSections(input: PersonalSectionInput!): [PersonalSection!]
  poll(id: ID!): Poll
  predictionEvent(id: ID!): PredictionEvent
  primeOffers(
    dateOverride: Time
    countryCode: String
    locale: String
  ): [PrimeOffer!]!
  primeOffersWithEligibility(
    dateOverride: Time
    countryCode: String
    locale: String
  ): [PrimeOfferWithEligibility!]!
  primeOffersWithoutEligibility(
    dateOverride: Time
    countryCode: String
    locale: String
  ): [PrimeOffer!]!
  primePromotions(ids: [ID!], dateOverride: Time): [PrimePromotion]!
  primeVideoBenefit(accessToken: String!): PrimeVideoBenefit
  purchasableOffer(params: PurchasableOfferParams!): Offer
  radioContent(contentType: RadioContentType!, id: ID): RadioContent
    @deprecated(reason: "Use specific user.radio queries instead.")
  recommendedGames(
    first: Int = 6
    recRequestID: ID!
    location: String!
    context: RecommendationsContext!
  ): RecommendedGamesConnection
  recommendedStreams(
    first: Int = 6
    recRequestID: ID!
    location: String!
    context: RecommendationsContext!
    filters: StreamRecommendationsFilters
  ): RecommendedStreamsConnection
  recurlyConfigs(paymentSession: PaymentSession): RecurlyConfigs
  rejectedChatMessage(id: ID!): RejectedChatMessage
  reportReasons(content: ReportContentType!): [ReportReason!]
  reportToSAndCountryReasons(
    content: ReportContentType!
  ): ReportToSAndCountryReasons
  requestInfo: RequestInfo!
  room(id: ID!): Room
  scheduleSegment(id: ID!, options: ScheduleSegmentOptions): ScheduleSegment
  search(
    userQuery: String!
    platform: String!
    options: SearchOptions
  ): SearchResult @deprecated(reason: "Use the 'searchFor' query instead.")
  searchApplicableTags(userQuery: String!, limit: Int = 15): [Tag!]
  searchCategories(
    query: String!
    first: Int = 25
    after: Cursor
  ): SearchCategoriesConnection
  searchCategoryTags(userQuery: String!, limit: Int = 15): [Tag!]
  searchFor(
    userQuery: String!
    platform: String!
    options: SearchForOptions
    target: SearchForTarget
    requestID: ID
  ): SearchFor
  searchLiveTags(userQuery: String!, categoryID: ID, limit: Int = 15): [Tag!]
  searchStreams(
    userQuery: String!
    first: Int = 25
    after: Cursor
  ): SearchStreamConnection
  searchSuggestions(
    queryFragment: String!
    requestID: ID
  ): SearchSuggestionConnection
  searchUsers(
    userQuery: String!
    hasSubscriptionProductsOnly: Boolean
    first: Int = 25
    after: Cursor
  ): SearchUserConnection
  shelves(
    requestID: String!
    platform: String!
    langWeightedCCU: Boolean
    first: Int
    itemsPerRow: Int = 12
    context: RecommendationsContext
  ): ShelfConnection
  shortVideoFeed(
    first: Int = 3
    after: Cursor
    options: ShortVideoFeedOptions
  ): ShortVideoFeedConnection @deprecated
  shouldShowDevsiteCSAT: Boolean
  squadStream(id: ID!): SquadStream
  streamPlaybackAccessToken(
    channelName: String!
    params: PlaybackAccessTokenParams!
  ): PlaybackAccessToken
  streams(
    first: Int = 10
    after: Cursor
    options: StreamOptions
    platformType: PlatformType = all
    languages: [Language!]
    input: StreamMetadataFilterInput
    tags: [String!]
  ): StreamConnection
  subscriptionProduct(productName: String!): SubscriptionProduct
  subscriptionTokenBundleProducts(
    countryCode: String
    channelID: ID
  ): [SubscriptionTokenBundleProduct!]
  subscriptionTokenProductConfig: SubscriptionTokenProductConfig
  supportedCloudBroadcastProviders: [CloudBroadcastProviderKey!]
  supportedHeroAssets: [HeroAsset!]!
  supportedVerticals(
    recommendationsContext: RecommendationsContext!
  ): [VerticalDirectory!]
  team(name: String!): Team
  topTags(limit: Int = 5): [Tag!]
  urlMetadata(url: String!): URLMetadata
  user(id: ID, login: String, lookupType: UserLookupType = ACTIVE): User
  userByAttribute(input: UserByAttribute!): User
  userEmoteSettings(userID: ID!): EmoteSettings
  userResultByID(id: ID!): UserResult
  userResultByLogin(login: String!): UserResult
  users(ids: [ID!], logins: [String!]): [User]
  verificationRequest(opaqueID: ID!): VerificationRequest
  verticalDirectory(
    id: ID!
    recommendationsContext: RecommendationsContext!
    contentMin: Int!
    contentMax: Int!
  ): VerticalDirectory
  verticalSubDirectory(
    id: ID!
    contentContext: VerticalSubDirectoryContentContext
    recommendationsContext: RecommendationsContext!
    contentMin: Int!
    contentMax: Int!
  ): VerticalSubDirectory
  video(id: ID, options: VideoOptions): Video
  videoComments(
    first: Int
    after: Cursor
    last: Int
    Before: Cursor
    id: String
    videoID: String
    channelID: String
  ): VideoCommentConnection
  videoIngestSession(
    id: ID!
    channelID: ID!
    customerID: ID
  ): VideoIngestSession
  videoIngestSessionLatest(
    channelID: ID!
    customerID: ID
    secondsAgo: Int!
  ): VideoIngestSession
  videoIngestSessions(
    channelID: ID!
    customerID: ID
    startedAt: Time!
    endedAt: Time!
  ): [VideoIngestSession!]
  videoPlaybackAccessToken(
    id: ID!
    params: PlaybackAccessTokenParams!
  ): PlaybackAccessToken
  videos(
    first: Int = 10
    after: Cursor
    broadcastType: BroadcastType
    language: Language
  ): VideoConnection
  watchPartyItems(
    first: Int = 20
    after: Cursor
    accessToken: String
    options: WatchPartyItemSearchOptions
  ): WatchPartyItemConnection
  whisperThread(id: ID): WhisperThread
}

type QuestEvaluationInterval {
  durationInDays: Int!
  endTime: Time!
  startTime: Time!
}

type QuestGoalFloat {
  current: Float!
  goal: Float!
}

type QuestGoalInt {
  current: Int!
  goal: Int!
}

type Quests {
  buildACommunity: BuildACommunity
  itBegins: ItBegins
  pathToAffiliate: PathToAffiliate
  pathToPartner: PathToPartner
}

type Radio {
  account: RadioAccount!
  currentlyPlaying: RadioCurrentlyPlaying!
    @deprecated(reason: "Use 'currentRadioTrack' in 'channel' instead.")
  playlist(id: ID!): RadioPlaylist
  playlists(filter: RadioPlaylistFilter): [RadioPlaylist!]!
  recentlyPlayed(filter: RadioRecentlyPlayedFilter): [RadioRecentlyPlayed!]!
  station(id: ID!, pageToken: String, numberOfTracks: Int): RadioStation
  stations: [RadioStation!]!
}

type RadioAccount {
  customerID: ID!
  deviceID: ID!
  musicTerritory: String!
  amazonAccessToken: String!
  tokenExpiresAt: Time!
}

type RadioAlbum {
  id: ID!
  imageURL: String!
  name: String!
}

type RadioArtist {
  channel: Channel
  creatorChannelID: ID
  id: ID!
  name: String!
}

type RadioContent {
  items: [RadioContentItem!]
}

union RadioContentItem = RadioPlaylist | RadioRecentlyPlayed
type RadioContentPromotion {
  buttonText: String!
  icon(format: RadioIconFormat = SVG): RadioIconThemeAssets!
  iconURL(format: RadioIconFormat = SVG): String!
    @deprecated(reason: "Use 'icon' instead.")
  rank: Int!
  title: String!
  url: String!
}

enum RadioContentType {
  PLAYLIST
  RECENTLY_PLAYED
}

type RadioCurrentlyPlaying {
  contentPromotions: [RadioContentPromotion!]
  isCurrentlyPlaying: Boolean!
  track: RadioTrack
}

enum RadioCurrentlyPlayingType {
  PLAYLIST
  STATION
}

type RadioCurrentTrackResponse {
  isSuccess: Boolean!
}

enum RadioIconFormat {
  PNG
  SVG
}

type RadioIconThemeAssets {
  darkURL: String!
  lightURL: String!
}

type RadioPlaylist {
  curator: String!
  description: String!
  id: ID!
  imageURL: String!
  isFeatured: Boolean!
  title: String!
  tracks: [RadioTrack!]
}

enum RadioPlaylistFilter {
  ALL
  FEATURED
}

type RadioRecentlyPlayed {
  contentType: RadioRecentlyPlayedType!
  id: ID!
  playlist: RadioPlaylist
  station: RadioStation
  updatedAt: Time!
}

enum RadioRecentlyPlayedFilter {
  ALL
  PLAYLISTS
}

enum RadioRecentlyPlayedType {
  PLAYLIST
  STATION
}

type RadioStation {
  id: ID!
  imageURL: String!
  isFeatured: Boolean!
  pageToken: String
  title: String!
  tracks: [RadioTrack!]
}

type RadioTrack {
  album: RadioAlbum!
  artists: [RadioArtist!]!
  duration: Int!
  genre: String!
  id: ID!
  isrc: String!
  title: String!
}

type Raid {
  announceAt: Time
  goAt: Time
  id: ID!
  sourceChannel: User
  targetChannel: User
  viewerCount: Int
}

type RaidSettings {
  incomingRaidsPolicy: IncomingRaidsPolicy!
}

type Range {
  max: Int!
  min: Int!
}

enum RateExtensionError {
  INTERNAL_ERROR
}

input RateExtensionInput {
  extensionClientID: ID!
  extensionVersion: String!
  isRecommended: Boolean!
  location: ExtensionRatingLocation!
  userID: ID!
}

type RateExtensionPayload {
  error: RateExtensionError
  rating: ExtensionRating
}

union ReactableContent = Clip | Post | Stream | Video
type Reaction {
  count: Int!
  emote: Emote!
  self: ReactionSelfConnection!
}

type ReactionSelfConnection {
  hasReacted: Boolean!
}

input ReadNotificationsInput {
  ids: [ID!]!
}

type ReadNotificationsPayload {
  count: Int!
  notifications: [OnsiteNotification]!
}

type RecommendationFeedback {
  category: RecommendationFeedbackCategory!
  content: RecommendationFeedbackContent
  id: ID!
  lastUpdated: Time!
  type: RecommendationFeedbackType!
  user: User
}

enum RecommendationFeedbackCategory {
  UNSPECIFIED
  NOT_INTERESTED
  OFFENSIVE
  ALREADY_WATCHED
  OTHER
}

type RecommendationFeedbackConnection {
  edges: [RecommendationFeedbackEdge!]
  pageInfo: PageInfo!
}

union RecommendationFeedbackContent = Channel | Game | Video
type RecommendationFeedbackEdge {
  cursor: Cursor!
  node: RecommendationFeedback
}

enum RecommendationFeedbackType {
  UNSPECIFIED
  CHANNEL
  CATEGORY
  SHELF
  VOD
}

type Recommendations {
  communityGiftQuantities(trackingID: ID!): [Int!]
  friends: [RecommendedFriend]
  liveRecommendations(
    first: Int = 10
    recRequestID: String!
    language: String!
    location: String
    context: RecommendationsContext
  ): LiveRecommendationConnection
  streams(first: Int = 10): RecommendedStreamConnection
    @deprecated(reason: "use a specific recommendation instead")
  videos(first: Int = 10, after: Cursor): RecommendedVideoConnection
    @deprecated(reason: "this feature has been sunset")
}

input RecommendationsContext {
  appWindowHeight: Int
  appWindowWidth: Int
  clientApp: String
  country: String
  location: String
  platform: String
  referrerDomain: String
  viewportHeight: Int
  viewportWidth: Int
}

type RecommendedFriend {
  reason: String
  user: User
}

type RecommendedGamesConnection {
  edges: [RecommendedGamesEdge!]
  generationID: ID!
  pageInfo: PageInfo!
  responseID: ID!
}

type RecommendedGamesEdge {
  cursor: Cursor!
  node: Game
  trackingID: ID!
}

interface RecommendedStream {
  stream: Stream
  type: StreamRecommendationType
}

type RecommendedStreamConnection {
  nodes: [RecommendedStream] @deprecated(reason: "This field has been sunset")
}

type RecommendedStreamsConnection {
  edges: [RecommendedStreamsEdge!]
  generationID: ID!
  pageInfo: PageInfo!
  responseID: ID!
}

type RecommendedStreamsEdge {
  cursor: Cursor!
  node: Stream
  trackingID: ID!
}

type RecommendedVideoConnection {
  edges: [RecommendedVideoEdge]
  pageInfo: PageInfo
  setID: String
}

type RecommendedVideoEdge {
  cursor: Cursor
  node: Video
}

type RecordAdEventError {
  code: RecordAdEventErrorCode!
}

enum RecordAdEventErrorCode {
  INVALID_TOKEN
  INVALID_JSON
  UNKNOWN_ERROR
}

input RecordAdEventInput {
  eventName: String!
  eventPayload: String!
  radToken: String!
}

type RecordAdEventPayload {
  error: RecordAdEventError
}

type RecurlyConfigs {
  braintreeClientAuthorization: String!
  payWithAmazonConfigs: PayWithAmazonConfigs!
  publicKey: String!
}

type RecurringPaymentDetail {
  expiresAt: Time
  productType: SubscriptionProductType!
  renewalCurrency: String
  renewalPrice: Int
  renewalPriceDivisor: Int
  subscriptionBenefit: SubscriptionBenefit
  ticketOwnerID: ID
  ticketProductOwnerID: ID
  willRenew: Boolean!
}

type RedeemClaimableError {
  code: RedeemClaimableErrorCode!
}

enum RedeemClaimableErrorCode {
  REQUEST_THROTTLED
  UNAUTHORIZED
  ALREADY_CLAIMED
  UNKNOWN
  INVALID_PIN
  ALREADY_REDEEMED
  EXCEEDED_WALLET_BALANCE
  TWO_FACTOR_REQUIRED
  INVALID_COUNTRY_OF_RESIDENCE
  EXCEEDED_VELOCITY_LIMIT
}

input RedeemClaimableInput {
  countryOfResidence: String
  keyCode: String!
}

type RedeemClaimablePayload {
  error: RedeemClaimableError
  key: Claimable
}

type RedeemCommunityPointsCustomRewardError {
  code: RedeemCommunityPointsCustomRewardErrorCode
}

enum RedeemCommunityPointsCustomRewardErrorCode {
  NOT_FOUND
  FORBIDDEN
  NOT_ENOUGH_POINTS
  PROPERTIES_MISMATCH
  DUPLICATE_TRANSACTION
  TRANSACTION_IN_PROGRESS
  DISABLED
  STREAM_NOT_LIVE
  MAX_PER_STREAM
  USER_BANNED
  CHANNEL_SETTINGS
  MESSAGE_IS_COMMAND
  UNKNOWN
  MAX_PER_USER_PER_STREAM
  GLOBAL_COOLDOWN
}

input RedeemCommunityPointsCustomRewardInput {
  channelID: ID!
  cost: Int!
  prompt: String
  rewardID: ID!
  textInput: String
  title: String!
  transactionID: ID!
}

type RedeemCommunityPointsCustomRewardPayload {
  error: RedeemCommunityPointsCustomRewardError
  redemption: CommunityPointsCustomRewardRedemption
}

input RedeemCreatorGiftsInput {
  amount: Int!
}

type RedeemCreatorGiftsPayload {
  creatorGifting: CreatorGifting
}

type RedeemRitualTokenError {
  code: RedeemRitualTokenErrorCode!
}

enum RedeemRitualTokenErrorCode {
  TOKEN_NOT_AVAILABLE
  TOKEN_NOT_FOUND
  FOLLOWER_ONLY_MODE_ENFORCEMENT_FAILED
  SUB_ONLY_MODE_ENFORCEMENT_FAILED
  USER_CHAT_BANNED
  USER_CHAT_TIMED_OUT
}

input RedeemRitualTokenInput {
  channelID: ID!
  messageText: String
  type: RitualTokenType!
}

type RedeemRitualTokenPayload {
  error: RedeemRitualTokenError
  token: RitualToken
}

input RedeemSubscriptionInput {
  fromChannelID: ID!
  targetChannelID: ID!
  userID: ID!
}

type RedeemSubscriptionPayload {
  errorCode: RedeemSubscriptionResponseErrorCode
  product: SubscriptionProduct
}

enum RedeemSubscriptionResponseErrorCode {
  INVALID_CHANNEL
  NOT_ELIGIBLE
  UNKNOWN
  USER_HAS_REDEEMED_SUBSCRIPTION
  CHANNEL_NOT_OFF_BOARDED
  USER_HAS_EXISTING_SUBSCRIPTION
  REDEEM_CHANNEL_INVALID
  USER_NOT_SUBSCRIBED_TO_OFF_BOARDED_CHANNEL
}

input RedeemTrueXAdInput {
  args: String!
  signature: String!
  targetID: ID
  trueXAd: TrueXAd
}

type RedeemTrueXAdPayload {
  currentUser: User
  grantedBits: Int!
}

enum ReferralsDimension {
  PLATFORM
  COUNTRY
  CHANNEL
  INTERNAL
  EXTERNAL
}

enum ReferralsFilter {
  ALL
  EXTERNAL_LIVE_WEB
  INTERNAL_CHANNEL_LIVE_WEB
  INTERNAL_LIVE_WEB
}

input RefreshExtensionTokenInput {
  channelID: ID!
  extensionID: ID!
  jwt: String
}

type RefreshExtensionTokenPayload {
  error: String
  token: ExtensionToken
}

input RegenerateStreamKeyInput {
  channelID: ID!
}

type RegenerateStreamKeyPayload {
  channel: Channel
}

input RegenerateVerificationCodeInput {
  address: String!
  key: String!
}

type RegenerateVerificationCodePayload {
  request: VerificationRequest
}

type RegisterPayoutInformationError {
  code: RegisterPayoutInformationErrorCode!
  invalidFields: [RegisterPayoutInformationFieldName!]
}

enum RegisterPayoutInformationErrorCode {
  UNAUTHENTICATED
  FORBIDDEN
  INVALID_FORMAT
  INTERNAL_ERROR
}

enum RegisterPayoutInformationFieldName {
  BIRTHDATE
  CITY
  COMPANY_NAME
  COUNTRY_CODE
  EMAIL
  FIRST_NAME
  LAST_NAME
  MIDDLE_NAME
  POSTAL
  STATE_CODE
  STREET_ADDRESS
  STREET_ADDRESS_2
  PARENT_NAME
  PARENT_EMAIL
}

input RegisterPayoutInformationInput {
  birthdate: Time!
  city: String!
  companyName: String
  countryCode: String!
  email: String!
  firstName: String!
  lastName: String!
  middleName: String
  parentEmail: String
  parentName: String
  postal: String
  stateCode: String
  streetAddress: String!
  streetAddress2: String
  targetUserID: ID!
}

type RegisterPayoutInformationPayload {
  error: RegisterPayoutInformationError
  workflow: PayoutOnboardingWorkflow
}

type RegisterTwoFactorConfirmationError {
  code: RegisterTwoFactorConfirmationErrorCode!
  message: String!
}

enum RegisterTwoFactorConfirmationErrorCode {
  REAUTH_NEEDED
  REGISTRATION_NOT_STARTED
  INVALID_OTP
  MISSING_OTP
  LIMIT_REACHED
  EMAIL_NOT_VERIFIED
  UNKNOWN_ERROR
}

input RegisterTwoFactorConfirmationInput {
  oneTimePassword: String!
  userID: ID!
}

type RegisterTwoFactorConfirmationPayload {
  accessToken: String
  isTwoFactorAccountShared: Boolean
  error: RegisterTwoFactorConfirmationError
}

type RegisterTwoFactorError {
  code: RegisterTwoFactorErrorCode!
  message: String!
}

enum RegisterTwoFactorErrorCode {
  REAUTH_NEEDED
  MISSING_PHONE_NUMBER
  INVALID_PHONE_NUMBER
  REQUEST_THROTTLED
  EMAIL_NOT_VERIFIED
  UNKNOWN_ERROR
}

input RegisterTwoFactorInput {
  phoneNumber: String!
  userID: ID!
}

type RegisterTwoFactorPayload {
  error: RegisterTwoFactorError
}

enum RegistrationType {
  OPEN
  INVITATIONAL
  FOLLOWERS
  SUBSCRIBERS
  FOLLOWER_AND_SUBSCRIBERS
  UNKNOWN
}

type RejectedChatMessage {
  body: String
  failedFragments: [String]
  id: ID
  isResolved: Boolean @deprecated(reason: "Use status field instead")
  message: Message
  sender: User
  status: CaughtMessageStatus!
  target: User
}

input RejectFriendRequestInput {
  targetID: ID!
}

type RejectFriendRequestPayload {
  user: User
}

type RejectSquadStreamInvitationError {
  code: RejectSquadStreamInvitationErrorCode!
}

enum RejectSquadStreamInvitationErrorCode {
  INVITATION_NOT_FOUND
  SQUAD_NOT_FOUND
  UNAUTHORIZED
  INVITATION_CANNOT_BE_REJECTED
}

input RejectSquadStreamInvitationInput {
  invitationID: ID!
}

type RejectSquadStreamInvitationPayload {
  error: RejectSquadStreamInvitationError
  invitation: SquadStreamInvitation
}

type RejectSquadStreamOutOfNetworkInvitationsError {
  code: RejectSquadStreamOutOfNetworkInvitationsErrorCode!
}

enum RejectSquadStreamOutOfNetworkInvitationsErrorCode {
  UNAUTHORIZED
}

input RejectSquadStreamOutOfNetworkInvitationsInput {
  recipientID: ID!
}

type RejectSquadStreamOutOfNetworkInvitationsPayload {
  error: RejectSquadStreamOutOfNetworkInvitationsError
}

input RemoveAutohostChannelsInput {
  channelIDs: [ID!]!
  userID: ID!
}

type RemoveAutohostChannelsPayload {
  user: User
}

input RemoveCollectionItemInput {
  collectionID: ID!
  itemID: ID!
  itemType: String!
}

type RemoveCollectionItemPayload {
  collection: Collection
}

input RemoveCompetitionPhaseInput {
  competitionID: ID!
  phaseID: ID!
}

type RemoveCompetitionPhasePayload {
  competition: Competition
  error: CompetitionError
}

input RemoveCompetitionPlayerInput {
  competitionID: ID!
  userID: ID!
}

type RemoveCompetitionPlayerPayload {
  competition: Competition
  error: CompetitionError
}

input RemoveCompetitionTeamInput {
  competitionID: ID!
  teamID: ID!
}

type RemoveCompetitionTeamPayload {
  competition: Competition
  error: CompetitionError
}

type RemoveEditorError {
  code: RemoveEditorErrorCode!
}

enum RemoveEditorErrorCode {
  CHANNEL_NOT_FOUND
  TARGET_USER_NOT_FOUND
}

input RemoveEditorInput {
  channelID: ID!
  targetUserID: ID
  targetUserLogin: String
}

type RemoveEditorPayload {
  channel: User
  error: RemoveEditorError
  targetUser: User
}

type RemoveEmoteFromGroupError {
  code: RemoveEmoteFromGroupErrorCode!
}

enum RemoveEmoteFromGroupErrorCode {
  EMOTE_NOT_FOUND
  PERMISSION_DENIED
  UNKNOWN
}

input RemoveEmoteFromGroupInput {
  emoteID: ID!
}

type RemoveEmoteFromGroupPayload {
  emote: Emote
  error: RemoveEmoteFromGroupError
}

type RemoveOrganizationMemberError {
  code: RemoveOrganizationMemberErrorCode!
}

enum RemoveOrganizationMemberErrorCode {
  PERMISSION_DENIED
  USER_NOT_FOUND
  ASSIGNED_BILLING_MANAGER
  INTERNAL_ERROR
}

input RemoveOrganizationMemberInput {
  organizationID: ID!
  userID: ID!
}

type RemoveOrganizationMemberPayload {
  error: RemoveOrganizationMemberError
  targetUser: User
}

input RemoveReactionInput {
  emoteID: ID!
  entityID: ID!
}

type RemoveReactionPayload {
  content: ReactableContent!
}

type RemoveSquadStreamMemberError {
  code: RemoveSquadStreamMemberErrorCode!
}

enum RemoveSquadStreamMemberErrorCode {
  UNAUTHORIZED
  USER_NOT_IN_SQUAD
}

input RemoveSquadStreamMemberInput {
  memberUserID: ID!
  squadStreamID: ID!
}

type RemoveSquadStreamMemberPayload {
  error: RemoveSquadStreamMemberError
  squadStream: SquadStream
}

input RemoveStuccoInput {
  channelID: ID!
  stuccoID: ID!
}

type RemoveStuccoPayload {
  stuccos: [Stucco!]
}

enum RenewalPolicy {
  NO_RENEW
  AUTO_RENEW
  UNKNOWN
}

input ReorderCollectionItemInput {
  collectionID: ID!
  itemID: ID!
  itemType: String!
  position: Int!
}

type ReorderCollectionItemPayload {
  collection: Collection
}

input ReportContentInput {
  content: ReportContentType!
  contentID: ID!
  description: String!
  extra: String!
  netzDGArgs: ReportContentNetzDGInput
  reason: ID!
  targetID: ID!
  wizardPath: [String!]
}

enum ReportContentNetzDGContentDirectedTo {
  ME
  SOMEONE_I_REPRESENT
  SOMEONE_ELSE
}

input ReportContentNetzDGInput {
  contentDirectedTo: ReportContentNetzDGContentDirectedTo!
  reporterEmail: String!
  reportingFor: ReportContentNetzDGReportingFor!
}

enum ReportContentNetzDGReportingFor {
  MYSELF
  COMPLAINTS_OFFICE
  GOVERNMENT_AGENCY
}

type ReportContentPayload {
  content: ReportContentType!
  contentID: ID!
}

enum ReportContentType {
  CHANNEL_FEED_COMMENT_REPORT
  CHANNEL_FEED_POST_REPORT
  CHAT_REPORT
  CHANNEL_POINTS_REPORT
  CLIP_REPORT
  COLLECTION_REPORT
  CURSE_PRIVATE_GROUP
  CURSE_PUBLIC_GROUP
  CURSE_WHISPER
  EMOTE_REPORT
  EVENT_REPORT
  EXTENSION_REPORT
  LIVE_UP_REPORT
  LIVESTREAM_REPORT
  POLL_REPORT
  RAID_REPORT
  REWARD_REDEMPTION_REPORT
  ROOM_REPORT
  SINGS_GROUP_NAME_REPORT
  SINGS_GROUP_BIO_REPORT
  SINGS_GROUP_CHAT_REPORT
  SINGS_VOD_COMMENT_REPORT
  SINGS_DUET_SEED_REPORT
  UNBAN_REQUEST_REPORT
  USER_REPORT
  VOD_COMMENT_REPORT
  VOD_REPORT
  WHISPER_REPORT @deprecated(reason: "use whisperReport mutation instead.")
}

input ReportedContent {
  url: String!
  type: ReportedContentType!
  broadcastTime: Time
  timestamps: [CopyrightTimeOffset!]
}

enum ReportedContentType {
  ONGOING_LIVESTREAM
  PAST_LIVESTREAM
  VOD
  CLIP
  OTHER
}

type ReportReason {
  id: ID!
  isApplicableToCountryRegulations: Boolean!
  text: String!
}

type ReportToSAndCountryReasons {
  countryCode: String
  disclosureText: String
  toSAndCountryReasons: [ReportReason!]!
}

enum ReportWhisperErrorReason {
  INVALID_USER_ID
  NO_WHISPERS_FROM_TARGET_USER
  RATE_LIMITED
  UNAUTHORIZED
  UNKNOWN
}

input ReportWhisperInput {
  description: String!
  reason: String!
  targetID: ID!
  wizardPath: [String!]
}

type ReportWhisperPayload {
  error: ReportWhisperPayloadError
}

type ReportWhisperPayloadError {
  reason: ReportWhisperErrorReason!
}

input ReportWhisperThreadInput {
  reason: String
  targetUserID: ID!
  threadID: ID!
}

type ReportWhisperThreadPayload {
  thread: WhisperThread!
}

type RequestInfo {
  countryCode: String!
  fromEU: Boolean!
  ipAddress: String
  isFromEEA: Boolean!
}

type RequestRitualTokenError {
  code: RequestRitualTokenErrorCode!
}

enum RequestRitualTokenErrorCode {
  TOKEN_NOT_AVAILABLE
  TOKEN_NOT_FOUND
}

input RequestRitualTokenInput {
  channelID: ID!
  type: RitualTokenType!
}

type RequestRitualTokenPayload {
  error: RequestRitualTokenError
  token: RitualToken
}

input ResendVerificationEmailInput {
  userID: ID!
}

type ResendVerificationEmailPayload {
  user: User
}

type ResetUsernameCodeError {
  code: ResetUsernameErrorCode!
}

enum ResetUsernameErrorCode {
  TOKEN_INVALID
  REQUESTS_THROTTLED
  LOGIN_UNAVAILABLE
  LOGIN_TOO_SHORT
  LOGIN_TOO_LONG
  LOGIN_CONTAINS_INVALID_CHARACTERS
  UNKNOWN_ERROR
}

input ResetUsernameInput {
  login: String!
  resetUsernameToken: String!
}

type ResetUsernamePayload {
  error: ResetUsernameCodeError
  login: String
}

type ResolvePredictionEventError {
  code: ResolvePredictionEventErrorCode!
}

enum ResolvePredictionEventErrorCode {
  FORBIDDEN
  EVENT_ENDED
  UNKNOWN
}

input ResolvePredictionEventInput {
  eventID: ID!
  outcomeID: ID!
}

type ResolvePredictionEventPayload {
  error: ResolvePredictionEventError
  predictionEvent: PredictionEvent
}

type ResourceRestriction {
  exemptions: [ResourceRestrictionExemption!]
  id: ID!
  options: [ResourceRestrictionOption!]!
  type: ResourceRestrictionType!
}

type ResourceRestrictionExemption {
  actions: [ResourceRestrictionExemptionAction!]
  endsAt: Time
  keys: [String!]
  startsAt: Time
  type: ResourceRestrictionExemptionType!
}

type ResourceRestrictionExemptionAction {
  name: String!
  title: String!
}

enum ResourceRestrictionExemptionType {
  UNKNOWN
  ALL
  STAFF
  SITE_ADMIN
  PRODUCT
  ORGANIZATION_MEMBER
  PREVIEW
  CHANNEL_MODERATOR
  CHANNEL_VIP
}

enum ResourceRestrictionOption {
  ALLOW_CHANNEL_VIP
  ALLOW_CHANNEL_MODERATOR
  ALLOW_TIER_3_ONLY
  ALLOW_TIER_2_AND_3_ONLY
  ALLOW_ALL_TIERS
}

enum ResourceRestrictionType {
  UNKNOWN
  SUB_ONLY_LIVE
  ALL_ACCESS_PASS
  ORGANIZATION_ACCESS_ONLY
}

input RespondToTeamInvitationInput {
  accepted: Boolean!
  teamID: ID!
  userID: ID!
}

type RespondToTeamInvitationPayload {
  user: User
}

enum RestrictionResource {
  VIDEO
  LIVE
}

type ResubNotification {
  cumulativeTenureMonths: Int!
  id: ID!
  months: Int!
  streakTenureMonths: Int!
  token: String!
  isGiftSubscription: Boolean!
  gifter: User
}

enum ResumeScheduleError {
  PERMISSION_DENIED
  NOT_FOUND
}

input ResumeScheduleInput {
  scheduleID: ID!
}

type ResumeSchedulePayload {
  error: ResumeScheduleError
  schedule: Schedule
}

type RevenueConfig {
  id: ID!
  splitPercent: Int!
  startAt: Time
}

type RevokeVIPError {
  code: RevokeVIPErrorCode!
}

enum RevokeVIPErrorCode {
  CHANNEL_NOT_FOUND
  FORBIDDEN
  REVOKEE_NOT_FOUND
  REVOKEE_NOT_VIP
}

input RevokeVIPInput {
  channelID: ID!
  revokeeID: ID
  revokeeLogin: String
}

type RevokeVIPPayload {
  channel: User
  error: RevokeVIPError
  revokee: User
}

type RewardedVideo {
  isEligible: Boolean!
  shouldCaptcha: Boolean!
}

type RichOEmbed implements OEmbed {
  authorName: String
  authorURL: String
  cacheAge: Int
  height: Int!
  html: String!
  inputURL: String!
  providerName: String
  providerURL: String
  thumbnail: ThumbnailOEmbed
  title: String
  type: String!
  version: String!
  width: Int!
}

type RitualToken {
  channel: User
  expiresAt: Time
  id: ID!
  status: RitualTokenStatus
  type: RitualTokenType
  user: User
}

enum RitualTokenStatus {
  ELIGIBLE
  AVAILABLE
  DISMISSED
  REDEEMED
}

enum RitualTokenType {
  NEW_CHATTER
}

type Room {
  id: ID! @deprecated(reason: "The Rooms product has been sunset")
  isPreviewable: Boolean!
    @deprecated(reason: "The Rooms product has been sunset")
  members(first: Int = 100, after: Cursor): RoomMemberConnection
    @deprecated(reason: "The Rooms product has been sunset")
  messages(
    first: Int
    after: Cursor
    last: Int
    before: Cursor
    fromTime: Time
  ): RoomMessageConnection
    @deprecated(reason: "The Rooms product has been sunset")
  minimumAllowedRole: RoomRole!
    @deprecated(reason: "The Rooms product has been sunset")
  modes: RoomModes @deprecated(reason: "The Rooms product has been sunset")
  name: String! @deprecated(reason: "The Rooms product has been sunset")
  owner: User! @deprecated(reason: "The Rooms product has been sunset")
  rolePermissions: RoomRolePermissions
    @deprecated(reason: "The Rooms product has been sunset")
  self: RoomView @deprecated(reason: "The Rooms product has been sunset")
  topic: String @deprecated(reason: "The Rooms product has been sunset")
}

type RoomMemberConnection {
  edges: [RoomMemberEdge]!
    @deprecated(reason: "The Rooms product has been sunset")
  pageInfo: PageInfo! @deprecated(reason: "The Rooms product has been sunset")
}

type RoomMemberEdge {
  cursor: Cursor! @deprecated(reason: "The Rooms product has been sunset")
  node: User @deprecated(reason: "The Rooms product has been sunset")
  type: RoomMemberType! @deprecated(reason: "The Rooms product has been sunset")
}

enum RoomMemberType {
  BROADCASTER @deprecated(reason: "The Rooms product has been sunset")
  STAFF @deprecated(reason: "The Rooms product has been sunset")
  ADMIN @deprecated(reason: "The Rooms product has been sunset")
  GLOBALMOD @deprecated(reason: "The Rooms product has been sunset")
  MOD @deprecated(reason: "The Rooms product has been sunset")
  REGULAR @deprecated(reason: "The Rooms product has been sunset")
}

type RoomMessage {
  content: RoomMessageContent!
    @deprecated(reason: "The Rooms product has been sunset")
  deletedAt: Time @deprecated(reason: "The Rooms product has been sunset")
  id: ID! @deprecated(reason: "The Rooms product has been sunset")
  room: Room! @deprecated(reason: "The Rooms product has been sunset")
  sender: User! @deprecated(reason: "The Rooms product has been sunset")
  sentAt: Time! @deprecated(reason: "The Rooms product has been sunset")
}

type RoomMessageConnection {
  edges: [RoomMessageEdge]!
    @deprecated(reason: "The Rooms product has been sunset")
  pageInfo: PageInfo! @deprecated(reason: "The Rooms product has been sunset")
}

type RoomMessageContent {
  fragments: [RoomMessageFragment]!
    @deprecated(reason: "The Rooms product has been sunset")
  text: String! @deprecated(reason: "The Rooms product has been sunset")
}

type RoomMessageEdge {
  cursor: Cursor! @deprecated(reason: "The Rooms product has been sunset")
  node: RoomMessageItem @deprecated(reason: "The Rooms product has been sunset")
}

type RoomMessageFragment {
  content: FragmentContent
    @deprecated(reason: "The Rooms product has been sunset")
  text: String! @deprecated(reason: "The Rooms product has been sunset")
}

type RoomMessageGroupMention {
  type: RoomMessageMentionType!
    @deprecated(reason: "The Rooms product has been sunset")
}

union RoomMessageItem = RoomMessage
enum RoomMessageMentionType {
  HERE @deprecated(reason: "The Rooms product has been sunset")
}

type RoomModes {
  emotesOnlyModeEnabled: Boolean!
    @deprecated(reason: "The Rooms product has been sunset")
  r9kModeEnabled: Boolean!
    @deprecated(reason: "The Rooms product has been sunset")
  slowModeDurationSeconds: Int!
    @deprecated(reason: "The Rooms product has been sunset")
}

type RoomPermissions {
  moderate: Boolean! @deprecated(reason: "The Rooms product has been sunset")
  readMessages: Boolean!
    @deprecated(reason: "The Rooms product has been sunset")
  sendMessages: Boolean!
    @deprecated(reason: "The Rooms product has been sunset")
}

enum RoomRole {
  BROADCASTER @deprecated(reason: "The Rooms product has been sunset")
  MODERATOR @deprecated(reason: "The Rooms product has been sunset")
  SUBSCRIBER @deprecated(reason: "The Rooms product has been sunset")
  EVERYONE @deprecated(reason: "The Rooms product has been sunset")
}

type RoomRolePermissions {
  read: RoomRole! @deprecated(reason: "The Rooms product has been sunset")
  send: RoomRole! @deprecated(reason: "The Rooms product has been sunset")
}

type RoomView {
  isArchived: Boolean! @deprecated(reason: "The Rooms product has been sunset")
  isMuted: Boolean! @deprecated(reason: "The Rooms product has been sunset")
  isUnread: Boolean! @deprecated(reason: "The Rooms product has been sunset")
  lastReadAt: Time @deprecated(reason: "The Rooms product has been sunset")
  permissions: RoomPermissions
    @deprecated(reason: "The Rooms product has been sunset")
  room: Room! @deprecated(reason: "The Rooms product has been sunset")
  unreadMentionCount: Int!
    @deprecated(reason: "The Rooms product has been sunset")
}

enum RotateExtensionSecretsError {
  INVALID_CLIENT
  UNAUTHORIZED
  INVALID_DELAY
}

input RotateExtensionSecretsInput {
  delaySeconds: Int!
  extensionID: ID!
}

type RotateExtensionSecretsPayload {
  error: RotateExtensionSecretsError
  secrets: [ExtensionSecret!]
}

type ROWCookieVendor {
  consentStatus: ConsentStatus!
  hasUserSetConsent: Boolean!
  isVisible: Boolean!
  name: VendorName!
}

type ROWVendorConsent {
  status: [ROWCookieVendor!]!
}

type RTMPSession {
  audioCodecs: String!
  avcLevel: Int
  clientIP: String
  encoder: String!
  idrInterval: Int
  rtmpExitReason: String
  rtmpFlags: String!
  rtmpMetadata: String!
  segmentDurationSeconds: Int!
  videoCodecs: String!
  videoResolutionHeight: Int!
  videoResolutionWidth: Int!
}

enum RunMultiplayerAdErrorCode {
  CHANNEL_NOT_LIVE
  OFFER_EXPIRED
  OFFER_NOT_FOUND
  UNKNOWN
}

input RunMultiplayerAdsInput {
  channelID: ID!
  desiredAdDurationSeconds: Int
  offerIDs: [ID!]!
}

type RunMultiplayerAdsPayload {
  error: RunMultiplayerAdErrorCode
}

input SaveComponentViewInput {
  aspectHeight: Int
  aspectRatioX: Int!
  aspectRatioY: Int!
  aspectWidth: Int
  hasAutoscale: Boolean
  hasZoom: Boolean
  scalePixels: Int
  size: Float
  targetHeight: Int!
  viewerPath: String!
  zoomPixels: Int
}

input SaveConfigViewInput {
  viewerPath: String!
}

input SaveExtensionAssetManifestInput {
  assetHash: String!
}

input SaveExtensionCapabilitiesInput {
  bitsSupportLevel: ExtensionBitsSupportLevel = NONE
  configurationLocation: ExtensionConfigurationLocation!
  hasBitsSupport: Boolean!
  hasChatSupport: Boolean!
  requiredConfiguration: String!
  subscriptionsSupportLevel: ExtensionSubscriptionsSupportLevel
  whitelists: ExtensionWhitelistsInput!
  willRequestIdentityLink: Boolean!
}

input SaveExtensionDeveloperManifestInput {
  authorEmail: String!
  testingBaseURI: String!
}

input SaveExtensionDiscoveryManifestInput {
  authorName: String!
  categories: [ID!]!
  description: String!
  games: [ID!]!
  name: String!
  privacyPolicyURL: String!
  summary: String!
  supportEmail: String!
  termsURL: String!
  viewerSummary: String!
}

enum SaveExtensionManifestError {
  UNAUTHORIZED
  INVALID_VERSION
  ANCHOR_REQUIRED
  INVALID_ZOOM
  MAX_BROADCASTERS
  MAX_TESTERS
  MAX_WHITELISTED_CONFIG_URLS
  MAX_WHITELISTED_PANEL_URLS
  INVALID_NAME_LENGTH
  INVALID_DESCRIPTION_LENGTH
  INVALID_SUMMARY_LENGTH
  INVALID_AUTHOR_EMAIL
  INVALID_SUPPORT_EMAIL
  INVALID_AUTHOR_NAME_LENGTH
  INVALID_TESTING_BASE_URI
  INVALID_TERMS_URI
  INVALID_PRIVACY_URI
  INVALID_COMPONENT_VIEWER_PATH
  INVALID_PANEL_VIEWER_PATH
  INVALID_VIDEO_OVERLAY_VIEWER_PATH
  INVALID_CONFIG_VIEWER_PATH
  INVALID_LIVE_CONFIG_VIEWER_PATH
  INVALID_MOBILE_VIEWER_PATH
  INVALID_COMPONENT_ASPECT_WIDTH
  INVALID_COMPONENT_ASPECT_HEIGHT
  INVALID_PANEL_HEIGHT
  INVALID_BITS_SUPPORT_LEVEL
  INVALID_SCALING_PIXELS
  INVALID_COMPONENT_ASPECT_RATIO_X
  INVALID_COMPONENT_ASPECT_RATIO_Y
  INVALID_COMPONENT_TARGET_HEIGHT
  INVALID_VIEWER_SUMMARY_LENGTH
}

input SaveExtensionManifestInput {
  assetManifest: SaveExtensionAssetManifestInput!
  capabilities: SaveExtensionCapabilitiesInput!
  developerManifest: SaveExtensionDeveloperManifestInput!
  discoveryManifest: SaveExtensionDiscoveryManifestInput!
  id: ID!
  version: String!
  views: SaveExtensionViewsInput!
}

type SaveExtensionManifestPayload {
  error: SaveExtensionManifestError
  manifest: ExtensionManifest
}

input SaveExtensionViewsInput {
  component: SaveComponentViewInput
  config: SaveConfigViewInput
  liveConfig: SaveLiveConfigViewInput
  mobile: SaveMobileViewInput
  panel: SavePanelViewInput
  videoOverlay: SaveVideoOverlayViewInput
}

input SaveExtensionWhitelistsInput {
  broadcasters: [ID!]!
  configURLs: [String!]!
  panelURLs: [String!]!
  testers: [ID!]!
}

input SaveHiddenViewInput {
  viewerPath: String!
}

input SaveLiveConfigViewInput {
  viewerPath: String!
}

input SaveMobileViewInput {
  viewerPath: String!
}

input SavePanelViewInput {
  height: Int!
  viewerPath: String!
}

input SaveVideoOverlayViewInput {
  viewerPath: String!
}

type SCETitle {
  ageRating: Int
  attribute: String
  genre: String
  id: ID
  isPreset: Boolean
  language: String
  metadata: String
  name: String
  presetText: [String]
  presetTextDescription: String
  productID: String
  sessionID: String
  shortName: String
  storeURL: String
}

type SCEUser {
  country: String
  npID: ID
  onlineID: ID
}

type Schedule {
  id: ID!
  interruption: ScheduleInterruption
  nextSegment: ScheduleSegment
  segmentList(
    first: Int = 10
    after: Cursor
    options: ScheduleSegmentListInput
  ): ScheduleSegmentListConnection
  segments(
    utcOffsetMinutes: Int
    startingWeekday: String
    relativeDate: Time
    includeFutureSegments: Boolean
  ): [ScheduleSegment!]
}

type ScheduleInterruption {
  endAt: Time!
  reason: ScheduleInterruptionReason!
  startAt: Time!
}

enum ScheduleInterruptionReason {
  VACATION
  OTHER
}

type ScheduleSegment {
  cancelledUntil: Time
  categories: [Game!]
  channel: Channel
  endAt: Time
  firstOccurrenceDate: Time
  hasReminder: Boolean!
  id: ID!
  isCancelled: Boolean!
  reminderCount: Int
  repeatEndsAfterCount: Int
  startAt: Time!
  title: String!
}

enum ScheduleSegmentDay {
  SUNDAY
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
}

type ScheduleSegmentListConnection {
  edges: [ScheduleSegmentListEdge!]
  pageInfo: PageInfo!
}

type ScheduleSegmentListEdge {
  cursor: Cursor!
  node: ScheduleSegment!
}

input ScheduleSegmentListInput {
  ignoreInProgress: Boolean
  startTime: Time
  utcOffsetMinutes: Int
}

input ScheduleSegmentOptions {
  relativeDate: Time
  utcOffsetMinutes: Int
  startingWeekday: ScheduleSegmentDay
}

enum Scope {
  BENEFIT
  CAMPAIGN
}

type SearchCategoriesConnection {
  edges: [SearchCategoriesEdge!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SearchCategoriesEdge {
  cursor: Cursor!
  node: Game!
}

type SearchFor {
  channels: SearchForResultUsers
  games: SearchForResultGames
  liveChannels: SearchForResultUsers
  relatedLiveChannels: SearchForResultRelatedLiveChannels
  users: SearchForResultUsers
  videos: SearchForResultVideos
}

type SearchForEdge {
  item: SearchForItem!
  trackingID: ID!
}

type SearchForEdgeRelatedLiveChannels {
  item: User!
  trackingID: ID!
}

union SearchForItem = Game | User | Video
input SearchForOptions {
  targets: [SearchForTarget!]
}

type SearchForResultGames {
  cursor: String
  edges: [SearchForEdge!]!
  items: [Game!]
  pageInfo: PageInfo!
  score: Int!
  totalMatches: Int!
}

type SearchForResultRelatedLiveChannels {
  edges: [SearchForEdgeRelatedLiveChannels!]!
  items: [User!]
  score: Int
}

type SearchForResultUsers {
  cursor: String
  edges: [SearchForEdge!]!
  items: [User!]
  pageInfo: PageInfo!
  score: Int!
  totalMatches: Int!
}

type SearchForResultVideos {
  cursor: String
  edges: [SearchForEdge!]!
  items: [Video!]
  pageInfo: PageInfo!
  score: Int!
  totalMatches: Int!
}

input SearchForTarget {
  cursor: String
  index: SearchIndex!
  limit: Int
}

enum SearchIndex {
  GAME
  USER
  VOD
  LIVE
  CHANNEL
}

input SearchOptions {
  targets: [SearchTarget!]
}

type SearchResult {
  result: String!
}

type SearchStreamConnection {
  edges: [SearchStreamEdge!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SearchStreamEdge {
  cursor: Cursor!
  node: Stream!
}

type SearchSuggestion {
  content: SearchSuggestionContent
  highlight: SearchSuggestionHighlight!
    @deprecated(reason: "Use 'matchingCharacters' instead.")
  id: ID!
  matchingCharacters: SearchSuggestionHighlight
  text: String!
}

type SearchSuggestionCategory {
  boxArtURL(width: Int, height: Int): String!
  game: Game
  id: ID!
}

type SearchSuggestionChannel {
  id: ID!
  isVerified: Boolean!
  login: String!
  profileImageURL(width: Int!): String
  user: User
}

type SearchSuggestionConnection {
  edges: [SearchSuggestionEdge!]
  pageInfo: PageInfo!
  tracking: SearchSuggestionTracking
}

union SearchSuggestionContent =
    SearchSuggestionCategory
  | SearchSuggestionChannel
type SearchSuggestionEdge {
  cursor: Cursor!
  node: SearchSuggestion!
}

type SearchSuggestionHighlight {
  end: Int!
  start: Int!
}

type SearchSuggestionTracking {
  modelTrackingID: ID!
  responseID: ID!
}

input SearchTarget {
  countTotalMatches: Boolean
  index: SearchIndex!
  limit: Int!
}

type SearchUserConnection {
  edges: [SearchUserEdge!]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SearchUserEdge {
  cursor: Cursor!
  node: User!
}

type SeasonDetails {
  episodeCount: Int
  season: Int
}

input SeedCompetitionParticipantInput {
  competitionID: ID!
  participantID: ID!
  seedValue: Int!
}

type SeedCompetitionParticipantPayload {
  competition: Competition
  error: CompetitionError
}

enum SegmentsStatusType {
  COMPLETED
  NOT_ENOUGH_DATA
  IN_PROGRESS
  FAILED
}

input SegmentStartTimeInput {
  day: ScheduleSegmentDay!
  hour: Int!
  minute: Int!
}

input SelectChannelBadgeInput {
  badgeSetID: ID!
  badgeSetVersion: String
  channelID: ID!
}

type SelectChannelBadgePayload {
  isSuccessful: Boolean
  user: User
}

input SelectGlobalBadgeInput {
  badgeSetID: ID!
  badgeSetVersion: String
}

type SelectGlobalBadgePayload {
  isSuccessful: Boolean
  user: User
}

interface SelfClaimEdge {
  canClaim: Boolean!
  countryOfResidence: String
  id: ID!
  statusCode: String
}

input SendChatMessageThroughSubscriberModeInput {
  channelID: ID!
  cost: Int!
  message: String!
  transactionID: ID!
}

type SendChatMessageThroughSubscriberModePayload {
  balance: Int
  error: SendCopoMessageError
  isHeldByAutomod: Boolean
}

input SendCheerInput {
  bits: Int!
  content: String!
  id: ID!
  isAnonymous: Boolean = false
  isAutoModEnabled: Boolean
  roomID: ID
  shouldCheerAnyway: Boolean
  targetID: ID!
  imageID: ID
}

type SendCheerPayload {
  currentUser: User
  id: ID!
  validationError: SendCheerValidationError
}

type SendCheerValidationError {
  code: SendCheerValidationErrorCode!
  message: String!
  messageContent: RoomMessageContent
}

enum SendCheerValidationErrorCode {
  AMOUNT_BELOW_MIN_BITS
  AUTO_MOD_MESSAGE
  CHANNEL_INELIGIBLE
  EMOTE_AMOUNT_BELOW_MIN_BITS
  INSUFFICIENT_BALANCE
  INVALID_BITS_AMOUNT
  INVALID_BITS_MESSAGE
  INVALID_EVENT_ID
  MESSAGE_LENGTH_EXCEEDED
  REQUEST_THROTTLED
  TOO_LARGE_BITS_EMOTE
  TOO_LARGE_CHEER
  UNKNOWN
  USER_BANNED
  USER_INELIGIBLE
  USER_SUSPENDED
  ZALGO_MESSAGE
  AUTO_MOD_PENDING
  CHANNEL_BLOCKED_TERMS
  INVALID_ANONYMOUS_MESSAGE
  ANONYMOUS_CHEERMOTE_NOT_ALLOWED
}

type SendCopoMessageError {
  code: SendCopoMessageErrorCode
}

enum SendCopoMessageErrorCode {
  MSG_DUPLICATE
  USER_SUSPENDED
  USER_BANNED
  USER_TIMED_OUT
  EMOTE_ONLY
  SLOW_MODE
  FOLLOWERS_ONLY
  FOLLOWERS_ONLY_ZERO
  SUBS_ONLY
  R9K_MODE
  BLIZZARD_CONNECT_MODE
  VERIFIED_ACCOUNT
  CHANNEL_SETTINGS
  AUTOMOD_HELD @deprecated(reason: "use isHeldByAutomod on the payload instead")
  MESSAGE_REJECTED
  SERVER_ERROR
  INSUFFICIENT_POINTS
  TRANSACTION_ALREADY_COMMITTED
  TRANSACTION_IN_PROGRESS
  REWARD_COST_MISMATCH
  REWARD_DISABLED
  REWARD_FORBIDDEN
  MESSAGE_IS_COMMAND
  UNKNOWN
}

type SendExtensionMessageError {
  code: SendExtensionMessageErrorCode!
}

enum SendExtensionMessageErrorCode {
  UNAUTHORIZED
  UNKNOWN
}

input SendExtensionMessageInput {
  channelID: ID!
  contentType: String!
  extAuthToken: String!
  extensionID: ID!
  message: String!
  targets: [String!]!
}

type SendExtensionMessagePayload {
  error: SendExtensionMessageError
  rateLimitsApplied: [SendExtensionMessageThrottleData!]
}

type SendExtensionMessageThrottleData {
  isLimitExceeded: Boolean!
  limit: String!
  rateLimiterName: String!
  remainingQuota: Int!
  resetsAt: Time
}

input SendHighlightedChatMessageInput {
  channelID: ID!
  cost: Int!
  message: String!
  transactionID: ID!
}

type SendHighlightedChatMessagePayload {
  balance: Int
  error: SendCopoMessageError
  isHeldByAutomod: Boolean
}

type SendRoomMessageError {
  code: SendRoomMessageErrorCode!
  remainingDurationSeconds: Int
  slowModeDurationSeconds: Int
}

enum SendRoomMessageErrorCode {
  FORBIDDEN
  AUTO_MOD_ENFORCEMENT_FAILED
  EMOTE_ONLY_MODE_ENFORCEMENT_FAILED
  R9K_MODE_ENFORCEMENT_FAILED
  RATE_LIMIT_FAILED
  SLOW_MODE_ENFORCEMENT_FAILED
  SPAM_ENFORCEMENT_FAILED
  ZALGO_ENFORCEMENT_FAILED
  USER_CHAT_BANNED
  USER_CHAT_TIMED_OUT
  USER_SUSPENDED
}

input SendRoomMessageInput {
  message: String!
  nonce: String
  roomID: ID!
}

type SendRoomMessagePayload {
  error: SendRoomMessageError
  message: RoomMessage
}

type SendWhisperError {
  code: SendWhisperErrorCode!
}

enum SendWhisperErrorCode {
  TARGET_BANNED
  BODY_EMPTY
  TARGET_RESTRICTED
  SENDER_NOT_VERIFIED
  NOT_DELIVERED
}

input SendWhisperInput {
  message: String!
  nonce: String!
  recipientUserID: ID!
}

type SendWhisperPayload {
  error: SendWhisperError
  message: WhisperMessage
}

type SEOMetatag {
  attributes: [SEOMetatagAttribute!]!
  name: String!
}

type SEOMetatagAttribute {
  key: String!
  value: String!
}

type SeriesDetails {
  seasonCount: Int
}

input SetAutoAdDensityInput {
  autoAdLengthSeconds: Int!
  autoAdPeriodMinutes: Int!
  targetChannelID: ID!
}

type SetAutoAdDensityPayload {
  autoAdLengthSeconds: Int
  autoAdPeriodMinutes: Int
  targetChannelID: ID
}

input SetAutohostChannelsInput {
  channelIDs: [ID!]!
  userID: ID!
}

type SetAutohostChannelsPayload {
  user: User
}

input SetAutoRefillSettingsInput {
  chargeInstrument: ChargeInstrumentInput!
  currency: Currency!
  grossAmount: Int!
  id: ID
  isEnabled: Boolean!
  offerID: ID!
  threshold: Int!
}

type SetAutoRefillSettingsPayload {
  autoRefillProfile: AutoRefillProfile
}

input SetBitsUserSettingsInput {
  abandonedFirstCheerTutorial: Boolean
  skippedFirstCheerTutorial: Boolean
}

type SetBitsUserSettingsPayload {
  currentUser: User
}

input SetChannelAdScheduleInput {
  targetChannelID: ID!
  isAdScheduleEnabled: Boolean
  scheduledAdDurationPreferenceSeconds: Int
  scheduledAdIntervalPreferenceSeconds: Int
  adStartDelaySeconds: Int
  isAdReminderEnabled: Boolean
  adReminderTimeSeconds: Int
}

type SetChannelAdSchedulePayload {
  targetChannelID: ID
  isAdScheduleEnabled: Boolean
  intervalSeconds: Int
  durationSeconds: Int
  startDelaySeconds: Int
  isAdReminderEnabled: Boolean
  adReminderTimeSeconds: Int
}

input SetChannelFeedEnabledInput {
  enabled: Boolean!
}

type SetChannelFeedEnabledPayload {
  user: User!
}

input SetChannelNotificationSettingInput {
  category: String!
  channelID: ID!
  platform: String!
  settingState: String!
}

type SetChannelNotificationSettingPayload {
  settingState: String!
}

enum SetChannelTrailerErrorCode {
  UNAUTHORIZED
  VOD_TOO_LONG
}

input SetChannelTrailerInput {
  channelID: ID!
  trailerVideoID: ID
}

type SetChannelTrailerPayload {
  channel: Channel
  error: SetChannelTrailerErrorCode
}

input SetChatPauseSettingInput {
  chatPauseSetting: ChatPauseSetting!
}

type SetChatPauseSettingPayload {
  chatPauseSetting: ChatPauseSetting
}

input SetContentTagsInput {
  authorID: ID!
  contentID: ID!
  contentType: ContentType!
  tagIDs: [ID!]!
}

type SetContentTagsPayload {
  content: TaggedContent
}

input SetCreatorBadgeFlairInput {
  channelID: ID!
  creatorBadgeFlair: CreatorBadgeFlairSetting!
}

type SetCreatorBadgeFlairPayload {
  channel: Channel
}

type SetDashboardAlertQueueActivityStatusError {
  code: SetDashboardAlertQueueActivityStatusErrorCode!
}

enum SetDashboardAlertQueueActivityStatusErrorCode {
  INVALID_ACTIVITY_ID
  INVALID_ALERT_STATUS
  INVALID_CHANNEL_ID
  NOT_FOUND
}

input SetDashboardAlertQueueActivityStatusInput {
  activityID: ID!
  alertStatus: DashboardActivityFeedActivityAlertStatus!
  userID: ID!
}

type SetDashboardAlertQueueActivityStatusPayload {
  activity: DashboardActivityFeedActivity
  error: SetDashboardAlertQueueActivityStatusError
}

type SetDashboardAlertQueuePreferenceError {
  code: SetDashboardAlertQueuePreferenceErrorCode!
}

enum SetDashboardAlertQueuePreferenceErrorCode {
  INVALID_CHANNEL_ID
}

input SetDashboardAlertQueuePreferenceInput {
  shouldEnableDNDMode: Boolean
  shouldHideBits: Boolean
  shouldHideFollows: Boolean
  shouldHideGiftSubscriptions: Boolean
  shouldHideHosts: Boolean
  shouldHideRaids: Boolean
  shouldHideSubscriptions: Boolean
  userID: ID!
}

type SetDashboardAlertQueuePreferencePayload {
  error: SetDashboardAlertQueuePreferenceError
  preferences: DashboardAlertQueuePreferences
}

enum SetDefaultPaymentMethodErrorCode {
  UNAUTHENTICATED
  FORBIDDEN
  INVALID_REQUEST
  INTERNAL_ERROR
}

input SetDefaultPaymentMethodInput {
  billingCountry: String
  lastFour: String
  paymentType: PaymentInstrumentType!
  provider: PaymentProvider!
  token: String!
  userID: ID!
}

type SetDefaultPaymentMethodPayload {
  errorCode: SetDefaultPaymentMethodErrorCode
  user: User
}

input SetDeletedMessageDisplaySettingInput {
  deletedMessageDisplaySetting: DeletedMessageDisplaySetting!
}

type SetDeletedMessageDisplaySettingPayload {
  deletedMessageDisplaySetting: DeletedMessageDisplaySetting
}

input SetDropBenefitsOnDropInput {
  benefitIDs: [ID!]!
  dropID: ID!
}

type SetDropBenefitsOnDropPayload {
  dropCampaign: DropCampaign
  error: DropsError
}

input SetDropCampaignAccessInput {
  allowedChannels: [ID!]
  blockedChannels: [ID!]
  campaignID: ID!
  isAllowedChannelsEnabled: Boolean!
  isBlockedChannelsEnabled: Boolean!
  testViewers: [ID!]
}

type SetDropCampaignAccessPayload {
  dropCampaign: DropCampaign
  error: DropsError
}

input SetDropCampaignStatusInput {
  campaignID: ID!
  status: DropCampaignStatus!
}

type SetDropCampaignStatusPayload {
  dropCampaign: DropCampaign
  error: DropsError
}

input SetDropCampaignSummaryInput {
  accountLinkURL: String!
  campaignID: ID!
  campaignType: CampaignType
  description: String!
  detailsURL: String!
  endAt: Time!
  gameID: ID!
  name: String!
  ownerID: ID!
  startAt: Time!
}

type SetDropCampaignSummaryPayload {
  dropCampaign: DropCampaign
  error: DropsError
}

input SetDropEventRuleInput {
  claimDurationSeconds: Int!
  dropID: ID!
  eventRules: [DropEventConditionInput!]!
  questDescription: String!
  questName: String!
}

type SetDropEventRulePayload {
  dropCampaign: DropCampaign
  error: DropsError
}

input SetDropManualTriggerRuleInput {
  claimDurationSeconds: Int!
  dropID: ID!
}

type SetDropManualTriggerRulePayload {
  dropCampaign: DropCampaign
  error: DropsError
}

input SetDropSummaryInput {
  dropID: ID!
  endAt: Time
  name: String!
  startAt: Time
}

type SetDropSummaryPayload {
  dropCampaign: DropCampaign
  error: DropsError
}

input SetDropTimeBasedRuleInput {
  dropID: ID!
  preconditionDropID: ID!
  requiredMinutesWatched: Int!
}

type SetDropTimeBasedRulePayload {
  dropCampaign: DropCampaign
  error: DropsError
}

input SetEmoteAnimationsEnabledInput {
  isEmoteAnimationsEnabled: Boolean!
}

type SetEmoteAnimationsEnabledPayload {
  isEmoteAnimationsEnabled: Boolean
}

input SetEmoteAnimationsSettingCalloutDismissedInput {
  isEmoteAnimationsSettingCalloutDismissed: Boolean!
}

type SetEmoteAnimationsSettingCalloutDismissedPayload {
  isEmoteAnimationsSettingCalloutDismissed: Boolean
}

type SetEmoteModifierGroupsError {
  code: SetEmoteModifierGroupsErrorCode!
}

enum SetEmoteModifierGroupsErrorCode {
  INTERNAL_SERVER_ERROR
  INVALID_ARGUMENT
  USER_UNAUTHORIZED
  UNKNOWN
}

input SetEmoteModifierGroupsInput {
  groups: [EmoteModifierGroupInput!]!
}

type SetEmoteModifierGroupsPayload {
  error: SetEmoteModifierGroupsError
  groups: [EmoteModifierGroupPayload!]
}

type SetExtensionConfigurationError {
  code: SetExtensionConfigurationErrorCode!
}

enum SetExtensionConfigurationErrorCode {
  UNAUTHORIZED
  UNKNOWN
}

input SetExtensionConfigurationInput {
  channelID: ID!
  configVersion: String!
  content: String!
  extensionID: ID!
}

type SetExtensionConfigurationPayload {
  channelID: ID
  configVersion: String
  content: String
  error: SetExtensionConfigurationError
  extensionID: ID
}

type SetExtensionFeatureFlagsError {
  code: SetExtensionFeatureFlagsErrorCode!
  missingInstallationID: ID
}

enum SetExtensionFeatureFlagsErrorCode {
  UNAUTHORIZED
  INVALID_CHANNEL_ID
  EXTENSION_NOT_INSTALLED
}

input SetExtensionFeatureFlagsInput {
  canSendChat: Boolean
  canUseBits: Boolean
  dynamicManagement: [ExtensionDynamicManagementInput]
  id: ID!
}

type SetExtensionFeatureFlagsPayload {
  error: SetExtensionFeatureFlagsError
  installedExtension: ExtensionInstallation
}

input SetExtensionInstallationOAuthInput {
  id: ID!
  oauthToken: String!
}

type SetExtensionInstallationOAuthPayload {
  installedExtension: ExtensionInstallation
}

input SetGameDropAccountLinkClientInput {
  clientID: ID!
  gameID: ID!
}

type SetGameDropAccountLinkClientPayload {
  error: DropsError
  game: Game
}

type SetHeroAsAvatarError {
  code: SetHeroAsAvatarErrorCode!
}

enum SetHeroAsAvatarErrorCode {
  FORBIDDEN
  UNKNOWN_ERROR
}

input SetHeroAsAvatarInput {
  heroID: ID!
}

type SetHeroAsAvatarPayload {
  error: SetHeroAsAvatarError
  user: User
}

input SetModLogsAccessInput {
  accessLevel: ModLogsAccessLevel!
  channelID: ID!
  channelRole: ChannelUserRole!
}

type SetModLogsAccessPayload {
  modLogsAccess: ModLogsAccess
}

input SetModViewSettingsInput {
  tutorialSeenAt: Time!
  tutorialState: TutorialState!
}

type SetModViewSettingsPayload {
  modViewSettings: ModViewSettings
}

input SetNotificationSettingInput {
  category: String!
  platform: String!
  settingState: String!
}

type SetNotificationSettingPayload {
  settingState: String!
}

input SetOverwatchLeagueTeamPreferenceInput {
  OverwatchTeamPreferenceOptionID: ID!
}

type SetOverwatchLeagueTeamPreferencePayload {
  error: SetOverwatchTeamPreferenceError
  overwatchLeagueTeamPreference: OverwatchLeagueTeamPreference
}

type SetOverwatchTeamPreferenceError {
  code: SetOverwatchTeamPreferenceErrorCode!
}

enum SetOverwatchTeamPreferenceErrorCode {
  UNKNOWN
}

input SetPreferredLanguageTagInput {
  preferredLanguageTag: LanguageTag!
  userID: ID!
}

type SetPreferredLanguageTagPayload {
  user: User
}

type SetRadioCurrentlyPlayingError {
  code: SetRadioCurrentlyPlayingErrorCode
}

enum SetRadioCurrentlyPlayingErrorCode {
  INVALID_ID
  PERMISSION_DENIED
  NO_RECORD
}

input SetRadioCurrentlyPlayingInput {
  contentType: RadioCurrentlyPlayingType
  isCurrentlyPlaying: Boolean!
  sourceID: ID
  trackID: ID
}

type SetRadioCurrentlyPlayingPayload {
  currentTrack: RadioCurrentTrackResponse
  error: SetRadioCurrentlyPlayingError
}

input SetReadableChatColorsEnabledInput {
  isReadableChatColorsEnabled: Boolean!
}

type SetReadableChatColorsEnabledPayload {
  isReadableChatColorsEnabled: Boolean!
}

input SetResourceRestrictionInput {
  resourceID: ID!
  resourceType: RestrictionResource!
  restrictionOptions: [ResourceRestrictionOption!]
  restrictionType: ResourceRestrictionType
}

type SetResourceRestrictionPayload {
  channel: Channel
  stream: Stream
  video: Video
}

type SetScheduleReminderError {
  code: SetScheduleReminderErrorCode!
  message: String
}

enum SetScheduleReminderErrorCode {
  UNKNOWN
  INVALID_ARGUMENT
  NOT_FOUND
  FAILED_PRECONDITION
}

input SetScheduleReminderInput {
  segmentID: ID!
  shouldEnable: Boolean!
}

type SetScheduleReminderPayload {
  error: SetScheduleReminderError
  isEnabled: Boolean
}

input SetSessionStatusInput {
  activity: ActivityInput
  availability: AvailabilityInput!
  sessionID: String!
}

type SetSessionStatusPayload {
  setAgainInSeconds: Int!
  user: User
}

input SetSquadStreamPrimaryPlayerInput {
  deviceID: ID!
  primaryPlayerID: ID!
  squadID: ID!
}

type SetSquadStreamPrimaryPlayerPayload {
  primaryPlayer: User
}

type SetUnbanRequestsSettingsError {
  code: SetUnbanRequestsSettingsErrorCode!
}

enum SetUnbanRequestsSettingsErrorCode {
  UNKNOWN
  UNAUTHORIZED
  INVALID_VALUE
}

input SetUnbanRequestsSettingsInput {
  channelID: ID!
  cooldownMinutes: Int!
  isEnabled: Boolean!
}

type SetUnbanRequestsSettingsPayload {
  error: SetUnbanRequestsSettingsError
  settings: UnbanRequestsSettings
}

input SetUserResidenceInput {
  countryCode: String!
  userID: ID!
  zipCode: String
}

type SetUserResidencePayload {
  user: User
}

type Share {
  author: User
  createdAt: Time
  id: ID!
  target: ShareTarget
}

union ShareTarget = Clip | Post | Stream | Video
type Shelf {
  content: ShelfContentConnection!
  displayType: String!
  id: ID!
  title: ShelfTitle!
  trackingInfo: TrackingInfo!
}

type ShelfConnection {
  edges: [ShelfEdge!]
  pageInfo: PageInfo!
}

union ShelfContent = Clip | Game | Stream | Tag | Video
type ShelfContentConnection {
  edges: [ShelfContentEdge!]
  pageInfo: PageInfo!
}

type ShelfContentEdge {
  cursor: Cursor!
  metadata: ShelfContentMetadata
  node: ShelfContent
  promotionsCampaignID: ID!
  sourceType: SourceType!
  trackingID: ID!
}

type ShelfContentMetadata {
  hasLive: Boolean!
  subtitle: ShelfTitle
  title: ShelfTitle!
}

type ShelfEdge {
  cursor: Cursor!
  node: Shelf!
}

type ShelfTitle {
  context: ShelfTitleContext
  fallbackLocalizedTitle: String!
  key: String!
  localizedTitleTokens: [TitleTokenEdge]!
}

union ShelfTitleContext = Game
input ShelvesAvailableOptions {
  collectionID: ID
  gameID: ID
  shelfType: VideoShelfType
}

input ShelvesOptions {
  includeEmpty: Boolean = false
}

type ShortVideo {
  content: ShortVideoContent
  id: ID!
  reactions: [ShortVideoReaction!]!
}

union ShortVideoContent = Clip
type ShortVideoFeedConnection {
  edges: [ShortVideoFeedEdge!]!
  pageInfo: PageInfo!
}

type ShortVideoFeedEdge {
  cursor: Cursor!
  node: ShortVideo
}

input ShortVideoFeedOptions {
  platform: ShortVideoFeedPlatform
  type: ShortVideoFeedType
}

enum ShortVideoFeedPlatform {
  MOBILE_WEB
  IOS
  ANDROID
}

enum ShortVideoFeedType {
  FOLLOWING
  RECOMMENDED
}

type ShortVideoReaction {
  count: Int!
  emote: Emote
  id: ID!
}

type SmartCostsAcknowledgement {
  lastAcknowledgedCost: Int!
  rewardType: CommunityPointsAutomaticRewardType!
}

input SmartCostsAcknowledgementInput {
  lastAcknowledgedCost: Int!
  rewardType: CommunityPointsAutomaticRewardType!
}

type SmiliesSet {
  emotes: [Emote!]
  id: ID
}

input SnoozeAdInput {
  targetChannelID: ID!
  snoozeDuration: Int
}

type SnoozeAdPayload {
  status: SnoozeAdStatusCode
}

enum SnoozeAdStatusCode {
  SUCCESS
  ERROR
}

type SocialMedia {
  id: ID!
  name: String
  title: String!
  url: String!
}

type SocialStream implements RecommendedStream {
  friend: User
  stream: Stream
  type: StreamRecommendationType
}

enum SortOrder {
  ASC
  DESC
}

enum SourceType {
  PROMOTION
  RECOMMENDED
  SPONSORED
  POPULAR
  COMMUNITY_BOOST
  UNKNOWN_SOURCE_TYPE
}

type SpendSubscriptionCreditError {
  code: SpendSubscriptionCreditErrorCode!
}

enum SpendSubscriptionCreditErrorCode {
  UNABLE_TO_SPEND
  TOO_MANY_RECENT_SPENDS
}

input SpendSubscriptionCreditInput {
  broadcasterID: String!
  userID: ID!
}

type SpendSubscriptionCreditPayload {
  error: SpendSubscriptionCreditError
  subscriptionBenefit: SubscriptionBenefit
  userID: ID!
}

type SponsoredCheermoteChannelSettingsConnection {
  edges: [SponsoredCheermoteChannelSettingsEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type SponsoredCheermoteChannelSettingsEdge {
  cursor: Cursor!
  node: SponsoredCheermoteChannelSettingsNode
}

type SponsoredCheermoteChannelSettingsNode {
  brandImageURL: String!
  brandName: String!
  endTime: Time!
  id: ID!
  isOptedIn: Boolean!
  startTime: Time!
  thresholds: [CheermoteCampaignThreshold!]!
}

type SquadStream {
  id: ID!
  invitations(status: SquadStreamInvitationStatus!): [SquadStreamInvitation!]
  members: [User!]
  owner: User
  status: SquadStreamStatus!
}

enum SquadStreamIncomingInvitePolicy {
  NONE
  NETWORK
  ALL
}

type SquadStreamInvitation {
  createdAt: Time!
  id: ID!
  networkType: SquadStreamInvitationNetworkType
  reasonRejected: SquadStreamInvitationRejectedReason
  recipient: User
  sender: User
  squadStream: SquadStream
  status: SquadStreamInvitationStatus!
}

type SquadStreamInvitationConnection {
  nodes: [SquadStreamInvitation!]
  totalCount: Int
}

enum SquadStreamInvitationNetworkType {
  IN_NETWORK
  OUT_OF_NETWORK
}

enum SquadStreamInvitationRejectedReason {
  RECIPIENT_REJECTED
  RECIPIENT_CANNOT_ACCESS_SQUAD_STREAM
  RECIPIENT_CANNOT_BE_INVITED
}

enum SquadStreamInvitationStatus {
  ACCEPTED
  DELETED
  PENDING
  REJECTED
  UNKNOWN
}

type SquadStreamSettings {
  canAccessSquads: Boolean!
  incomingInvitePolicy: SquadStreamIncomingInvitePolicy
}

enum SquadStreamStatus {
  LIVE
  PENDING
  ENDED
  UNKNOWN
}

type SSOLink {
  app: String @deprecated(reason: "To be removed.")
  ssoID: String
}

type StartAdError {
  code: StartAdErrorCode!
  retryAfterSeconds: Int
}

enum StartAdErrorCode {
  RATE_LIMITED
  USER_NOT_AUTHORIZED
  UNKNOWN_ERROR
}

input StartAdInput {
  channelID: ID!
  lengthSeconds: Int
  trigger: StartAdTrigger
}

type StartAdPayload {
  adSession: AdSession
  error: StartAdError
}

enum StartAdTrigger {
  QUICK_ACTION
  ADS_MANAGER
}

type StartBountyError {
  code: StartBountyErrorCode!
}

enum StartBountyErrorCode {
  INVALID_PARAMETER
  BOUNTY_NOT_LIVE
  STREAM_TITLE_BANNED_WORDS
  STREAM_TITLE_TOO_LONG
  UNAUTHORIZED
  UNKNOWN_ERROR
}

input StartBountyInput {
  bountyID: ID!
  title: String!
  userID: ID!
}

type StartBountyPayload {
  error: StartBountyError
  startedBounty: Bounty
  user: User
}

type StartCloudBroadcastError {
  cause: StartCloudBroadcastErrorCause!
  message: String
}

enum StartCloudBroadcastErrorCause {
  NO_SUBSCRIPTION
  UNKNOWN
}

input StartCloudBroadcastInput {
  framerate: Int
  height: Int
  providerID: ID!
  width: Int
}

type StartCloudBroadcastPayload {
  broadcast: CloudBroadcast
  error: StartCloudBroadcastError
}

input StartPayoutOnboardingWorkflowInput {
  targetUserID: ID!
}

type StartPayoutOnboardingWorkflowPayload {
  workflow: PayoutOnboardingWorkflow
}

input StartWatchPartyInput {
  accessToken: String!
  channelID: ID!
  watchPartyItemID: ID!
}

type StartWatchPartyPayload {
  error: WatchPartyError
  watchParty: WatchParty
}

type StatCreatorHomeCard implements CreatorHomeCard {
  type: String!
  currentValue: Float!
  targetValue: Float!
  error: CreatorHomeError
}

type StopBountyError {
  code: StopBountyErrorCode!
}

enum StopBountyErrorCode {
  INVALID_PARAMETER
  UNAUTHORIZED
  UNKNOWN_ERROR
}

input StopBountyInput {
  bountyID: ID!
  userID: ID!
}

type StopBountyPayload {
  error: StopBountyError
  stoppedBounty: Bounty
  user: User
}

type StopCloudBroadcastError {
  cause: StopCloudBroadcastErrorCause!
  message: String
}

enum StopCloudBroadcastErrorCause {
  BROADCAST_NOT_FOUND
  UNKNOWN
}

input StopCloudBroadcastInput {
  id: ID!
}

type StopCloudBroadcastPayload {
  broadcast: CloudBroadcast
  error: StopCloudBroadcastError
}

input StopWatchPartyInput {
  accessToken: String!
  channelID: ID!
}

type StopWatchPartyPayload {
  error: WatchPartyError
  watchParty: WatchParty
}

type Stream {
  archiveVideo: Video
  averageFPS: Float
  bitrate: Float
  broadcastLanguage: Language
  broadcaster: User
  broadcasterSoftware: String
  channel: Channel
    @deprecated(
      reason: "Channel fields have been merged into User. Use stream.broadcaster instead."
    )
  clipCount: Int
  codec: String
  createdAt: Time
  delayLengthSeconds: Int
    @deprecated(reason: "Not a supported feature anymore.")
  directories: [Directory]!
    @deprecated(
      reason: "This was made for Communities, but the feature is officially dead. Use 'game' instead"
    )
  game: Game
  height: Int
  id: ID!
  isDirectoryHidden: Boolean
  isEncrypted: Boolean
  isMature: Boolean
    @deprecated(reason: "Use broadcaster.broadcastSettings.isMature instead")
  isPartner: Boolean
  isStreamDropsEnabled: Boolean
  language: Language
  lastUpdatedAt: Time
  maxHeight: Int @deprecated(reason: "Not a supported feature anymore")
  platform: Platform
  playbackAccessToken(params: PlaybackAccessTokenParams!): PlaybackAccessToken
  previewImageURL(height: Int, width: Int): String
  restriction: ResourceRestriction
    @deprecated(
      reason: "Use Channel.restriction for full restriction data or Stream.restrictionType for stream's restriction type"
    )
  restrictionOptions: [ResourceRestrictionOption!]!
  restrictionType: String
  self: StreamSelfConnection
  tags: [Tag!]
  title: String
    @deprecated(
      reason: "Title field in Users has been deprecated. Use broadcaster.broadcastSettings.title instead"
    )
  type: String
  viewersCount: Int
  width: Int
}

type StreamBitrate {
  recordedAt: Time!
  valueKbps: Float!
}

type StreamConnection {
  edges: [StreamEdge]
  generationID: ID
  pageInfo: PageInfo
  responseID: ID
}

type StreamEdge {
  cursor: Cursor
  node: Stream
  trackingID: ID
}

enum StreamerShelfType {
  AUTOHOST
  TEAM
  DISABLED
}

type StreamFramerate {
  recordedAt: Time!
  valueFPS: Float!
}

type Streaming implements Activity {
  stream: Stream
  type: ActivityType
}

type StreamKey {
  expiresAt: Time
  value: String!
}

type StreamKeyError {
  code: String!
  links: [String!]!
  message: String!
}

union StreamKeyResult = StreamKey | StreamKeyError
type StreamManagerMosaicLayout implements ChannelDashboardLayout {
  data: MosaicData!
  id: ID!
  name: String!
  version: String!
  lastUpdated: Time
}

input StreamMetadataFilterInput {
  counterStrikeMap: String
  counterStrikeSkill: String
  hearthstoneBroadcasterHeroClass: String
  hearthstoneBroadcasterHeroName: String
  hearthstoneGameMode: String
  leagueOfLegendsChampionID: String
  maxAVCLevel: String
  maxAVCProfile: AVCProfile
  maxHeight: Int
  overwatchBroadcasterCharacter: String
  pubgGameMode: String
  pubgPlayerAliveMax: String
  pubgPlayerAliveMin: String
}

input StreamOptions {
  includeRestricted: [StreamRestrictionType!]
  languages: [Language!]
  locale: String
  platformType: PlatformType = all
  recommendationsContext: RecommendationsContext
  requestID: ID
  sort: StreamSort = VIEWER_COUNT
  tags: [String!]
}

type StreamRecommendationEdge {
  cursor: Cursor!
  node: Stream
  trackingID: ID!
}

input StreamRecommendationsFilters {
  categoryIDs: [ID!]
}

enum StreamRecommendationType {
  SOCIAL
}

enum StreamRestrictionType {
  OWL_ALL_ACCESS_PASS
  SUB_ONLY_LIVE
}

type StreamSelfConnection {
  canWatch: Boolean!
  isRestricted: Boolean!
  restrictionType: String
}

type StreamSession {
  archiveVideo: Video
  endedAt: Time!
  startedAt: Time!
}

enum StreamSort {
  VIEWER_COUNT
  VIEWER_COUNT_ASC
  RECENT
  RELEVANCE
  CSGO_SKILL
  LOL_SUMMONER_RANK
}

type StreamSummary {
  archiveVideos: [Video!]
  averageViewers: Float!
  channelID: ID!
  chatters: Int!
  clipsCreated: Int!
  endedAt: Time!
  follows: Int!
  goLiveNotification: GoLiveNotification
  liveViews: Int!
  maxViewers: Int!
  newSubscriptions: Int!
  startedAt: Time!
  uniqueChatters: Int! @deprecated(reason: "Use chatters instead")
  uniqueViewers: Int!
}

type Stucco {
  description: String!
  id: ID!
  imageSet: StuccoImageSet!
  isGlobal: Boolean!
  ownerID: ID!
  state: StuccoState!
  textCode: String!
}

type StuccoImageSet {
  image1xURL: String!
  image2xURL: String!
  image4xURL: String!
}

type StuccoPack {
  id: ID!
  ownerID: ID!
  slots: [StuccoPackSlot!]
}

type StuccoPackSlot {
  index: Int!
  stucco: Stucco!
}

enum StuccoState {
  ACTIVE
  INACTIVE
  MODERATED
  PENDING
  ARCHIVED
}

type SubCountSeries {
  period: TimeSeriesPeriod!
  subCountSeriesDataPoints: [SubCountSeriesDataPoint!]!
  totalCount: Int!
}

type SubCountSeriesDataPoint {
  giftSubTierBreakdown: [SubCountTierDataPoint!]!
  multiMonthSubTierBreakdown: [SubCountTierDataPoint!]!
  paidSubTierBreakdown: [SubCountTierDataPoint!]!
  timeStamp: Time!
  totalGiftSubCount: Int!
  totalMultiMonthSubCount: Int!
  totalPaidSubCount: Int!
  totalPrimeSubCount: Int!
}

type SubCountTierDataPoint {
  count: Int!
  tier: String!
}

type SubmitCopyrightClaimError {
  message: String!
}

input SubmitCopyrightClaimInput {
  copyrightedWork: CopyrightedWork!
  reportedContents: [ReportedContent!]!
  contactInformation: CopyrightClaimContact!
  signature: String!
  captchaToken: String
}

type SubmitCopyrightClaimPayload {
  claimID: ID
  error: SubmitCopyrightClaimError
}

type SubmitCSATFeedbackError {
  code: SubmitCSATFeedbackErrorCode!
}

enum SubmitCSATFeedbackErrorCode {
  UNKNOWN
  INVALID_ARGUMENT
}

input SubmitCSATFeedbackInput {
  actionPrompted: CSATActionPrompted
  companyID: ID
  feedback: String
  guid: ID
  rating: CSATRating
  source: String!
}

type SubmitCSATFeedbackPayload {
  error: SubmitCSATFeedbackError
  response: SubmitCSATFeedbackResponse
}

type SubmitCSATFeedbackResponse {
  guid: ID!
}

input SubmitEmotePrefixInput {
  channelID: ID!
  name: String!
}

type SubmitEmotePrefixPayload {
  errorCode: SubmitEmotePrefixResponseCode
  prefix: EmoticonPrefix
}

enum SubmitEmotePrefixResponseCode {
  ERR_INVALID_USER
  ERR_INVALID_PREFIX_LENGTH
  ERR_INVALID_PREFIX_REGEX
  ERR_INVALID_PREFIX_STATE
  ERR_PREFIX_NOT_UNIQUE
  ERR_PREFIX_UPDATE_TOO_SOON
  ERR_NOT_IN_GOOD_STANDING
  ERR_UNKNOWN
  ERR_AFFILIATE_PREFIX_UPDATE_TOO_SOON
  ERR_SUBMITTED_PREFIX_DOES_NOT_MATCH_AUTO_GENERATED_PREFIX
}

input SubmitEmoticonPrefixInput {
  channelID: ID!
  name: String!
}

type SubmitEmoticonPrefixPayload {
  response: EmoticonPrefix!
}

enum SubmitExtensionFeedbackError {
  INTERNAL_ERROR
}

input SubmitExtensionFeedbackInput {
  comment: String!
  extensionClientID: ID!
  extensionVersion: String!
  userID: ID!
}

type SubmitExtensionFeedbackPayload {
  comment: ExtensionComment
  error: SubmitExtensionFeedbackError
}

type SubscribedChannelConnection {
  edges: [SubscribedChannelEdge!]
  pageInfo: PageInfo!
  totalCount: Int
}

type SubscribedChannelEdge {
  cursor: Cursor!
  node: User
}

type SubscriberBadgeProgress {
  id: ID!
  image1xURL: String!
  image2xURL: String!
  image4xURL: String!
  percentCompleted: Float!
  requiredTenureMonths: Int!
  version: String!
}

type SubscriberCountBreakdown {
  count: Int!
  tier: String!
}

type SubscriberScore {
  breakdown: [SubscriberScoreBreakdown!]
  count: Int!
  countBreakdown: [SubscriberCountBreakdown!]
  current: Int!
  currentEmoteLimit: Int!
  next: Int
  nextEmoteLimit: Int
}

type SubscriberScoreBreakdown {
  score: Int!
  tier: String!
}

type SubscriptionBenefit {
  endsAt: Time
  gift: SubscriptionGift
  id: ID!
  intervalNumber: Int!
  isDNRd: Boolean!
  isExtended: Boolean!
  isRefundable: Boolean!
  originID: String
  paidUpgrade: PaidUpgrade
    @deprecated(
      reason: "gift to paid upgrades will now be in the pendingSubscription schema"
    )
  pendingSubscription: PendingSubscription
  platform: SubscriptionPlatform!
  product: SubscriptionProduct
  purchasedWithPrime: Boolean!
  renewsAt: Time
  states: [SubscriptionBenefitStateHistory!]
  thirdPartySKU: String
  tier: String!
  user: User
}

type SubscriptionBenefitConnection {
  edges: [SubscriptionBenefitEdge!]
  pageInfo: PageInfo!
}

input SubscriptionBenefitCriteriaInput {
  filter: SubscriptionBenefitFilter = ALL
  platform: SubscriptionPlatform = WEB
}

type SubscriptionBenefitEdge {
  cursor: Cursor!
  node: SubscriptionBenefit
}

enum SubscriptionBenefitFilter {
  PLATFORM
  GIFT
  ALL
}

enum SubscriptionBenefitState {
  UNKNOWN
  ACTIVE
  DNR_INITIATED
  WILL_NOT_RENEW
  CANCEL_INITIATED
  CANCELLED
  ON_HOLD
}

type SubscriptionBenefitStateHistory {
  createdAt: Time
  state: SubscriptionBenefitState!
}

type SubscriptionCheckoutConfigs {
  actions: [CheckoutAction!]!
  canGift: Boolean!
  canPurchase: Boolean!
  isOneMonthFreeEligible: Boolean!
  paymentProviderConfigs: PaymentProviderConfigs!
  purchaseIneligibilityReason: PurchaseIneligibilityReason!
}

type SubscriptionCommunityGifting {
  assets: SubscriptionCommunityGiftingAssets!
  offer: Offer
  quantity: Int!
  type: SubscriptionCommunityGiftingType!
}

type SubscriptionCommunityGiftingAssets {
  imageURL1x: String!
  imageURL2x: String!
  imageURL3x: String!
  imageURL4x: String!
}

enum SubscriptionCommunityGiftingType {
  UNKNOWN
  BUNDLE
  CUSTOM
}

type SubscriptionGift {
  giftDate: Time
  gifter: User
  isGift: Boolean!
}

type SubscriptionGifting {
  community: [SubscriptionCommunityGifting!]
  standard(
    recipientID: ID
    recipientLogin: String
  ): [SubscriptionStandardGifting!]
}

type SubscriptionGiftOffer {
  id: ID!
  priceInfo(taxCountry: String): PriceInfo!
  promotion: SubscriptionGiftPromotion
  quantity: Int!
  thirdPartySKU: String
  type: SubscriptionGiftType!
}

enum SubscriptionGiftOfferPlatform {
  WEB
  ANDROID
}

type SubscriptionGiftPromotion {
  discountType: SubscriptionPromotionDiscountType!
  discountValue: String!
  id: ID!
  priceInfo(taxCountry: String): PriceInfo!
  quantity: Int!
  thirdPartySKU: String
}

enum SubscriptionGiftType {
  NONE
  STANDARD
  COMMUNITY
}

type SubscriptionInterval {
  duration: Int!
  unit: SubscriptionIntervalUnit!
}

enum SubscriptionIntervalUnit {
  UNKNOWN
  WEEK
  MONTH
  YEAR
  ONE_TIME
}

type SubscriptionOffer {
  currency: String!
  exponent: Int!
  id: ID!
  price: Int!
  promoDescription: String
}

enum SubscriptionPlatform {
  NONE
  WEB
  IOS
  ANDROID
  MOBILE_ALL
}

type SubscriptionProduct {
  displayName: String
  emoteLimit: Int
  animatedEmoteLimit: Int
  emoteModifiers: [EmoteModifier!]
  emoteSetID: ID
    @deprecated(
      reason: "Products can have more than one emote set now so use emoteGroups instead."
    )
  emoteGroups(state: EmoteStateFilter = ACTIVE): [EmoteSet!]
  emotes(state: EmoteStateFilter = ACTIVE): [Emote]
  giftOffers(
    platform: SubscriptionGiftOfferPlatform
    type: SubscriptionGiftType!
  ): [SubscriptionGiftOffer!]
  giftPromotion: SubscriptionPromotion
  gifting(countryCode: String): SubscriptionGifting!
  hasAdFree: Boolean!
  hasFastChat: Boolean
  hasSubOnlyChat: Boolean
  hasSubonlyVideoArchive: Boolean
  id: ID!
  interval: SubscriptionInterval!
  name: String!
  offers(countryCode: String): [Offer!]
  owner: User
  price: String!
    @deprecated(
      reason: "Transitioning to priceInfo instead to support multi region pricing"
    )
  priceInfo(taxCountry: String): PriceInfo!
  promotion: SubscriptionPromotion
  revenueConfig: RevenueConfig
  self: SubscriptionProductSelfConnection
  state: SubscriptionState!
  thirdPartyTemplateSKU(platform: String): String
  tier: String!
  type: SubscriptionProductType!
  url: String!
}

type SubscriptionProductsConnection {
  nodes: [SubscriptionProduct!]!
}

type SubscriptionProductSelfConnection {
  benefit: SubscriptionBenefit
  canGiftInChannel: Boolean!
  canGiftTo(recipientID: ID!): Boolean!
  canGiftToLogin(recipientLogin: String!): Boolean!
  checkoutConfiguration(
    config: CheckoutConfigurationInput!
  ): SubscriptionCheckoutConfigs
  giftOffers(
    platform: SubscriptionGiftOfferPlatform
    type: SubscriptionGiftType!
  ): [SubscriptionGiftOffer!]
  paidUpgradePromotion: SubscriptionPromotion
  productPurchase(
    quantity: Int!
    paymentProvider: PaymentProvider!
  ): ProductPurchase
  promotion: SubscriptionPromotion
  purchase: SubscriptionPurchase
  subscriptionTenure(
    tenureMethod: SubscriptionTenureMethod!
  ): SubscriptionTenure
  thirdPartyPurchaseSKU(platform: String): String
}

type SubscriptionProductsError {
  code: SubscriptionProductsErrorCode!
}

enum SubscriptionProductsErrorCode {
  UNKNOWN
  ERROR
  MISSING
}

union SubscriptionProductsResult =
    SubscriptionProductsConnection
  | SubscriptionProductsError
enum SubscriptionProductType {
  CHANSUB
  TEAMSUB
  TURBO
}

type SubscriptionPromotion {
  checkoutPrice(
    quantity: Int!
    paymentProvider: PaymentProvider!
  ): ProductPurchase
  discountType: SubscriptionPromotionDiscountType!
    @deprecated(reason: "No longer supported.")
  discountValue: String! @deprecated(reason: "No longer supported.")
  newPrice: String!
    @deprecated(reason: "Use SubscriptionPromotion.previewPrice instead.")
  oldPrice: String!
    @deprecated(reason: "Use SubscriptionProduct.priceInfo instead.")
  previewPrice: PriceInfo!
}

enum SubscriptionPromotionDiscountType {
  NONE
  PERCENT_OFF
  FIXED_VALUE_OFF
}

type SubscriptionPurchase {
  compatiblePurchases: [SubscriptionPurchaseDetails!]
  details: SubscriptionPurchaseDetails
}

type SubscriptionPurchaseDetails {
  cancelledAt: Time
  currency: String!
  divisor: Int!
  paymentProvider: PaymentProvider!
  price: Int!
  productTier: String
  productType: SubscriptionProductType!
  state: SubscriptionPurchaseState!
}

enum SubscriptionPurchaseState {
  ACTIVE
  CANCELLED
  INACTIVE
}

type SubscriptionStandardGifting {
  offer: Offer
}

enum SubscriptionState {
  ACTIVE
  INACTIVE
  UNKNOWN
}

type SubscriptionSummary {
  emotes: [Emote]
  id: ID!
  modifiers: [EmoteModifier!]
  name: String!
  offers: [SubscriptionOffer!]
  self: SubscriptionSummarySelf!
  tier: SubscriptionSummaryTier!
  url: String!
}

type SubscriptionSummarySelf {
  cumulativeTenure: Int!
  subscribedTier: SubscriptionSummaryTier
}

enum SubscriptionSummaryTier {
  TIER_1
  TIER_2
  TIER_3
}

type SubscriptionTenure {
  daysRemaining: Int!
  elapsedDays: Int!
  end: Time
  method: SubscriptionTenureMethod!
  months: Int!
  start: Time
}

enum SubscriptionTenureMethod {
  CUMULATIVE
  STREAK
}

enum SubscriptionTier {
  CUSTOM
  PRIME
  T_1000
  T_2000
  T_3000
}

type SubscriptionToken {
  balance: Int
}

type SubscriptionTokenBundleProduct {
  assets: [TokenBundleAsset!]
  id: ID!
  offers: [Offer!]
  quantity: Int!
}

type SubscriptionTokenProductConfig {
  maxBalance: Int
}

input SwapCompetitionLobbyParticipantInput {
  lobbyID: ID!
  participantID: ID!
}

input SwapCompetitionLobbyParticipantsInput {
  competitionID: ID!
  first: SwapCompetitionLobbyParticipantInput!
  phaseID: ID!
  second: SwapCompetitionLobbyParticipantInput!
}

type SwapCompetitionLobbyParticipantsPayload {
  competition: Competition
  error: CompetitionError
}

input SyncGameOnDropCampaignInput {
  campaignID: ID!
}

type SyncGameOnDropCampaignPayload {
  dropCampaign: DropCampaign
  error: DropsError
}

type Tag {
  createdAt: Time
  id: ID!
  isAutomated: Boolean!
  isLanguageTag: Boolean!
  localizedDescription: String!
  localizedName: String!
  scope: TagScope!
  tagName: String!
}

type TagAnalytic {
  percentage: Float!
  tag: Tag!
}

type TagConnection {
  edges: [TagEdge!]
  pageInfo: PageInfo!
}

type TagEdge {
  cursor: Cursor!
  node: Tag
}

union TaggedContent = Clip | Game | Stream | User | Video
enum TagScope {
  ALL
  CATEGORY
}

enum TagType {
  CONTENT
  TOP
}

type TargetedModActionDetails {
  bannedAt: Time
  durationSeconds: Int
  expiresAt: Time
  reason: String
}

type TaxInterview {
  accountID: ID! @deprecated(reason: "Use interview options instead")
  clientID: ID! @deprecated(reason: "Use interview options")
  governmentAlias: String! @deprecated(reason: "Use interview options")
  locale: String! @deprecated(reason: "Use interview options instead")
  options: [TaxInterviewOption!]
  signature: String!
  type: TaxInterviewType! @deprecated(reason: "Use interview options instead")
  url: String!
}

type TaxInterviewOption {
  key: String!
  value: String!
}

enum TaxInterviewType {
  ROYALTY
  SERVICE
}

enum TaxMismatchError {
  NAME
  COUNTRY
  EMAIL
  STREET_ADDRESS
  STREET_ADDRESS_2
  CITY
  STATE
  POSTAL
}

type TaxRegion {
  countryCode: String!
  state: String
  zipCode: String
}

type TCFCookieVendor {
  consentStatus: ConsentStatus!
  cookieVendorType: CookieVendorType!
  features: [ConsentFeature!]
  hasUserSetConsent: Boolean!
  isVisible: Boolean!
  name: VendorName!
  policyURL: String!
  purposes: [ConsentPurpose!]
  specialFeatures: [ConsentSpecialFeature!]
  specialPurposes: [ConsentSpecialPurpose!]
}

type Team {
  backgroundImageID: ID
  backgroundImageURL: String
  bannerID: ID
  bannerURL: String
  creatorTimeseriesMetrics(
    startAt: Time!
    endAt: Time
    timeZone: String!
    granularity: Granularity = FIVE_MINUTE
    channelIDs: [ID!] = []
  ): CreatorTimeseriesMetrics
  description: String
  displayName: String!
  id: ID!
  liveFeaturedChannels(first: Int = 10, after: Cursor): UserConnection
  liveMembers(first: Int = 10, after: Cursor): UserConnection
  logoID: ID
  logoURL: String
  members(
    first: Int = 10
    after: Cursor
    metricsRevealedFilter: MemberMetricsRevealedParams
  ): UserConnection
  name: String!
  owner: User
  videoPlayReferrals(
    start: Time!
    end: Time!
    filter: ReferralsFilter = ALL
    dimension: ReferralsDimension!
    first: Int = 10
    channelIDs: [ID!] = []
  ): VideoPlayReferrals
}

input TerminatePollInChannelInput {
  channelID: ID!
}

type TerminatePollInChannelPayload {
  poll: Poll
}

input TerminatePollInput {
  pollID: ID!
}

type TerminatePollPayload {
  poll: Poll
}

type TextToken {
  hasEmphasis: Boolean!
  location: LinkType!
  text: String!
}

type ThumbnailOEmbed {
  height: Int!
  url: String!
  width: Int!
}

enum TiebreakerLabel {
  KILLS
  BONUS
  UNKNOWN
}

scalar Time

type TimeBasedDrop implements DropType {
  benefitEdges: [DropBenefitEdge!]
  campaign: DropCampaign!
  endAt: Time!
  id: ID!
  name: String!
  preconditionDrops: [TimeBasedDrop!]
  requiredMinutesWatched: Int!
  self: TimeBasedDropSelfEdge!
  startAt: Time!
}

type TimeBasedDropSelfEdge {
  currentMinutesWatched: Int!
  dropInstanceID: ID
  hasPreconditionsMet: Boolean!
  isClaimed: Boolean!
}

type TimeseriesItem {
  follows: Int @deprecated(reason: "Use user.timeseriesStats.follows instead.")
  minutesStreamed: Int!
  timestamp: Time!
  value: Float!
}

enum TimeSeriesPeriod {
  DAY
  MONTH
}

type TimeseriesStats {
  adBreaksInSeconds: [TimeseriesItem!]
  adTimePerHour: [TimeseriesItem!]
  averageViewers: [TimeseriesItem!]
  chatMessages: [TimeseriesItem!]
  clipViews: [TimeseriesItem!]
  clipsCreated: [TimeseriesItem!]
  follows: [TimeseriesItem!]
  granularity: Granularity!
  hostRaidViewers: [TimeseriesItem!]
  items: [TimeseriesItem!]
    @deprecated(
      reason: "Use specific metric from user.timeseriesStats instead."
    )
  liveViews: [TimeseriesItem!]
  maxViewers: [TimeseriesItem!]
  minutesWatched: [TimeseriesItem!]
  newSubscriptions: [TimeseriesItem!]
  promotionClick: [TimeseriesItem!]
  promotionDisplay: [TimeseriesItem!]
  timeStreamed: [TimeseriesItem!]
  uniqueChatters: [TimeseriesItem!]
  uniqueViewers: [TimeseriesItem!]
}

type TitleTokenEdge {
  node: TitleTokenNode
}

union TitleTokenNode = DateToken | Game | IntegerToken | Tag | TextToken | User
input ToggleRitualsEnabledInput {
  channelID: ID!
  isEnabled: Boolean!
}

type ToggleRitualsEnabledPayload {
  isEnabled: Boolean!
  user: User
}

type TokenBundleAsset {
  imageURL1x: String!
  imageURL2x: String!
  imageURL3x: String!
  key: String!
}

type Tournament {
  globalLeaderboard: BitsLeaderboard! @deprecated
  id: ID! @deprecated
  progress: TournamentProgress! @deprecated
  rewards: TournamentRewards @deprecated
  self: TournamentSelfEdge @deprecated
  teamLeaderboard: BitsLeaderboard! @deprecated
  teams: [TournamentTeam]! @deprecated
}

type TournamentInsiderRewards {
  badges: [TournamentReward!]! @deprecated
  bits: [TournamentReward!]! @deprecated
  heroSkins: [TournamentReward!]! @deprecated
  inGameContent: [TournamentReward!]! @deprecated
}

type TournamentProgress {
  amount: Int! @deprecated
  milestones: [Milestone!]! @deprecated
}

type TournamentReward {
  campaignID: ID! @deprecated
  canBeFulfilled: Boolean! @deprecated
  canBeFulfilledQuantity: Int! @deprecated
  description: String! @deprecated
  entitledQuantity: Int! @deprecated
  id: ID! @deprecated
  imageURL: String! @deprecated
  isEntitled: Boolean! @deprecated
  isPrimeOnly: Boolean! @deprecated
  isRepeatable: Boolean! @deprecated
  metadata: CampaignRewardMetadata @deprecated
  name: String! @deprecated
  quantity: Int! @deprecated
  rarity: Int! @deprecated
  type: String! @deprecated
}

type TournamentRewards {
  cheerbomb: [TournamentReward!]! @deprecated
  global: [TournamentReward!]! @deprecated
  individual: [TournamentReward!]! @deprecated
  insider: TournamentInsiderRewards! @deprecated
  team: [TournamentReward!]! @deprecated
}

type TournamentSelfEdge {
  globalLeaderboardItem: BitsLeaderboardItem @deprecated
  progress: TournamentProgress! @deprecated
  teams: [TournamentTeam!]! @deprecated
}

type TournamentTeam {
  division: String! @deprecated
  id: ID! @deprecated
  logoURL: String! @deprecated
  name: String! @deprecated
}

input TrackAppealRequestInput {
  audibleMagicResponseID: ID!
  reason: String!
}

type TrackingInfo {
  reasonTarget: String
  reasonTargetType: String
  reasonType: String!
  rowName: String!
}

type TrackingPixel {
  origin: String
  service: String!
  timeOffsetSeconds: Int
  type: TrackingPixelType
  url: String!
}

input TrackingPixelInput {
  timeOffsetSeconds: Int
  type: TrackingPixelType
  url: String!
}

enum TrackingPixelType {
  DAR
  DCM
  SIZMEK
}

type Trailer {
  video: Video
}

type TranscodeSession {
  audioCodecs: String!
  host: String
  ingestOrigin: String
  profile: String
  videoCodecs: String!
}

enum TransitionExtensionStateError {
  UNAUTHORIZED
  MISSING_ASSET_HASH
  MISSING_REVIEW_NOTES
  MISSING_TEST_CHANNEL
  MULTIPLE_VERSIONS_IN_REVIEW
  TRANSITION_MISSING_AUTHOR_EMAIL
  TRANSITION_MISSING_AUTHOR_NAME
  TRANSITION_MISSING_CATEGORY
  TRANSITION_MISSING_SUPPORT_EMAIL
  TRANSITION_MISSING_NAME
  TRANSITION_MISSING_VERSION
  TRANSITION_MISSING_TESTING_BASE_URI
  TRANSITION_MISSING_SUMMARY
  TRANSITION_MISSING_DESCRIPTION
  TRANSITION_MISSING_SCREENSHOT_URLS
  INVALID_STATE_TRANSITION
  INVALID_VERSION
  ANCHOR_REQUIRED
  INVALID_ZOOM
  MAX_BROADCASTERS
  MAX_TESTERS
  MAX_WHITELISTED_CONFIG_URLS
  MAX_WHITELISTED_PANEL_URLS
  INVALID_NAME_LENGTH
  INVALID_DESCRIPTION_LENGTH
  INVALID_SUMMARY_LENGTH
  INVALID_AUTHOR_EMAIL
  INVALID_SUPPORT_EMAIL
  INVALID_AUTHOR_NAME_LENGTH
  INVALID_TESTING_BASE_URI
  INVALID_TERMS_URI
  INVALID_PRIVACY_URI
  INVALID_COMPONENT_VIEWER_PATH
  INVALID_PANEL_VIEWER_PATH
  INVALID_VIDEO_OVERLAY_VIEWER_PATH
  INVALID_CONFIG_VIEWER_PATH
  INVALID_LIVE_CONFIG_VIEWER_PATH
  INVALID_MOBILE_VIEWER_PATH
  INVALID_COMPONENT_ASPECT_WIDTH
  INVALID_COMPONENT_ASPECT_HEIGHT
  INVALID_PANEL_HEIGHT
  INVALID_BITS_SUPPORT_LEVEL
  INVALID_SCALING_PIXELS
  INVALID_COMPONENT_ASPECT_RATIO_X
  INVALID_COMPONENT_ASPECT_RATIO_Y
  INVALID_COMPONENT_TARGET_HEIGHT
}

input TransitionExtensionStateInput {
  id: ID!
  reviewNotes: String
  state: ExtensionState!
  testChannel: String
  version: String!
}

type TransitionExtensionStatePayload {
  error: TransitionExtensionStateError
  manifest: ExtensionManifest
}

type TriggerResult {
  channel: Channel
  dropInstanceID: ID
  status: ManuallyTriggerDropResultStatus!
}

enum TriggerType {
  CHEER
}

input TrueXAd {
  campaignID: ID!
  creativeID: ID!
  currencyAmount: String!
  name: String!
}

enum TutorialState {
  DISMISSED
  SEEN
  UNSEEN
}

type TwitchStudioMosaicLayout implements ChannelDashboardLayout {
  data: MosaicData!
  id: ID!
  name: String!
  version: String!
  lastUpdated: Time
}

enum TwoFactorMethod {
  AUTHY_SMS
  AUTHY_APP
  AUTHY_TOTP
  UNKNOWN
}

type UnacknowledgedSubscriptionEvent {
  channel: User
  endDate: Time
  externalProductID: ID!
  status: UnacknowledgedSubscriptionEventState!
  subscriptionID: ID!
}

enum UnacknowledgedSubscriptionEventState {
  ACTIVE
  WILL_NOT_RENEW
  CANCELLED
  ON_HOLD
}

type UnbanRequest {
  channel: Channel
  createdAt: Time!
  id: ID!
  requester: User
  requesterMessage: String
  resolvedAt: Time
  resolvedBy: User
  resolverMessage: String
  status: UnbanRequestStatus!
}

type UnbanRequestConnection {
  edges: [UnbanRequestEdge!]
  pageInfo: PageInfo!
  totalCount(status: UnbanRequestStatus = NONE): Float
}

type UnbanRequestEdge {
  cursor: Cursor!
  node: UnbanRequest
}

type UnbanRequestError {
  code: UnbanRequestErrorCode!
}

enum UnbanRequestErrorCode {
  UNAUTHORIZED
  REQUEST_NOT_FOUND
  INVALID_UPDATE
  UNKNOWN
}

enum UnbanRequestRestrictionReason {
  ALREADY_CREATED
  NOT_BANNED
  TOO_SOON_SINCE_BAN
  UNBAN_REQUESTS_DISABLED
  UNAUTHENTICATED
  UNKNOWN
}

input UnbanRequestsOptions {
  order: UnbanRequestsSortOrder = NEWEST
  status: UnbanRequestStatus
  userID: ID
}

type UnbanRequestsSettings {
  cooldownMinutes: Int!
  isEnabled: Boolean!
}

enum UnbanRequestsSortOrder {
  OLDEST
  NEWEST
}

enum UnbanRequestStatus {
  NONE
  APPROVED
  DENIED
  PENDING
  ACKNOWLEDGED
  CANCELED
}

type UnbanUserFromChatRoomError {
  code: UnbanUserFromChatRoomErrorCode!
}

enum UnbanUserFromChatRoomErrorCode {
  FORBIDDEN
  TARGET_NOT_FOUND
  TARGET_NOT_BANNED
}

input UnbanUserFromChatRoomInput {
  bannedUserLogin: String!
  channelID: ID!
}

type UnbanUserFromChatRoomPayload {
  ban: ChatRoomBanStatus
  error: UnbanUserFromChatRoomError
}

input UnblockUserInput {
  targetUserID: ID!
}

type UnblockUserPayload {
  targetUser: User!
}

input UndoRecommendationFeedbackInput {
  feedbackID: ID!
  sourceItemPage: String!
  sourceItemRequestID: ID!
  sourceItemTrackingID: ID!
}

type UndoRecommendationFeedbackPayload {
  feedbackID: ID!
}

input UnfollowGameInput {
  gameID: ID!
}

type UnfollowGamePayload {
  follow: GameFollow
  game: Game
}

input UnfollowUserInput {
  targetID: ID!
}

type UnfollowUserPayload {
  follow: Follow
}

input UnfriendUserInput {
  targetID: ID!
}

type UnfriendUserPayload {
  user: User
}

input UnhostInput {
  channelID: ID!
}

type UnhostPayload {
  channel: User
}

type UninstallExtensionError {
  code: UninstallExtensionErrorCode!
}

enum UninstallExtensionErrorCode {
  UNAUTHORIZED
  INVALID_CHANNEL_ID
  EXTENSION_NOT_INSTALLED
}

input UninstallExtensionInput {
  extensionInstallationID: ID!
}

type UninstallExtensionPayload {
  error: UninstallExtensionError
  id: ID!
}

input UnlinkAmazonConnectionInput {
  userID: ID
}

type UnlinkAmazonConnectionPayload {
  isSuccess: Boolean
}

input UnlinkRiotConnectionInput {
  userID: ID!
}

type UnlinkRiotConnectionPayload {
  connections: AccountConnectionSet
}

input UnlinkSSOInput {
  app: String!
  token: String
}

type UnlinkSSOPayload {
  links: [SSOLink!] @deprecated(reason: "To be removed.")
}

input UnlockChosenModifiedSubscriberEmoteInput {
  channelID: ID!
  cost: Int!
  emoteID: ID!
  transactionID: ID!
}

type UnlockChosenModifiedSubscriberEmotePayload {
  balance: Int
  error: CommunityPointsUnlockEmoteError
}

input UnlockChosenSubscriberEmoteInput {
  channelID: ID!
  cost: Int!
  emoteID: ID!
  transactionID: ID!
}

type UnlockChosenSubscriberEmotePayload {
  balance: Int
  error: CommunityPointsUnlockEmoteError
}

input UnlockRandomSubscriberEmoteInput {
  channelID: ID!
  cost: Int!
  transactionID: ID!
}

type UnlockRandomSubscriberEmotePayload {
  balance: Int
  emote: CommunityPointsEmote
  error: CommunityPointsUnlockEmoteError
}

type UnmodUserError {
  code: UnmodUserErrorCode!
}

enum UnmodUserErrorCode {
  FORBIDDEN
  TARGET_NOT_FOUND
  CHANNEL_NOT_FOUND
  TARGET_NOT_MOD
}

input UnmodUserInput {
  channelID: ID!
  targetID: ID
  targetLogin: String
}

type UnmodUserPayload {
  channel: User
  error: UnmodUserError
  target: User
}

input UnsetHypeTrainConfigInput {
  calloutEmote: Boolean
  cooldownPeriodMinutes: Boolean
  difficulty: Boolean
  eventsThreshold: Boolean
  isEnabled: Boolean
  shouldUsePersonalizedSettings: Boolean
  willUseCreatorColor: Boolean
}

type UnsetHypeTrainConfigPayload {
  config: HypeTrainConfig
}

input UnsubscribeEmailInput {
  sourceEmailID: String!
  sourceEmailType: String!
  targetChannelID: ID
  targetEmailType: String
  userID: ID!
  validatingHash: String!
}

type UnsubscribeEmailPayload {
  isSuccess: Boolean!
}

input UpdateAdPropertiesInput {
  hasDisablePrerollsAbilityEnabled: Boolean
  hasDisablePrerollsNotificationsEnabled: Boolean
  isMultiplayerAdsForSubsEnabled: Boolean
  targetUserID: ID!
}

type UpdateAdPropertiesPayload {
  targetUser: User
}

input UpdateAllChannelVideosViewabilityInput {
  channelID: ID!
  scope: VideoPrivacyScope!
}

type UpdateAllChannelVideosViewabilityPayload {
  status: UpdateAllChannelVideosViewabilityStatus
}

type UpdateAllChannelVideosViewabilityStatus {
  code: UpdateAllChannelVideosViewabilityStatusCode!
}

enum UpdateAllChannelVideosViewabilityStatusCode {
  SUCCESS
  FORBIDDEN
  INTERNAL_ERROR
  INVALID_ARGUMENT
  UNKNOWN
}

input UpdateAllWhisperThreadsInput {
  markAllAsRead: Boolean
}

type UpdateAllWhisperThreadsPayload {
  count: Int!
}

input UpdateAutohostSettingsInput {
  isEnabled: Boolean
  strategy: AutohostSettingsStrategy
  userID: ID!
  willAutohostTeam: Boolean
  willPrioritizeAutohost: Boolean
}

type UpdateAutohostSettingsPayload {
  user: User
}

input UpdateAutoModLevelsInput {
  channelID: ID!
  detailedLevels: DetailedAutoModLevelsInput
  overallLevel: Int
}

type UpdateAutoModLevelsPayload {
  autoModConfiguration: AutoModConfiguration
}

input UpdateAutoModPropertiesInput {
  aggressiveLevel: Int!
  channelID: String!
  identityLevel: Int!
  profanityLevel: Int!
  sexualLevel: Int!
}

type UpdateAutoModPropertiesPayload {
  autoModProperties: AutoModProperties
}

input UpdateBitsBadgeTierNotificationInput {
  message: String
  notificationID: ID!
  notificationState: BitsBadgeTierNotificationState!
}

type UpdateBitsBadgeTierNotificationPayload {
  user: User
}

type UpdateBitsBadgeTiersError {
  code: UpdateBitsBadgeTiersErrorCode!
}

enum UpdateBitsBadgeTiersErrorCode {
  INVALID_PARAMETER
  BADGE_TITLE_EXCEEDS_CHARACTER_LIMIT
  BADGE_TITLE_FAILED_MODERATION
  EMOTE_CODE_ALREADY_EXISTS
  EMOTE_CODE_UNACCEPTABLE
  USER_OWNED_EMOTE_LIMIT_REACHED
  INCOMPLETE_BADGE_IMAGE_DATA
  UNKNOWN_ERROR
}

input UpdateBitsBadgeTiersInput {
  tiers: [BitsBadgeTierInput!]
  userID: ID!
}

type UpdateBitsBadgeTiersPayload {
  canUploadBadgeTierEmoticons: Boolean
  error: UpdateBitsBadgeTiersError
  tiers: [BitsBadgeTier!]
}

type UpdateBoostSettingsError {
  code: UpdateBoostSettingsErrorCode!
}

enum UpdateBoostSettingsErrorCode {
  INVALID_PARAMETER
  INTERNAL_ERROR
}

input UpdateBoostSettingsInput {
  channelID: ID!
  isEarnedEnabled: Boolean
  isEnabled: Boolean
  isPaidEnabled: Boolean
}

type UpdateBoostSettingsPayload {
  channel: Channel
  error: UpdateBoostSettingsError
}

enum UpdateBroadcastSettingsErrorCode {
  AUTH_FAILURE
  REQUESTS_THROTTLED
  LANGUAGE_NOT_VALID
  STATUS_TOO_LONG
  STATUS_USES_BANNED_WORDS
  GAME_NAME_TOO_LONG
  UNKNOWN_ERROR
}

input UpdateBroadcastSettingsInput {
  broadcasterLanguage: String
  game: String
  isMature: Boolean
  status: String
  userID: ID!
}

type UpdateBroadcastSettingsPayload {
  broadcastSettings: BroadcastSettings
  error: UpdateBroadcastSettingsErrorCode
}

input UpdateCelebrationConfigInput {
  channelID: ID!
  isEnabled: Boolean!
}

type UpdateCelebrationConfigPayload {
  celebrationConfig: CelebrationConfig
  error: CelebrationError
}

input UpdateCelebrationInput {
  area: CelebrationArea
  celebrationID: ID!
  channelID: ID!
  durationMilliseconds: Int
  effect: CelebrationEffect
  eventThreshold: Int
  eventType: CelebrationEventType
  intensity: Int
  isEnabled: Boolean
}

type UpdateCelebrationPayload {
  celebration: Celebration
  error: CelebrationError
}

input UpdateCelebrationProductConfigInput {
  celebrationProducts: [CelebrationProductConfigInput!]!
  channelID: ID!
}

type UpdateCelebrationProductConfigPayload {
  celebrationProducts: [CelebrationProduct!]
  error: CelebrationError
}

input UpdateCelebrationUserSettingsInput {
  isOptedOut: Boolean
}

type UpdateCelebrationUserSettingsPayload {
  currentUser: User
}

type UpdateChangelogReadTimePayload {
  user: User
}

input UpdateChanletContentAttributesInput {
  chanletID: ID!
  contentAttributeIDs: [ID!]
}

type UpdateChanletContentAttributesPayload {
  chanlet: Channel
}

enum UpdateChannelCategoryShelfError {
  FORBIDDEN
  INVALID_CATEGORY
  CANNOT_SHOW_AND_HIDE_CATEGORY
}

input UpdateChannelClipsSettingInput {
  channelID: ID!
  creationRestrictedTo: ChannelClipsCreationRestrictedToInput
  creationRestrictionOptions: ChannelClipsCreationAuthRestrictionOptionsInput
  isClipsEnabled: Boolean!
}

type UpdateChannelClipsSettingPayload {
  channel: Channel
}

input UpdateChannelHomePreferencesInput {
  categoryIDsToHide: [ID!]
  categoryIDsToUnhide: [ID!]
  channelID: ID!
  heroPreset: HeroPreset
  streamerShelfType: StreamerShelfType
  isStreamScheduleSyncDisabled: Boolean
}

type UpdateChannelHomePreferencesPayload {
  channel: Channel
  error: UpdateChannelCategoryShelfError
}

type UpdateChannelPredictionSettingsError {
  code: UpdateChannelPredictionSettingsErrorCode!
}

enum UpdateChannelPredictionSettingsErrorCode {
  FORBIDDEN
  UNKNOWN
}

input UpdateChannelPredictionSettingsInput {
  canModeratorsManagePredictions: Boolean
  channelID: ID!
}

type UpdateChannelPredictionSettingsPayload {
  error: UpdateChannelPredictionSettingsError
  settings: ChannelPredictionSettings
}

input UpdateChatColorInput {
  color: String!
}

type UpdateChatColorPayload {
  user: User
}

input UpdateChatSettingsInput {
  autoModLevel: Int
  channelID: String!
  chatDelayInMs: Int
  followersOnlyDurationMinutes: Int
  hideLinks: Boolean
  isBroadcasterLanguageModeEnabled: Boolean
  isEmoteOnlyModeEnabled: Boolean
  isOptedOutOfGlobalBannedWordsList: Boolean
  isUniqueChatModeEnabled: Boolean
  requireVerifiedAccount: Boolean
  rules: [String!]
  slowModeDurationSeconds: Int
}

type UpdateChatSettingsPayload {
  chatSettings: ChatSettings
}

type UpdateCheermoteTierError {
  code: UpdateCheermoteTierErrorCode!
}

enum UpdateCheermoteTierErrorCode {
  INVALID_OWNER
  INVALID_IMAGE_UPLOAD
  EMOTE_IMAGE_NOT_FOUND
  NOT_ENOUGH_EMOTE_IMAGE_ASSETS
  TOO_MANY_EMOTE_IMAGE_ASSETS
  EMOTE_MISSING_STATIC_ASSET
  EMOTE_MISSING_ANIMATED_ASSET
  UNKNOWN_ERROR
}

input UpdateCheermoteTierInput {
  imageAssets: [EmoteImageAssetInput!]!
  tierThreshold: CheermoteTierThreshold!
  userID: ID!
}

type UpdateCheermoteTierPayload {
  error: UpdateCheermoteTierError
}

input UpdateCheerPartnerSettingsBadgesInput {
  tiers: [BitsBadgeTierInput!]
}

input UpdateCheerPartnerSettingsChatMessageInput {
  isOptedOutOfProjectV: Boolean
  minBitsPerEmote: Int
  minBitsToCheer: Int
}

input UpdateCheerPartnerSettingsCheerBombInput {
  isOptedOut: Boolean
}

input UpdateCheerPartnerSettingsCustomPrefixInput {
  isEnabled: Boolean
}

input UpdateCheerPartnerSettingsInput {
  badges: UpdateCheerPartnerSettingsBadgesInput
  chatMessage: UpdateCheerPartnerSettingsChatMessageInput
  cheerBombEvent: UpdateCheerPartnerSettingsCheerBombInput
  customPrefix: UpdateCheerPartnerSettingsCustomPrefixInput
  isOnboarded: Boolean
  leaderboard: UpdateCheerPartnerSettingsLeaderboardInput
  recentCheer: UpdateCheerPartnerSettingsRecentCheerInput
  sponsoredCheermote: UpdateCheerPartnerSettingsSponsoredCheermoteInput
  userID: ID!
}

input UpdateCheerPartnerSettingsLeaderboardInput {
  isEnabled: Boolean
  timePeriod: String
}

type UpdateCheerPartnerSettingsPayload {
  cheer: CheerPartnerSettings!
}

input UpdateCheerPartnerSettingsRecentCheerInput {
  canPin: Boolean
  minimumBits: Int
  timeoutMilliseconds: Int
}

input UpdateCheerPartnerSettingsSponsoredCheermoteInput {
  id: ID!
  isOptedIn: Boolean!
}

type UpdateClipError {
  message: String
}

input UpdateClipInput {
  slug: ID!
  title: String
}

type UpdateClipPayload {
  clip: Clip!
  error: UpdateClipError
}

input UpdateClipViewCountInput {
  slug: ID!
}

type UpdateClipViewCountPayload {
  clip: Clip
}

input UpdateCollectionInput {
  collectionID: ID!
  description: String
  thumbnailInput: UpdateCollectionThumbnailInput
  title: String
  type: CollectionType
}

type UpdateCollectionPayload {
  collection: Collection!
}

input UpdateCollectionThumbnailInput {
  id: ID!
  type: String!
}

type UpdateCommunityPointsAutomaticRewardError {
  code: UpdateCommunityPointsAutomaticRewardErrorCode
  minimumCost: Int
}

enum UpdateCommunityPointsAutomaticRewardErrorCode {
  UNKNOWN
  FORBIDDEN
  COST_TOO_LOW
  COST_INVALID
  BACKGROUND_COLOR_INVALID
}

input UpdateCommunityPointsAutomaticRewardInput {
  backgroundColor: String
  channelID: ID!
  cost: Int
  isEnabled: Boolean
  rewardType: CommunityPointsAutomaticRewardType!
  shouldResetBackgroundColor: Boolean
  shouldResetCost: Boolean
  shouldResetImage: Boolean
}

type UpdateCommunityPointsAutomaticRewardPayload {
  error: UpdateCommunityPointsAutomaticRewardError
  reward: CommunityPointsAutomaticReward
}

type UpdateCommunityPointsChannelSettingsError {
  code: UpdateCommunityPointsChannelSettingsErrorCode
}

enum UpdateCommunityPointsChannelSettingsErrorCode {
  UNKNOWN
  FORBIDDEN
  NAME_AUTOMOD_FAILED
}

input UpdateCommunityPointsChannelSettingsInput {
  channelID: ID!
  isEnabled: Boolean
  name: String
  shouldResetImage: Boolean
  shouldResetName: Boolean
}

type UpdateCommunityPointsChannelSettingsPayload {
  channel: Channel
  error: UpdateCommunityPointsChannelSettingsError
}

type UpdateCommunityPointsCommunityGoalError {
  code: UpdateCommunityPointsCommunityGoalErrorCode!
}

enum UpdateCommunityPointsCommunityGoalErrorCode {
  DUPLICATE_GOAL
  TITLE_AUTOMOD_FAILED
  TITLE_INVALID
  DESCRIPTION_AUTOMOD_FAILED
  DESCRIPTION_INVALID
  GOAL_AMOUNT_INVALID
  DURATION_INVALID
  BACKGROUND_COLOR_INVALID
  GOAL_STARTED
  INVALID_STATUS_CHANGE
  NOT_FOUND
  FORBIDDEN
  UNKNOWN
}

input UpdateCommunityPointsCommunityGoalInput {
  amountNeeded: Int
  backgroundColor: String
  channelID: ID!
  description: String
  durationDays: Int
  endsAt: Time
  goalID: ID!
  resetBackgroundColor: Boolean
  resetImage: Boolean
  resetMaxContributionPerStream: Boolean
  status: CommunityPointsCommunityGoalStatus
  title: String
}

type UpdateCommunityPointsCommunityGoalPayload {
  error: UpdateCommunityPointsCommunityGoalError
  goal: CommunityPointsCommunityGoal
}

type UpdateCommunityPointsCustomRewardError {
  code: UpdateCommunityPointsCustomRewardErrorCode!
}

enum UpdateCommunityPointsCustomRewardErrorCode {
  UNKNOWN
  FORBIDDEN
  NOT_FOUND
  TITLE_AUTOMOD_FAILED
  PROMPT_AUTOMOD_FAILED
  COST_INVALID
  MAX_PER_STREAM_INVALID
  TITLE_INVALID
  BACKGROUND_COLOR_INVALID
  DUPLICATE_REWARD
  MAX_PER_USER_PER_STREAM_INVALID
  GLOBAL_COOLDOWN_INVALID
}

input UpdateCommunityPointsCustomRewardInput {
  backgroundColor: String
  channelID: ID!
  cost: Int
  globalCooldownSetting: CommunityPointsCustomRewardGlobalCooldownSettingInput
  hasRealWorldValue: Boolean
  isEnabled: Boolean
  isPaused: Boolean
  isSubOnly: Boolean
  isUserInputRequired: Boolean
  maxPerStreamSetting: CommunityPointsCustomRewardMaxPerStreamSettingInput
  maxPerUserPerStreamSetting: CommunityPointsCustomRewardMaxPerUserPerStreamSettingInput
  prompt: String
  rewardID: ID!
  shouldRedemptionsSkipRequestQueue: Boolean
  shouldResetImage: Boolean
  title: String
}

type UpdateCommunityPointsCustomRewardPayload {
  error: UpdateCommunityPointsCustomRewardError
  reward: CommunityPointsCustomReward
}

type UpdateCommunityPointsCustomRewardRedemptionStatusError {
  code: UpdateCommunityPointsCustomRewardRedemptionStatusErrorCode
}

enum UpdateCommunityPointsCustomRewardRedemptionStatusErrorCode {
  NOT_FOUND
  FORBIDDEN
}

input UpdateCommunityPointsCustomRewardRedemptionStatusesByChannelInput {
  channelID: ID!
  newStatus: CommunityPointsCustomRewardRedemptionStatus!
  oldStatus: CommunityPointsCustomRewardRedemptionStatus!
}

type UpdateCommunityPointsCustomRewardRedemptionStatusesByChannelPayload {
  error: UpdateCommunityPointsCustomRewardRedemptionStatusesError
}

input UpdateCommunityPointsCustomRewardRedemptionStatusesByRedemptionsInput {
  channelID: ID!
  newStatus: CommunityPointsCustomRewardRedemptionStatus!
  oldStatus: CommunityPointsCustomRewardRedemptionStatus!
  redemptionIDs: [ID!]!
}

type UpdateCommunityPointsCustomRewardRedemptionStatusesByRedemptionsPayload {
  error: UpdateCommunityPointsCustomRewardRedemptionStatusesError
}

input UpdateCommunityPointsCustomRewardRedemptionStatusesByRewardInput {
  channelID: ID!
  newStatus: CommunityPointsCustomRewardRedemptionStatus!
  oldStatus: CommunityPointsCustomRewardRedemptionStatus!
  rewardID: ID!
}

type UpdateCommunityPointsCustomRewardRedemptionStatusesByRewardPayload {
  error: UpdateCommunityPointsCustomRewardRedemptionStatusesError
}

type UpdateCommunityPointsCustomRewardRedemptionStatusesError {
  code: UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCode
}

enum UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCode {
  UNKNOWN
  FORBIDDEN
  IN_PROGRESS
}

input UpdateCommunityPointsCustomRewardRedemptionStatusInput {
  channelID: ID!
  newStatus: CommunityPointsCustomRewardRedemptionStatus!
  redemptionID: ID!
}

type UpdateCommunityPointsCustomRewardRedemptionStatusPayload {
  error: UpdateCommunityPointsCustomRewardRedemptionStatusError
  redemption: CommunityPointsCustomRewardRedemption
}

type UpdateCommunityPointsEarlyAccessError {
  code: UpdateCommunityPointsEarlyAccessErrorCode!
}

enum UpdateCommunityPointsEarlyAccessErrorCode {
  FORBIDDEN
  UNKNOWN
}

input UpdateCommunityPointsEarlyAccessSettingsInput {
  isSignedUp: Boolean!
}

type UpdateCommunityPointsEarlyAccessSettingsPayload {
  channel: Channel
  error: UpdateCommunityPointsEarlyAccessError
}

type UpdateCommunityPointsLastViewedContentError {
  code: UpdateCommunityPointsLastViewedContentErrorCode
}

enum UpdateCommunityPointsLastViewedContentErrorCode {
  UNKNOWN
  FORBIDDEN
}

input UpdateCommunityPointsLastViewedContentInput {
  channelID: ID!
  viewedContent: [CommunityPointsContentType!]!
}

type UpdateCommunityPointsLastViewedContentPayload {
  error: UpdateCommunityPointsLastViewedContentError
  lastViewedChannelContent: [CommunityPointsLastViewedContentByType!]
  lastViewedGlobalContent: [CommunityPointsLastViewedContentByTypeAndID!]
}

type UpdateCommunityPointsSmartCostsAcknowledgementsError {
  code: UpdateCommunityPointsSmartCostsAcknowledgementsErrorCode
}

enum UpdateCommunityPointsSmartCostsAcknowledgementsErrorCode {
  UNKNOWN
  FORBIDDEN
  LAST_ACKNOWLEDGED_COST_INVALID
}

input UpdateCommunityPointsSmartCostsAcknowledgementsInput {
  acknowledgements: [SmartCostsAcknowledgementInput!]!
  channelID: ID!
}

type UpdateCommunityPointsSmartCostsAcknowledgementsPayload {
  acknowledgements: [SmartCostsAcknowledgement!]
  error: UpdateCommunityPointsSmartCostsAcknowledgementsError
}

input UpdateCompetitionContactInfoInput {
  discordURL: String
  email: String
}

input UpdateCompetitionInput {
  bannerImageURL: String
  checkInDurationMinutes: Int
  description: String
  endAt: Time
  formatType: FormatType
  gameID: ID
  id: ID!
  imageURL: String
  leaderboardDetails: UpdateCompetitionLeaderboardDetailsInput
  name: String
  participantOnlyContactInfo: UpdateCompetitionContactInfoInput
  prizeDescription: String
  publicContactInfo: UpdateCompetitionContactInfoInput
  registrationEndAt: Time
  registrationLimit: Int
  rulesDescription: String
  startAt: Time
  state: CompetitionState
  teamSize: Int
  termsURL: String
}

input UpdateCompetitionLeaderboardDetailsInput {
  lobbyMaxSize: Int
  phaseCount: Int
  tiebreakerLabel: TiebreakerLabel
}

type UpdateCompetitionPayload {
  competition: Competition
  error: CompetitionError
}

input UpdateCompetitionPlayerInput {
  competitionID: ID!
  discordUsername: String
  inGameUsername: String
  isDisqualified: Boolean
  state: CompetitionPlayerState
  userID: ID!
}

type UpdateCompetitionPlayerPayload {
  competition: Competition
  error: CompetitionError
}

input UpdateCompetitionTeamInput {
  captainID: ID
  competitionID: ID!
  isDisqualified: Boolean
  members: [ID!]
  teamID: ID!
  teamName: String
}

type UpdateCompetitionTeamPayload {
  competition: Competition
  error: CompetitionError
}

type UpdateConsentError {
  code: UpdateConsentErrorCode
}

enum UpdateConsentErrorCode {
  INVALID_VENDOR_LAW_CONSENT_STATUS
}

input UpdateConsentInput {
  consentSessionID: ID!
  privacyLawName: PrivacyLawName!
  vendorStatus: [VendorConsentStatusInput!]!
}

type UpdateConsentPayload {
  consent: Consent
  error: UpdateConsentError
}

input UpdateContentTagsInput {
  addedTagIDs: [ID!]
  authorID: ID!
  contentID: ID!
  contentType: ContentType!
  removedTagIDs: [ID!]
}

type UpdateContentTagsPayload {
  content: TaggedContent
}

enum UpdateDashboardViewMosaicLayoutErrorCode {
  UNKNOWN
  NOT_FOUND
  INVALID_ARGUMENT_NAME
  INVALID_ARGUMENT_LAYOUT
  INVALID_ARGUMENT_VERSION
  INVALID_ARGUMENT_LAYOUTID
  INVALID_ARGUMENT_USERID
  INVALID_ARGUMENT
}

input UpdateDashboardViewMosaicLayoutInput {
  data: MosaicData
  id: ID!
  name: String
  version: String
}

type UpdateDashboardViewMosaicLayoutPayload {
  errorCode: UpdateDashboardViewMosaicLayoutErrorCode
  layout: ChannelDashboardLayout
}

input UpdateDropBenefitInput {
  accountLinkURL: String!
  benefitID: ID!
  entitlementLimit: Int!
  gameID: ID!
  isIosAvailable: Boolean
  name: String!
  ownerID: ID!
}

input UpdateDropBenefitOnDropInput {
  benefitID: ID!
  dropEntitlementLimit: Int!
  dropID: ID!
}

type UpdateDropBenefitOnDropPayload {
  dropCampaign: DropCampaign
  error: DropsError
}

type UpdateDropBenefitPayload {
  dropBenefit: DropBenefit
  error: DropsError
}

input UpdateDropPreconditionsInput {
  campaignID: ID!
  dropPreconditions: [DropPrecondition]!
}

type UpdateDropPreconditionsPayload {
  dropCampaign: DropCampaign
  error: DropsError
}

input UpdateDropsOptOutStatusInput {
  isOptedOut: Boolean!
  userID: ID!
}

type UpdateDropsOptOutStatusPayload {
  isOptedOut: Boolean
  userID: ID
}

type UpdateEmoteOrdersError {
  code: UpdateEmoteOrdersErrorCode!
}

enum UpdateEmoteOrdersErrorCode {
  UNAUTHORIZED
  BAD_EMOTE_REQUEST
  BAD_GROUP_REQUEST
  BAD_NON_UNIQUE_ORDERS_REQUEST
  UNKNOWN_ERROR
}

input UpdateEmoteOrdersInput {
  orders: [EmoteOrder!]!
}

type UpdateEmoteOrdersPayload {
  emotes: [Emote!]
  error: UpdateEmoteOrdersError
}

enum UpdateExtensionDiscoveryDataError {
  UNAUTHORIZED
  INVALID_VERSION
  INVALID_NAME_LENGTH
  INVALID_DESCRIPTION_LENGTH
  INVALID_SUMMARY_LENGTH
  INVALID_AUTHOR_EMAIL
  INVALID_SUPPORT_EMAIL
  INVALID_AUTHOR_NAME_LENGTH
  INVALID_TESTING_BASE_URI
  INVALID_TERMS_URI
  INVALID_PRIVACY_URI
}

input UpdateExtensionDiscoveryDataInput {
  discoveryManifest: ExtensionDiscoveryManifestInput!
  id: ID!
  version: String!
}

type UpdateExtensionDiscoveryDataPayload {
  error: UpdateExtensionDiscoveryDataError
  manifest: ExtensionVersionDiscoveryManifest
}

enum UpdateExtensionManifestError {
  UNAUTHORIZED
  INVALID_VERSION
  ANCHOR_REQUIRED
  INVALID_ZOOM
  MAX_BROADCASTERS
  MAX_TESTERS
  MAX_WHITELISTED_CONFIG_URLS
  MAX_WHITELISTED_PANEL_URLS
  INVALID_NAME_LENGTH
  INVALID_DESCRIPTION_LENGTH
  INVALID_SUMMARY_LENGTH
  INVALID_AUTHOR_EMAIL
  INVALID_SUPPORT_EMAIL
  INVALID_AUTHOR_NAME_LENGTH
  INVALID_TESTING_BASE_URI
  INVALID_TERMS_URI
  INVALID_PRIVACY_URI
  INVALID_COMPONENT_VIEWER_PATH
  INVALID_PANEL_VIEWER_PATH
  INVALID_VIDEO_OVERLAY_VIEWER_PATH
  INVALID_CONFIG_VIEWER_PATH
  INVALID_LIVE_CONFIG_VIEWER_PATH
  INVALID_MOBILE_VIEWER_PATH
  INVALID_COMPONENT_ASPECT_WIDTH
  INVALID_COMPONENT_ASPECT_HEIGHT
  INVALID_PANEL_HEIGHT
  INVALID_BITS_SUPPORT_LEVEL
}

input UpdateExtensionManifestInput {
  assetManifest: ExtensionAssetManifestInput!
  capabilities: ExtensionCapabilitiesInput!
  developerManifest: ExtensionDeveloperManifestInput!
  discoveryManifest: ExtensionDiscoveryManifestInput!
  id: ID!
  version: String!
  views: ExtensionViewsInput!
}

type UpdateExtensionManifestPayload {
  error: UpdateExtensionManifestError
  manifest: ExtensionManifest
}

input UpdateHypeTrainConfigInput {
  calloutEmoteID: ID
  cooldownPeriodMinutes: Int
  difficulty: HypeTrainDifficulty
  isEnabled: Boolean
  kickoff: HypeTrainKickoffInput
  shouldUsePersonalizedSettings: Boolean
  willUseCreatorColor: Boolean
}

type UpdateHypeTrainConfigPayload {
  config: HypeTrainConfig
}

input UpdateIsSharingActivityInput {
  isSharingActivity: Boolean!
}

type UpdateIsSharingActivityPayload {
  user: User
}

input UpdateLeaderboardSettingsInput {
  defaultLeaderboard: LeaderboardType
  isCheerEnabled: Boolean
  isSubGiftEnabled: Boolean
  timePeriod: LeaderboardTimePeriodType
  userID: ID!
}

type UpdateLeaderboardSettingsPayload {
  user: User
}

input UpdateLiveUpNotificationInput {
  liveUpNotification: String!
  userID: ID!
}

type UpdateLiveUpNotificationPayload {
  broadcastSettings: BroadcastSettings
  error: UpdateLiveUpNotificationValidationError
}

type UpdateLiveUpNotificationValidationError {
  code: UpdateLiveUpNotificationValidationErrorCode!
}

enum UpdateLiveUpNotificationValidationErrorCode {
  FAILED_AUTOMOD
  TOO_LONG
  USER_NOT_FOUND
}

input UpdateLobbyParticipantScoreInput {
  competitionID: ID!
  lobbyID: ID!
  participantID: ID!
  phaseID: ID!
  score: Int!
}

type UpdateLobbyParticipantScorePayload {
  competition: Competition
  error: CompetitionError
}

input UpdateLWATokenInput {
  grant: String!
  grantType: GrantType!
}

type UpdateLWATokenPayload {
  error: WatchPartyError
  token: LWAToken
}

input UpdateMultiviewContentAttributesInput {
  params: [MultiviewContentAttributeParams!]!
}

type UpdateMultiviewContentAttributesPayload {
  failedUpdates: [MultiviewContentAttribute!]!
  succeededUpdates: [MultiviewContentAttribute!]!
}

input UpdateOnboardingSkippedChannelsInput {
  channelIDs: [ID!]!
  userID: ID!
}

type UpdateOnboardingSkippedChannelsPayload {
  user: User
}

type UpdateOrganizationMemberRoleError {
  code: UpdateOrganizationMemberRoleErrorCode!
}

enum UpdateOrganizationMemberRoleErrorCode {
  MEMBER_NOT_FOUND
  MEMBER_INELIGIBLE
  PERMISSION_DENIED
  INVALID_ARGUMENT
}

input UpdateOrganizationMemberRoleInput {
  organizationID: ID!
  role: OrganizationMemberRole!
  userID: ID!
}

type UpdateOrganizationMemberRolePayload {
  error: UpdateOrganizationMemberRoleError
  organizationMember: OrganizationMember
}

input UpdateOwnerChanletAttributesInput {
  channelID: ID!
  isChanletFeatureEnabled: Boolean!
}

type UpdateOwnerChanletAttributesPayload {
  ownerChanletAttributes: OwnerChanletAttributes
}

input UpdatePanelInput {
  description: String
  id: ID!
  imageURL: String
  linkURL: String
  slotID: String
  title: String
}

type UpdatePanelPayload {
  panel: Panel!
}

type UpdatePhoneNumberConfirmationError {
  code: UpdatePhoneNumberConfirmationErrorCode!
  message: String!
}

enum UpdatePhoneNumberConfirmationErrorCode {
  REAUTH_NEEDED
  INVALID_PHONE_NUMBER
  REQUEST_THROTTLED
  LIMIT_REACHED
  INVALID_OTP
  MISSING_OTP
  UNKNOWN_ERROR
}

input UpdatePhoneNumberConfirmationInput {
  oneTimePassword: String!
  phoneNumber: String!
  userID: ID!
}

type UpdatePhoneNumberConfirmationPayload {
  error: UpdatePhoneNumberConfirmationError
}

type UpdatePhoneNumberError {
  code: UpdatePhoneNumberErrorCode!
  message: String!
}

enum UpdatePhoneNumberErrorCode {
  REAUTH_NEEDED
  INVALID_PHONE_NUMBER
  REQUEST_THROTTLED
  LIMIT_REACHED
  UNKNOWN_ERROR
}

input UpdatePhoneNumberInput {
  phoneNumber: String!
  userID: ID!
}

type UpdatePhoneNumberPayload {
  error: UpdatePhoneNumberError
}

type UpdatePrimeOfferStatusError {
  code: UpdatePrimeOfferStatusErrorCode!
}

enum UpdatePrimeOfferStatusErrorCode {
  OFFERS_FAILED_TO_UPDATE
  UNKNOWN
}

input UpdatePrimeOfferStatusInput {
  statusChanges: [OfferAndStatus!]!
  userID: ID!
}

type UpdatePrimeOfferStatusPayload {
  error: UpdatePrimeOfferStatusError
  self: [PrimeOfferSelfConnection!]!
}

input UpdatePrimeSettingsInput {
  primeEmoticonsSetName: PrimeEmoticonsSetName
  shouldEnableSubCreditChatNotification: Boolean
  userID: ID!
}

type UpdatePrimeSettingsPayload {
  primeSettings: PrimeSettings
}

input UpdateRaidSettingsInput {
  incomingRaidsPolicy: IncomingRaidsPolicy
  userID: ID!
}

type UpdateRaidSettingsPayload {
  user: User
}

type UpdateRoomError {
  code: UpdateRoomErrorCode!
  maxLength: Int
  minLength: Int
}

enum UpdateRoomErrorCode {
  FORBIDDEN
  ROOM_NOT_FOUND
  NAME_LENGTH_INVALID
  NAME_CONTAINS_INVALID_CHARACTERS
  NAME_INAPPROPRIATE
  NAME_NOT_UNIQUE
  TOPIC_LENGTH_INVALID
  TOPIC_INAPPROPRIATE
  ROLES_INVALID
}

input UpdateRoomInput {
  isPreviewable: Boolean
  minimumAllowedRole: RoomRole
  minimumReadMessagesRole: RoomRole
  minimumSendMessagesRole: RoomRole
  name: String
  roomID: ID!
  topic: String
}

type UpdateRoomModesError {
  code: UpdateRoomModesErrorCode!
  maximumSlowModeDurationSeconds: Int
  minimumSlowModeDurationSeconds: Int
}

enum UpdateRoomModesErrorCode {
  ROOM_NOT_FOUND
  FORBIDDEN
  SLOW_MODE_DURATION_INVALID
}

input UpdateRoomModesInput {
  enableEmotesOnlyMode: Boolean
  enableR9KMode: Boolean
  enableSlowMode: Boolean
  roomID: ID!
  slowModeDurationSeconds: Int
}

type UpdateRoomModesPayload {
  error: UpdateRoomModesError
  room: Room
}

type UpdateRoomPayload {
  error: UpdateRoomError
  room: Room
}

input UpdateRoomViewInput {
  isArchived: Boolean
  isMuted: Boolean
  lastReadAt: Time
  roomID: ID!
}

type UpdateRoomViewPayload {
  roomView: RoomView
}

type UpdateScheduleSegmentError {
  code: UpdateScheduleSegmentErrorCode!
  conflictingSegment: ScheduleSegment
  maximum: Int
  minimum: Int
}

enum UpdateScheduleSegmentErrorCode {
  PERMISSION_DENIED
  INVALID_CATEGORY_COUNT
  NOT_FOUND
  NO_UPDATED_ATTRIBUTES_PROVIDED
  OVERLAPPING_SEGMENTS
  INVALID_TITLE
  TITLE_FAILED_MODERATION
  INVALID_TIMEZONE
  INVALID_CATEGORIES
  INVALID_START_DAY
  INVALID_START_HOUR
  INVALID_START_MINUTE
  INVALID_DURATION
  INVALID_SEGMENT
  INVALID_ARGUMENT
  FIRST_OCCURRENCE_DATE_IN_PAST
  FIRST_OCCURRENCE_DATE_ON_RECURRING_SEGMENT
  ALREADY_STARTED
}

input UpdateScheduleSegmentInput {
  categories: [ID!]
  durationMinutes: Int
  firstOccurrenceDate: Time
  isCancelled: Boolean
  scheduleID: ID!
  segmentID: ID!
  start: SegmentStartTimeInput
  timezone: String
  title: String
}

type UpdateScheduleSegmentPayload {
  error: UpdateScheduleSegmentError
  schedule: Schedule
}

input UpdateSeenCreatorOnboardingContentInput {
  onboardingContentIDs: [ID!]!
  userID: ID!
}

type UpdateSeenCreatorOnboardingContentPayload {
  user: User
}

enum UpdateSocialMediaError {
  FAILED_TITLE_MODERATION
  TITLE_TOO_LONG
  INVALID_URL
  NOT_FOUND
}

input UpdateSocialMediaInput {
  channelID: ID!
  id: ID!
  title: String
  url: String
}

type UpdateSocialMediaPayload {
  channel: Channel
  error: UpdateSocialMediaError
}

type UpdateSquadInvitePolicyError {
  code: UpdateSquadInvitePolicyErrorCode!
}

enum UpdateSquadInvitePolicyErrorCode {
  UNAUTHORIZED
}

input UpdateSquadInvitePolicyInput {
  incomingInvitePolicy: SquadStreamIncomingInvitePolicy!
  userID: ID!
}

type UpdateSquadInvitePolicyPayload {
  error: UpdateSquadInvitePolicyError
  user: User
}

type UpdateSquadStreamError {
  code: UpdateSquadStreamErrorCode!
}

enum UpdateSquadStreamErrorCode {
  SQUAD_NOT_FOUND
  SQUAD_CANNOT_BE_UPDATED
  SQUAD_TOO_FEW_MEMBERS
  UNAUTHORIZED
}

input UpdateSquadStreamInput {
  squadStreamID: ID!
  status: SquadStreamStatus
}

type UpdateSquadStreamPayload {
  error: UpdateSquadStreamError
  squadStream: SquadStream
}

input UpdateStuccoInput {
  channelID: ID!
  description: String!
  imageData1x: String!
  imageData2x: String!
  imageData4x: String!
  stuccoID: ID!
  suffix: String!
}

input UpdateStuccoPackInput {
  channelID: ID!
  stuccoPackID: ID!
  stuccos: [UpdateStuccoPackItemInput!]
}

input UpdateStuccoPackItemInput {
  slotIndex: Int!
  stuccoID: ID!
}

type UpdateStuccoPackPayload {
  stuccoPack: StuccoPack
}

type UpdateStuccoPayload {
  stucco: Stucco
}

input UpdateSubscriptionProductInput {
  displayName: String
  hasAdFree: Boolean
  hasFastChat: Boolean
  hasSubOnlyChat: Boolean
  hasSubOnlyVideoArchive: Boolean
  id: ID!
  targetUserID: ID!
}

type UpdateSubscriptionProductPayload {
  product: SubscriptionProduct
  targetUser: User
}

type UpdateUserColorsError {
  code: UpdateUserColorsErrorCode!
}

enum UpdateUserColorsErrorCode {
  INVALID_HEX_COLOR
}

input UpdateUserColorsInput {
  primaryColorHex: String!
  userID: ID!
}

type UpdateUserColorsPayload {
  error: UpdateUserColorsError
  user: User
}

input UpdateUserCreateDateHiddenInput {
  isCreateDateHidden: Boolean!
  userID: ID!
}

type UpdateUserCreateDateHiddenPayload {
  user: User
}

input UpdateUserDirectoryHiddenInput {
  IsDirectoryHidden: Boolean!
}

type UpdateUserDirectoryHiddenPayload {
  user: User
}

input UpdateUserEmailReusableInput {
  IsEmailReusable: Boolean!
  userID: ID!
}

type UpdateUserEmailReusablePayload {
  user: User
}

type UpdateUserError {
  code: UpdateUserErrorCode!
}

enum UpdateUserErrorCode {
  AUTH_FAILURE
  REQUESTS_THROTTLED
  USER_NOT_FOUND
  REAUTH_NEEDED
  DISPLAY_NAME_NOT_AVAILABLE
  DISPLAY_NAME_TOO_SHORT
  DISPLAY_NAME_TOO_LONG
  INVALID_CHARS_IN_DISPLAY_NAME
  DISPLAY_NAME_CHANGE_AGAIN
  DISPLAY_NAME_ONLY_CAP
  DISPLAY_NAME_UNEXPECTED_ERR
  LOGIN_NOT_AVAILABLE
  LOGIN_BLOCKED
  NOT_ALLOWED_TO_CHANGE_LOGIN
  LOGIN_TOO_SHORT
  LOGIN_TOO_LONG
  INVALID_CHARS_IN_LOGIN
  LOGIN_USE_BANNED_WORDS
  LOGIN_USE_VARIATION_ON_BANNED_WORDS
  FILTERED_USER_REQUESTED
  IP_BLOCKED
  TOO_MANY_USERS_FOR_EMAIL
  EMAIL_DISABLED_FOR_REUSE
  INVALID_EMAIL
  WORK_EMAIL_REQUIRED
  INVALID_EMAIL_DOMAIN
  NOT_ALLOWED_TO_CHANGE_EMAIL
  PHONE_NUMBER_INVALID
  PHONE_NUMBER_HAS_LETTERS
  DESCRIPTION_FAILED_MODERATION
  DESCRIPTION_TOO_LONG
  NO_PROPERTIES
  RESERVATION_NOT_EXITS
  LANGUAGE_NOT_VALID
  INVALID_BIRTHDAY
  INVALID_LAST_LOGIN
  INVALID_PARAMETER_COMBINATION
  NOT_ALLOWED_TO_DELETE_PHONE_NUMBER
  PHONE_NUMBER_ALREADY_EXISTS
  INVALID_HEX_COLOR
  UNKNOWN
}

input UpdateUserInput {
  deletePhoneNumber: Boolean
  description: String
  displayName: String
  email: String
  includeVerificationCode: Boolean
  userID: ID!
}

input UpdateUserIsEmailRevertSuccessInput {
  isEmailRevertSuccess: Boolean!
  userID: ID!
}

type UpdateUserIsEmailRevertSuccessPayload {
  user: User
}

type UpdateUserPayload {
  error: UpdateUserError
  user: User
}

type UpdateUserPredictionSettingsError {
  code: UpdateUserPredictionSettingsErrorCode!
}

enum UpdateUserPredictionSettingsErrorCode {
  UNKNOWN
}

input UpdateUserPredictionSettingsInput {
  hasAcceptedTOS: Boolean
  isTemporaryChatBadgeEnabled: Boolean
}

type UpdateUserPredictionSettingsPayload {
  error: UpdateUserPredictionSettingsError
  settings: UserPredictionSettings
}

input UpdateUserSubscriptionSettingsInput {
  giftsInFollowedChannelsOnly: Boolean
  isBadgeModifierHidden: Boolean
  isFounderBadgesHidden: Boolean
  isGiftCountHidden: Boolean
  isSubscriptionStatusHidden: Boolean
}

type UpdateUserSubscriptionSettingsPayload {
  subscriptionSettings: UserSubscriptionSettings
}

input UpdateUserTeamMembershipInput {
  primary: Boolean
  revenueRevealed: Boolean!
  statsRevealed: Boolean!
  teamID: ID!
  userID: ID!
}

type UpdateUserTeamMembershipPayload {
  user: User
}

type UpdateUserVideoShelvesError {
  code: Int!
  message: String
}

input UpdateUserVideoShelvesInput {
  channelID: ID!
  shelfOptions: [ShelvesAvailableOptions!]!
}

type UpdateUserVideoShelvesPayload {
  error: UpdateUserVideoShelvesError
  shelves: [VideoShelf]
}

input UpdateUserViewedVideoInput {
  position: Int!
  userID: ID!
  videoID: ID!
  videoType: VideoType!
}

type UpdateUserViewedVideoPayload {
  video: Video
}

input UpdateVideoCommentInput {
  commentID: ID!
  state: VideoCommentState!
}

type UpdateVideoCommentPayload {
  comment: VideoComment!
}

input UpdateVideoInput {
  description: String
  game: String
  language: String
  scope: VideoPrivacyScope
  thumbnailPath: String
  title: String
  videoID: ID!
}

type UpdateVideoPayload {
  video: Video
}

type UpdateVideoStreamSettingsError {
  code: UpdateVideoStreamSettingsErrorCode!
}

enum UpdateVideoStreamSettingsErrorCode {
  CHANNEL_NOT_FOUND
  PERMISSION_DENIED
  INVALID_ARGUMENT
}

input UpdateVideoStreamSettingsInput {
  channelID: ID!
  delaySeconds: Int
  isLowLatency: Boolean
  shouldArchiveVODs: Boolean
  shouldShowDisconnectSlate: Boolean
}

type UpdateVideoStreamSettingsPayload {
  channel: Channel
  error: UpdateVideoStreamSettingsError
}

type UpdateVideosViewabilityError {
  code: UpdateVideosViewabilityErrorCode!
}

enum UpdateVideosViewabilityErrorCode {
  INTERNAL_ERROR
  BAD_REQUEST
  PERMISSION_DENIED
  UNKNOWN
}

input UpdateVideosViewabilityInput {
  scope: VideoPrivacyScope
  videoIDs: [ID!]!
}

type UpdateVideosViewabilityPayload {
  error: UpdateVideosViewabilityError
}

input UpdateVisibilityInput {
  visibility: VisibilityInput!
}

type UpdateVisibilityPayload {
  user: User
}

input UpdateWhisperSettingsInput {
  isBlockingWhispersFromStrangers: Boolean
}

type UpdateWhisperSettingsPayload {
  user: User
}

input UpdateWhisperThreadInput {
  isArchived: Boolean
  isMuted: Boolean
  isSpam: Boolean
  lastReadMessageID: ID
  removeWhitelist: Boolean
  threadID: ID!
}

type UpdateWhisperThreadPayload {
  thread: WhisperThread!
}

input UploadCompetitionImageInput {
  competitionID: ID!
  imageType: CompetitionImageType!
}

type UploadCompetitionImagePayload {
  error: CompetitionUploadImageError
  image: CompetitionImageUpload
}

type UploadConfig {
  ID: ID!
  URL: String!
  assetType: EmoteAssetType!
  images: [UploadImage!]!
  size: EmoteImageSize!
}

type UploadImage {
  ID: ID!
  Size: EmoteImageSize!
  assetType: EmoteAssetType!
}

type URLMetadata {
  jsonld: String
  metatags: [SEOMetatag!]!
  share: URLMetadataShare!
  title: String!
}

type URLMetadataShare {
  text: String!
  title: String!
  url: String!
}

input UseChatNotificationTokenInput {
  channelLogin: String!
  includeStreak: Boolean!
  message: String
  tokenID: ID
}

type UseChatNotificationTokenPayload {
  isSuccess: Boolean!
}

type User {
  accountConnections: AccountConnectionSet!
  accountHealth: UserAccountHealth
  activeChallenges(
    first: Int = 10
    after: Cursor
    sort: ChannelChallengeSort = START_TIME
    direction: SortOrder = DESC
  ): ChannelChallengeConnection @deprecated
  activity: Activity
  adProperties: AdProperties
  amazon: UserAmazonConnection @deprecated(reason: "Retail sales discontinued")
  authenticatedSessionList: [AuthenticatedSession!]
  autoModProperties: AutoModProperties
  autoRefill: AutoRefill
  autohostChannels: AutohostChannelConnection
  autohostSettings: AutohostSettings
  autohostedByChannels: AutohostedByChannelConnection
    @deprecated(reason: "This functionality has been removed")
  availability: Availability
  availableBadges(domains: [BadgeDomain!]): [Badge]
  balances(walletType: WalletType): [Balance]
    @deprecated(reason: "Use walletBalances")
  bannedUsers: [ChannelBannedUser!]
  bannerImageURL: String
  bitsBalance: Int
  bitsEvents(
    first: Int = 50
    after: Cursor
    criteria: BitsEventConnectionCriteriaInput!
  ): BitsEventConnection
  bitsOffers: [BitsOffer]
  bitsPaymentMethods: BitsPaymentMethods
  bitsProducts(
    provider: BitsProductProvider!
    skus: [String!]
    paymentProvider: PaymentProvider
  ): [BitsProduct!]
  bitsUserSettings: BitsUserSettings
  bitsUserState: BitsUserState
  blizzardAccount: BlizzardUser
  blockedTerms: [ChannelBlockedTerm!]!
    @deprecated(reason: "Use channel.blockedTerms instead")
  blockedUsers: [User]!
  bounties(status: String!): [Bounty!]
    @deprecated(reason: "Use user.bountiesPage instead")
  bountiesPage(
    first: Int = 10
    after: Cursor
    status: String!
  ): BountyConnection
  bountyBoardSettings: BountyBoardSettings
  broadcastBadges: [Badge]
  broadcastSettings: BroadcastSettings
  campaign(campaignID: ID!): Campaign
    @deprecated(reason: "campaign events have been deprecated")
  campaignProperties: CampaignProperties
    @deprecated(reason: "campaign events have been deprecated")
  celebrationSettings: CelebrationUserSettings
  channel: Channel
  channelAnalyticsContentOverlap: ChannelAnalyticsContentOverlap
  channelFeed: Feed
  channelRooms: [Room]! @deprecated(reason: "The Rooms product has been sunset")
  chatColor: String
  chatSettings: ChatSettings
  chatUISettings: ChatUISettings
  cheer: CheerInfo
  clientAuthorizations: [ClientAuthorization!]
  clips(
    first: Int = 10
    after: Cursor
    criteria: UserClipsInput
  ): ClipConnection
  collections(
    first: Int = 10
    after: Cursor
    options: CollectionsOptions
  ): CollectionsConnection
  communityPoints: CommunityPointsUserProperties
  company: Company @deprecated(reason: "Use organizations instead.")
  competitions(
    first: Int = 10
    after: Cursor
    userState: CompetitionPlayerState
    competitionState: CompetitionState
    userCompetitionRelationship: UserCompetitionRelationship!
  ): CompetitionConnection
  createdAt: Time!
  creatorGifting: CreatorGifting
  creatorMetricsByInterval(
    startAt: Time!
    endAt: Time!
    timeZone: String
    numberOfIntervals: Int = 1
  ): CreatorMetricsByInterval
  creatorReferralLinks(
    first: Int = 1
    after: Cursor
  ): CreatorReferralLinkConnection
  creatorReferralSummary(startAt: Time!, endAt: Time!): CreatorReferralSummary!
  dashboardActivityFeedActivities(
    first: Int = 10
    after: Cursor
  ): DashboardActivityFeedActivityConnection
  dashboardAlertQueueActivities(
    first: Int = 10
    after: Cursor
  ): DashboardAlertQueueActivityConnection
  dashboardAlertQueuePreferences: DashboardAlertQueuePreferences
  deletedAt: Time
  description: String
  directories: UserDirectoryConnection
  displayBadges(channelID: ID, channelLogin: String): [Badge]!
  displayName: String!
  dmcaViolationCount: Int
  dropCampaign(id: ID!): DropCampaign
  dropCampaigns: [DropCampaign!]
  dropCurrentSession: DropCurrentSession
  editableChannels: EditableChannelConnection
  editors: EditorConnection
  email: String
  emoteSets(domains: [EmoteSetDomain!]): [EmoteSet!]
  emoticonPrefix: EmoticonPrefix
  endorsedChannels(
    first: Int = 10
    recommendationsContext: RecommendationsContext!
  ): EndorsedChannelConnection
  expiredSubscriptions(
    first: Int = 10
    after: Cursor
  ): ExpiredSubscriptionConnection
  featureFlags: FeatureFlags
    @deprecated(reason: "this functionality has been removed")
  follow(targetID: ID, targetLogin: String): Follow
    @deprecated(reason: "Use user.self.follower instead.")
  followedGames(
    first: Int = 10
    type: FollowedGamesType = ALL
  ): FollowedGameConnection
  followedHosts(first: Int = 10): FollowedHostConnection
    @deprecated(
      reason: "This field is intended to be replaced as soon as an alternative is available."
    )
  followedLiveUsers(
    first: Int = 10
    after: Cursor
    includeRestricted: [StreamRestrictionType!]
    sort: StreamSort = VIEWER_COUNT
  ): FollowedLiveUserConnection
    @deprecated(
      reason: "This field is intended to be replaced as soon as an alternative is available."
    )
  followedVideos(
    first: Int = 10
    after: Cursor
    languages: [String!]
    types: [BroadcastType!]
    sort: VideoSort = TIME
  ): VideoConnection
  followers(
    first: Int = 10
    after: Cursor
    order: SortOrder = ASC
  ): FollowerConnection
  follows(
    first: Int = 10
    after: Cursor
    filter: FollowsFilter = ALL
    order: SortOrder = ASC
  ): FollowConnection
  friends: FriendConnection
  goLiveNotificationConnection(
    startAt: Time!
    endAt: Time!
    first: Int = 100
    after: Cursor
    sort: SortOrder = DESC
  ): GoLiveNotificationConnection
  goLiveNotifications(
    startAt: Time!
    endAt: Time!
    first: Int = 100
    sort: SortOrder = DESC
  ): [GoLiveNotification!]
  goLiveNotificationsTimeseries(
    startAt: Time!
    endAt: Time!
    granularity: Granularity!
    numberOfIntervals: Int = 1
    timeZone: String!
  ): [GoLiveNotificationTimeseries!]
  hasBadgesTimedOut: Boolean!
    @deprecated(reason: "this functionality has been removed")
  hasPresto: Boolean
  hasPrime: Boolean!
  hasStreamed: Boolean
  hasTurbo: Boolean!
  hasUnreadChangelogItems: Boolean
  hero: Hero
  hostRecommendations: [User]
  hostedBy(first: Int = 10, after: Cursor): HostConnection
  hosting: User
  id: ID!
  idSHA1: ID!
  incomingFriendRequests(
    first: Int = 10
    after: Cursor
    sort: FriendSort = DESC
  ): IncomingFriendRequestConnection
  incomingSquadStreamInvitations: SquadStreamInvitationConnection
  installedExtensions: [ExtensionInstallation!]
  inventory: Inventory
  invitedTeams: [Team]
  isCommerceRevShareEnabled: Boolean!
    @deprecated(reason: "Game sales discontinued")
  isConnectedToTwitter: Boolean
  isEmailReusable: Boolean!
  isEmailUpdateable: Boolean!
  isEmailVerified: Boolean!
  isFlaggedToDelete: Boolean!
  isGlobalMod: Boolean!
    @deprecated(reason: "Use user.roles.isGlobalMod instead.")
  isInEmoteGoodStanding: Boolean
  isInGoodStanding: Boolean!
  isMinimumGDPRConsentAge: Boolean!
  isModerator(channelID: String!): Boolean!
  isPartner: Boolean @deprecated(reason: "Use user.roles.isPartner instead.")
  isPhoneNumberVerified: Boolean!
  isSiteAdmin: Boolean!
    @deprecated(reason: "Use user.roles.isSiteAdmin instead.")
  isStaff: Boolean! @deprecated(reason: "Use user.roles.isStaff instead.")
  keyPools(after: String): KeyPoolConnection
  language: Language
    @deprecated(reason: "Use user.settings.preferredLanguageTag instead.")
  lastBroadcast: Broadcast
  lastLoginChangeAt: Time
  lastStatusChangeAt: Time
  latestPoll: Poll
  linkedExtensions: [Extension!]
  login: String!
  logoURL(width: Int!): String
    @deprecated(reason: "Replaced by profileImageURL")
  loyaltyBadges: [LoyaltyBadge!]
  maxAllowedChannelRooms: Int!
    @deprecated(reason: "The Rooms product has been sunset")
  modLogs: ModLogs
  modLogsAccess: [ModLogsAccess!]
  modLogsRoleAccess(role: ChannelUserRole!): ModLogsAccess
  modViewSettings: ModViewSettings
  mods(first: Int = 10, after: Cursor): ModConnection
  notificationSettings: [EventNotificationSetting!]
  notifications(
    first: Int = 10
    after: Cursor
    language: String
    displayType: OnsiteNotificationDisplayType
    capabilities: [OnsiteNotificationsCapability!]
  ): OnsiteNotificationConnection
  oauthApps(after: Cursor): OAuthAppConnection
  offlineImageURL: String
  onboarding: Onboarding @deprecated(reason: "This feature has been sunset.")
  onboardingInvitations: OnboardingInvitations
  organizationInvites(
    first: Int = 10
    after: Cursor
  ): OrganizationInviteUserConnection
  organizations: [Organization!]
  outgoingFriendRequests(
    first: Int = 10
    after: Cursor
    sort: FriendSort = DESC
  ): OutgoingFriendRequestConnection
  ownedTeams: [Team]
  panels(hideExtensions: Boolean = false): [Panel]!
  participatingChallenges(
    first: Int = 10
    after: Cursor
    sort: ChannelChallengeSort = END_TIME
    direction: SortOrder = ASC
    status: [ChannelChallengeStatus!]
  ): ChannelChallengeConnection @deprecated
  partnershipApplication: PartnershipApplication
  payableStatus: PayableStatus
  paymentIncentiveMetrics: [PaymentIncentiveMetricsRollup!]
  paymentMethodConfigs: PaymentProviderConfigs
  paymentMethods: [PaymentMethod!]
  paymentTransactions(
    first: Int = 50
    after: Cursor
    criteria: PaymentTransactionConnectionCriteriaInput!
  ): PaymentTransactionConnection
  payout: Payout
  payoutBalance: PayoutBalance
  payoutInvite: PayoutInvite
  payoutPlans: [PayoutPlan!]
  permittedTerms: [ChannelPermittedTerm!]!
    @deprecated(reason: "Use channel.permittedTerms instead")
  phoneNumber: String
  polls(
    first: Int = 15
    after: Cursor
    sort: PollSort = START_TIME
    direction: SortOrder = DESC
    status: [PollStatus!]
  ): PollConnection
  predictionsSettings: UserPredictionSettings
  prerollFreeTimeSeconds: Int
  primaryColorHex: String
  primaryTeam: Team
  primePayoutDetails: PrimePayoutDetails
    @deprecated(reason: "Use primePayoutHistory, this will be removed soon")
  primePayoutHistory: [PrimePayoutDetail!]
  primeSettings: PrimeSettings
  profileImageURL(width: Int!): String
  profileURL: String!
  profileViewCount: Int
  programAgreement(invitationType: InvitationType = TOP): ProgramAgreement
  pulseFeed: Feed
  purchaseOrder(id: ID!): PurchaseOrder
  quests: Quests
  radio: Radio
  radioAccount: RadioAccount
    @deprecated(reason: "Use user.radio.account instead.")
  raid: Raid @deprecated(reason: "this feature has been moved")
  raidSettings: RaidSettings
  recentRaids: [Raid!]
  recommendationFeedback(
    limit: Int = 5
    after: Cursor
    type: String!
  ): RecommendationFeedbackConnection
  recommendations: Recommendations
  recommendedEmoticonPrefix: String!
  relationship(targetUserID: ID): UserRelationship
  residence: UserResidence
  rewardedVideo: RewardedVideo
  roles: UserRoles
  searchVideos(
    first: Int = 10
    after: Cursor
    search: VideoConnectionSearchParams
  ): VideoConnection
  seenCreatorOnboardingContent: [CreatorOnboardingContent!]
  selectedBadge: Badge
  self: UserSelfConnection
  selfInstalledExtensions(
    isMobile: Boolean = false
  ): [ExtensionInstallationSelfEdge!]
  settings: UserSettings
  squadStream: SquadStream
  squadStreamSettings: SquadStreamSettings
  ssoLinks(app: String): [SSOLink!]
    @deprecated(reason: "Service has been shut down")
  stream: Stream
  streamSessions(first: Int, lastStartedAt: Time): [StreamSession!]
  streamSessionsByInterval(startAt: Time!, endAt: Time!): [StreamSession!]
  streamSummaries(first: Int, lastStartedAt: Time): [StreamSummary!]
  stuccoPacksBroadcaster: [StuccoPack]
  stuccos: [Stucco]
  subscribedChannels(
    first: Int = 10
    after: Cursor
    live: Boolean
  ): SubscribedChannelConnection
  subscriberScore: SubscriberScore
  subscriptionBenefits(
    first: Int = 10
    after: Cursor
    criteria: SubscriptionBenefitCriteriaInput!
  ): SubscriptionBenefitConnection
  subscriptionProducts: [SubscriptionProduct]
  subscriptionProductsResult: SubscriptionProductsResult!
  subscriptionSettings: UserSubscriptionSettings
  subscriptionToken: SubscriptionToken
  tagAnalytics: [TagAnalytic!]
  tags: [Tag!]
  teamMemberships: [UserTeamMembership]
  timeseriesStats(
    startAt: Time!
    endAt: Time
    timeZone: String!
    granularity: Granularity = FIVE_MINUTE
  ): TimeseriesStats
  tournament: Tournament @deprecated
  twitch: UserTwitchConnection
  unacknowledgedSubscriptionEvents(
    platform: String!
  ): [UnacknowledgedSubscriptionEvent!]
  updatedAt: Time
  verificationRequest(address: String): VerificationRequest
  videoPlayReferrals(
    start: Time!
    end: Time!
    filter: ReferralsFilter = ALL
    dimension: ReferralsDimension!
    first: Int = 15
  ): VideoPlayReferrals
  videoShelves(
    first: Int = 10
    after: Cursor
    options: ShelvesOptions
  ): VideoShelfConnection
  videoShelvesAvailable(
    first: Int = 10
    after: Cursor
    options: ShelvesAvailableOptions
  ): VideoShelfConnection
  videos(
    first: Int = 10
    after: Cursor
    type: BroadcastType
    types: [BroadcastType!]
    sort: VideoSort = TIME
    options: VideoConnectionOptionsInput
  ): VideoConnection
  viewablePoll: Poll
  viewedVideos(first: Int = 10): ViewedVideosConnection
  vips(first: Int = 10, after: Cursor): VIPConnection
  walletBalances(
    walletType: WalletType
    bestGuessCountryCode: String
  ): WalletBalances
  watchPartiesRestrictions: [WatchPartiesRestriction!]
  watchParty(accessToken: String, decorated: Boolean = false): WatchPartyResult
  whisperSettings: WhisperSettings
  whisperThreads(first: Int = 10, after: Cursor): WhisperThreadConnection
  withholdingTaxDetail: WithholdingTaxDetail
}

type UserAccountHealth {
  isPasswordResetRequired: Boolean!
  isVerifiedEmail: Boolean!
  passwordStatus: PasswordStatus!
  twoFactorMethods: [TwoFactorMethod!]!
  isTwoFactorAccountShared: Boolean!
}

type UserAmazonConnection {
  associatesStore: AssociatesStore
}

type UserBlizzardConnectionLink {
  battleTag: String
}

input UserByAttribute {
  broadcasterOfClipSlug: String
  login: String
  ownsCollectionID: ID
  ownsVideoID: ID
}

input UserClipsInput {
  broadcasterID: ID
  curatorID: ID
  filter: ClipsFilter
  gameName: String
  period: ClipsPeriod = LAST_WEEK
  sort: ClipsSort = VIEWS_DESC
}

enum UserCompetitionRelationship {
  PLAYER
  OWNER
  UNKNOWN
}

type UserConnection {
  edges: [UserEdge!]
  pageInfo: PageInfo!
  totalCount: Int
}

type UserDirectoryConnection {
  nodes: [Directory]!
}

type UserDoesNotExist {
  key: String!
}

type UserDropAwardConnection {
  nodes: [DropAward]! @deprecated
  totalCount: Int @deprecated
}

type UserDropReward {
  benefit: DropBenefit!
  game: Game @deprecated(reason: "use benefit.Game")
  id: ID! @deprecated(reason: "use benefit.id")
  imageURL: String! @deprecated(reason: "use benefit.imageAssetURL")
  isConnected: Boolean!
  isIosAvailable: Boolean! @deprecated(reason: "use benefit.isIosAvailable")
  lastAwardedAt: Time!
  name: String! @deprecated(reason: "use benefit.name")
  requiredAccountLink: String! @deprecated(reason: "use benefit.accountLinkURL")
  totalCount: Int!
}

type UserEdge {
  cursor: Cursor
  node: User
}

type UserError {
  key: String!
}

type UserFacebookConnectionLink {
  fullName: String!
}

type UserLeaderboard {
  id: ID!
  items: UserLeaderboardItemConnection!
  myPosition: UserLeaderboardItem
  secondsRemaining: Int!
}

type UserLeaderboardItem {
  id: ID!
  rank: Int!
  score: Int!
  user: User
}

type UserLeaderboardItemConnection {
  edges: [UserLeaderboardItemEdge!]!
  pageInfo: PageInfo!
}

type UserLeaderboardItemEdge {
  cursor: Cursor!
  node: UserLeaderboardItem
}

enum UserLookupType {
  ACTIVE
  ALL
}

enum UserPredictionEventRestriction {
  CAN_MANAGE_PREDICTIONS
  REGION_LOCKED
  CATEGORY_REGION_LOCKED
}

type UserPredictionSettings {
  hasAcceptedTOS: Boolean!
  isInRestrictedRegion: Boolean
  isTemporaryChatBadgeEnabled: Boolean!
}

type UserPredictionStatistics {
  eventsTotal: Int!
  eventsWon: Int!
  mostRecentPrediction: Prediction
  pointsUsed: Int!
  pointsWon: Int!
  pointsWonMax: Int!
  winStreak: Int!
  winStreakMax: Int!
}

type UserRelationship {
  followedAt: Time
  predictionStatistics: UserPredictionStatistics
  subscriptionBenefit: SubscriptionBenefit
  subscriptionTenure(
    tenureMethod: SubscriptionTenureMethod!
  ): SubscriptionTenure
}

type UserResidence {
  countryCode: String!
  postalCode: String
}

union UserResult = User | UserDoesNotExist | UserError
type UserRiotConnectionLink {
  id: ID!
}

type UserRoles {
  isAffiliate: Boolean
  isExtensionsApprover: Boolean
    @deprecated(reason: "This role is no longer surfaced through the API")
  isExtensionsDeveloper: Boolean
  isGlobalMod: Boolean
  isPartner: Boolean
  isSiteAdmin: Boolean
  isStaff: Boolean
}

type UserSelfBitsBadge {
  current: Badge
  id: ID!
  next: Badge
  nextBits: Int
  progress: Float!
  tierNotification: BitsBadgeTierNotification
  totalBits: Int!
}

type UserSelfConnection {
  availableBadges: [Badge]
  banStatus: ChatRoomBanStatus
  bitsBadge: UserSelfBitsBadge
  bitsLeaderboardEntry: BitsLeaderboardEntry
    @deprecated(reason: "use user.self.bitsLeaderboardItem instead.")
  bitsLeaderboardItem: BitsLeaderboardItem
  bitsLeaderboardPosition: BitsLeaderboard
  canFollow: Boolean!
  canGift(product: String!): Boolean!
    @deprecated(
      reason: "Transitioning to SubscriptionProductSelfConnection instead"
    )
  canGiftInChannel(product: String!): Boolean!
    @deprecated(
      reason: "Transitioning to SubscriptionProductSelfConnection instead"
    )
  canPrimeSubscribe: Boolean!
  canRedeemSubscription: Boolean
  celebrationProducts: [CelebrationProduct]
  chatRestrictedReasons: [ChatRestrictedReason!]
  displayBadges: [Badge]!
  follower: FollowerEdge
  friendship: FriendRelationship
  isChannelMember: Boolean
  isEditor: Boolean
  isFounder: Boolean
  isModerator: Boolean
  isVIP: Boolean
  lastRecentChatMessageAt: Time
  primeSubCreditBenefit: PrimeSubCreditBenefit
  resubNotification: ResubNotification
  ritualTokens: [RitualToken!]
  selectedBadge: Badge
  stuccoPacksViewer: [StuccoPack]
  subscriberBadgeProgress(limit: Int = 5): [SubscriberBadgeProgress!]
  subscriptionBenefit: SubscriptionBenefit
  subscriptionGiftCount: Int
  subscriptionTenure(
    tenureMethod: SubscriptionTenureMethod!
  ): SubscriptionTenure
  whisperPermissions: WhisperPermissions
}

type UserSettings {
  canHostWatchParties: Boolean!
  channelFeedEnabled: Boolean! @deprecated
  cheer: CheerPartnerSettings
  hasTwoFactorEnabled: Boolean
  isAmazonRetailRevShareEnabled: Boolean
    @deprecated(reason: "Game sales discontinued")
  isCommerceRevShareEnabled: Boolean
    @deprecated(reason: "Game sales discontinued")
  isCreateDateHidden: Boolean
  isDirectoryHidden: Boolean
  isEmailRevertSuccess: Boolean
  isRitualsEnabled: Boolean!
  isRitualsWhitelisted: Boolean!
    @deprecated(reason: "Rituals is whitelisted only for launch.")
  isSharingActivity: Boolean!
  leaderboard: LeaderboardSettings
  preferredLanguageTag: LanguageTag
  visibility: Visibility!
}

type UserSteamConnectionLink {
  id: ID!
}

type UserSubscriptionSettings {
  giftsToFollowedChannelsOnly: Boolean!
  isBadgeModifierHidden: Boolean!
  isFounderBadgesHidden: Boolean!
  isGiftCountHidden: Boolean!
  isSubscriptionStatusHidden: Boolean!
}

type UserTeamMembership {
  isPrimary: Boolean!
  isRevenueRevealed: Boolean!
  isStatsRevealed: Boolean!
  team: Team!
}

type UserTwitchConnection {
  overwatchLeagueTeamPreference: OverwatchLeagueTeamPreference
}

type UserTwitterConnectionLink {
  username: String!
}

type UserYoutubeConnectionLink {
  channelURL: String!
}

type ValidateVerificationCodeError {
  code: ValidateVerificationCodeErrorCode
}

enum ValidateVerificationCodeErrorCode {
  INCORRECT_CODE
  TOO_MANY_FAILED_ATTEMPTS
  RATE_LIMITED
  UNKNOWN
}

input ValidateVerificationCodeInput {
  address: String!
  code: String!
  key: String!
}

type ValidateVerificationCodePayload {
  error: ValidateVerificationCodeError
  request: VerificationRequest
}

union VendorConsent = CCPAVendorConsent | GDPRVendorConsent | ROWVendorConsent
type VendorConsentStatus {
  consentStatus: ConsentStatus!
  hasUserSetConsent: Boolean!
  isVisible: Boolean!
  name: VendorName!
}

input VendorConsentStatusInput {
  consentStatus: ConsentStatus!
  name: VendorName!
}

enum VendorName {
  AMAZON
  TWITCH_AMAZON
  BRANCH
  COMSCORE
  GOOGLE
  NIELSEN
  SALESFORCE_DMP
  BEESWAX
  TRUEX
  THE_TRADE_DESK
  FLASHTALKING
  GAMESITE
  KANTAR
  SPOTX
  SIZMEK
  GOOGLE_ANALYTICS_DEVELOPER_EXTENSIONS
}

type VerificationRequest {
  address: String!
  key: String!
  modified: Time!
  status: VerificationStatus!
}

enum VerificationStatus {
  UNKNOWN
  PENDING
  VERIFIED
  REJECTED
}

input VerifyContactMethodInput {
  opaqueID: ID!
}

type VerifyContactMethodPayload {
  isSuccess: Boolean!
  request: VerificationRequest
}

type VerifyOneTimePasswordError {
  code: VerifyOneTimePasswordErrorCode!
  message: String!
}

enum VerifyOneTimePasswordErrorCode {
  REAUTH_NEEDED
  INVALID_OTP
  NO_TWO_FACTOR
  UNKNOWN_ERROR
}

input VerifyOneTimePasswordInput {
  oneTimePassword: String!
  userID: ID!
}

type VerifyOneTimePasswordPayload {
  error: VerifyOneTimePasswordError
}

type VerifyRewardedVideoEligibilityCaptchaError {
  code: VerifyRewardedVideoEligibilityCaptchaErrorCode!
}

enum VerifyRewardedVideoEligibilityCaptchaErrorCode {
  INVALID_PARAMETER
  INTERNAL_ERROR
}

input VerifyRewardedVideoEligibilityCaptchaInput {
  arkoseEndpointVersion: ArkoseEndpointVersion!
  sessionToken: String!
}

type VerifyRewardedVideoEligibilityCaptchaPayload {
  error: VerifyRewardedVideoEligibilityCaptchaError
}

union VerticalContentContext = Game | Tag
type VerticalDirectory {
  id: ID!
  name: String
  shelfGroups: [VerticalShelfGroup!]
  slug: String
  subtitle: ShelfTitle!
  title: ShelfTitle!
  trackingID: ID!
}

type VerticalShelf {
  content: ShelfContentConnection!
  contentContext: [VerticalContentContext!]
  id: ID!
  subtitle: ShelfTitle
  title: ShelfTitle
  trackingID: ID!
  type: VerticalShelfType!
}

type VerticalShelfGroup {
  contentContext: [VerticalContentContext!]
  id: ID!
  shelves: [VerticalShelf!]
  subtitle: ShelfTitle
  title: ShelfTitle
  trackingID: ID!
}

enum VerticalShelfType {
  CATEGORY_SELECTOR
  LIVE_MATCHES
  LIVE_PROS
  REPLAYS
  COLLECTION
}

type VerticalSubDirectory {
  contentContext: [VerticalContentContext!]
  id: ID!
  shelfGroups: [VerticalShelfGroup!]
  subtitle: ShelfTitle!
  title: ShelfTitle!
  trackingID: ID!
}

input VerticalSubDirectoryContentContext {
  categoryIDs: [ID!]
  tagIDs: [ID!]
}

type Video {
  animatedPreviewURL: String
  bookmarks(first: Int, after: Cursor): VideoBookmarkConnection
  broadcastType: BroadcastType
  clips(
    first: Int = 10
    after: Cursor
    curatorIDs: [ID!]
    sort: SortOrder = ASC
  ): ClipConnection
  comments(
    first: Int
    after: Cursor
    last: Int
    Before: Cursor
    contentOffsetSeconds: Int
  ): VideoCommentConnection
  contentTags: [Tag!]
  createdAt: Time
  creator: User
  deletedAt: Time
  description: String
  download: VideoDownload
  duration: Duration
    @deprecated(reason: "Use length instead, as it's easier to parse.")
  game: Game
  id: ID!
  isDeleted: Boolean!
  language: String
  lengthSeconds: Int
  moments(
    first: Int = 10
    after: Cursor
    sort: SortOrder = ASC
    types: [VideoMomentType]
    momentRequestType: VideoMomentRequestType
  ): VideoMomentConnection
  muteInfo: VideoMuteInfo
  offsetSeconds: Int
  owner: User
  playbackAccessToken(params: PlaybackAccessTokenParams!): PlaybackAccessToken
  previewThumbnailURL(height: Int, width: Int): String!
  publishedAt: Time
  reactions: [Reaction]
  recordedAt: Time
  resourceRestriction: ResourceRestriction
  restriction: VideoRestriction
    @deprecated(
      reason: "Restriction will be moved over to resourceRestriction instead"
    )
  scope: VideoPrivacyScope
  seekPreviewsURL: String
  self: VideoSelfEdge
  status: VideoStatus
  suggestedHighlight: VideoSuggestedHighlight
  tags: [String]
  thumbnailURLs(height: Int, width: Int): [String]
  title: String
  topClips(
    first: Int = 10
    after: Cursor
    criteria: VideoTopClipsInput
  ): ClipConnection
  updatedAt: Time
  viewCount: Int
  viewableAt: Time
}

type VideoBookmark {
  channel: User!
  createdAt: Time!
  description: String!
  id: ID!
  positionSeconds: Int!
  user: User!
}

type VideoBookmarkConnection {
  edges: [VideoBookmarkEdge]!
  error: VideoBookmarkConnectionError
  pageInfo: PageInfo!
}

type VideoBookmarkConnectionError {
  code: VideoBookmarkConnectionErrorCode
}

enum VideoBookmarkConnectionErrorCode {
  INTERNAL_SERVER_ERROR
  USER_UNAUTHORIZED
}

type VideoBookmarkEdge {
  cursor: Cursor!
  node: VideoBookmark!
}

type VideoComment {
  commenter: User
  contentOffsetSeconds: Int!
  createdAt: Time!
  id: ID!
  message: VideoCommentMessage
  replies(first: Int, after: Cursor): VideoCommentConnection @deprecated
  source: VideoCommentSource!
  state: VideoCommentState!
  updatedAt: Time!
  video: Video
}

type VideoCommentConnection {
  edges: [VideoCommentEdge]
  pageInfo: PageInfo!
}

type VideoCommentEdge {
  cursor: Cursor
  node: VideoComment
}

type VideoCommentMessage {
  fragments: [VideoCommentMessageFragment]
  userBadges: [Badge]
  userColor: String
}

type VideoCommentMessageFragment {
  emote: EmbeddedEmote
  mention: User
  text: String!
}

enum VideoCommentSource {
  CHAT
  COMMENT
  UNKNOWN
}

enum VideoCommentState {
  PUBLISHED
  UNPUBLISHED
  PENDING_REVIEW
  PENDING_REVIEW_SPAM
  DELETED
}

type VideoConnection {
  edges: [VideoEdge]
  pageInfo: PageInfo
  totalCount: Int
}

input VideoConnectionOptionsInput {
  gameIDs: [ID!]
  includePrivate: Boolean = false
  maxLengthSeconds: Int
  minLengthSeconds: Int
  searchRangeEndAt: Time
  searchRangeStartAt: Time
}

input VideoConnectionSearchParams {
  term: String
}

type VideoDownload {
  status: VideoDownloadStatus!
  url: String!
}

enum VideoDownloadStatus {
  CREATED
  SUBMITTED
  DOWNLOADING
  TRANSMUXING
  FAILED
  COMPLETE
  UNKNOWN
}

type VideoEdge {
  cursor: Cursor
  node: Video
}

type VideoIngestSession {
  backupIngestSession: BackupIngestSession
  bitrates(startedAt: Time, endedAt: Time): [StreamBitrate!]
  broadcaster: User
  frameDrops: [IngestFrameDrop!]
  framerates(startedAt: Time, endedAt: Time): [StreamFramerate!]
  id: ID!
  ingestSession: IngestSession!
  rtmpSession: RTMPSession!
  starvationEvents: [IngestStarvationEvent!]
  streamHealth: IngestStreamHealth
  transcodeSessions: [TranscodeSession!]
}

type VideoMoment {
  channel: User!
  createdAt: Time!
  description: String
  details: VideoMomentDetails
  durationMilliseconds: Int!
  id: ID!
  moments: VideoMomentConnection
  positionMilliseconds: Int!
  subDescription: String
  thumbnailURL: String
  type: VideoMomentType!
  video: Video
}

type VideoMomentConnection {
  edges: [VideoMomentEdge!]!
  pageInfo: PageInfo!
}

union VideoMomentDetails =
    GameChangeMomentDetails
  | HearthstoneMomentDetails
  | OverwatchMomentDetails
  | PUBGMomentDetails
type VideoMomentEdge {
  cursor: Cursor!
  node: VideoMoment!
}

enum VideoMomentRequestType {
  HIGHLIGHTER_SUGGESTIONS
  VIDEO_CHAPTER_MARKERS
}

enum VideoMomentType {
  STREAM_MARKER
  GAME_CHANGE
  HEARTHSTONE_VCA
  OVERWATCH_VCA
  PUBG_VCA
  VCA
}

type VideoMutedSegment {
  duration: Int!
  offset: Int!
}

type VideoMutedSegmentConnection {
  nodes: [VideoMutedSegment!]
}

type VideoMuteInfo {
  mutedSegmentConnection: VideoMutedSegmentConnection
  tracks: [FlaggedTrack!]
}

type VideoOEmbed implements OEmbed {
  authorName: String
  authorURL: String
  cacheAge: Int
  height: Int!
  html: String!
  inputURL: String!
  providerName: String
  providerURL: String
  thumbnail: ThumbnailOEmbed
  title: String
  type: String!
  version: String!
  width: Int!
}

input VideoOptions {
  includePrivate: Boolean = false
}

input VideoOverlayActivationInput {
  slot: String!
}

type VideoOverlayView implements ExtensionView {
  canLinkExternalContent: Boolean!
  viewerPath: String!
  viewerURL: String!
}

input VideoOverlayViewInput {
  viewerPath: String!
}

type VideoPlayReferrals {
  items: [AggregatedReferrals!]
  total: Int!
}

enum VideoPrivacyScope {
  PRIVATE
  PUBLIC
}

type VideoRestriction {
  productName: String!
  productTitle: String!
  reason: String!
  type: String!
}

type VideoSelfEdge {
  isRestricted: Boolean!
  viewingHistory: VideoViewingHistory
}

type VideoShelf {
  collection: Collection
  description: String
  game: Game
  id: ID!
  items: [VideoShelfItem!]
  title: String!
  type: VideoShelfType!
}

type VideoShelfConnection {
  edges: [VideoShelfEdge!]
  maxShelfCount: Int
  pageInfo: PageInfo!
  totalCount: Int!
}

type VideoShelfEdge {
  cursor: Cursor!
  node: VideoShelf
}

union VideoShelfItem = Clip | Video
enum VideoShelfType {
  LATEST_BROADCASTS
  LATEST_NON_BROADCASTS
  TOP_CLIPS
  SHORT_VIDEOS
  LONG_VIDEOS
  GAME
  COLLECTION
  ALL_VIDEOS
}

enum VideoSort {
  TIME
  TIME_ASC
  VIEWS
}

enum VideoStatus {
  RECORDING
  UNPROCESSED
  CREATED
  UPLOADING
  PENDING_TRANSCODE
  TRANSCODING
  FAILED
  RECORDED
}

type VideoStreamSettings {
  authorizedUsers: [User!]
  backupStreamKeys: [StreamKeyResult!]!
  delaySeconds: Int!
  disconnectSlateDurationSeconds: Int!
  isBackupEnabled: Boolean!
  isDelayEnabled: Boolean!
  isDisconnectSlateEnabled: Boolean!
  isLowLatency: Boolean!
  shouldArchiveVODs: Boolean!
  streamKey: StreamKeyResult!
}

type VideoSuggestedHighlight {
  isDismissed: Boolean!
  segments: [VideoSuggestedSegment]!
  status: SegmentsStatusType
}

type VideoSuggestedSegment {
  endMS: Int!
  startMS: Int!
}

input VideoTopClipsInput {
  curatorID: ID
  period: ClipsPeriod = LAST_WEEK
  sort: ClipsSort = VIEWS_DESC
}

enum VideoType {
  LIVE
  VOD
}

type VideoViewingHistory {
  position: Int
  updatedAt: Time
}

type ViewedNotificationsPayload {
  user: User
}

type ViewedVideosConnection {
  edges: [ViewedVideosEdge]
}

type ViewedVideosEdge {
  history: VideoViewingHistory!
  node: Video!
}

type VIPConnection {
  edges: [VIPEdge!]!
  pageInfo: PageInfo!
}

type VIPEdge {
  cursor: Cursor!
  grantedAt: Time!
  node: User
}

enum Visibility {
  ONLINE
  AWAY
  BUSY
  OFFLINE
}

enum VisibilityInput {
  ONLINE
  AWAY
  BUSY
  OFFLINE
}

input VisitStreamManagerInput {
  channelID: ID!
}

type VisitStreamManagerPayload {
  channelID: ID
  isSuccess: Boolean
  viewerID: ID
}

type VoteInAdPollError {
  code: VoteInAdPollErrorCode!
}

enum VoteInAdPollErrorCode {
  POLL_NOT_FOUND
  POLL_NOT_ACTIVE
  VOTE_ID_CONFLICT
  MAX_VOTE_LIMIT_ERROR
  MULTI_CHOICE_VOTE_FORBIDDEN
  INVALID_CHOICE_ID
  UNKNOWN
}

input VoteInAdPollInput {
  choiceID: ID!
  pollID: ID!
  userID: ID!
  voteID: ID!
}

type VoteInAdPollPayload {
  error: VoteInAdPollError
  vote: AdPollVote
}

input VoteInPollByChoiceIndexInput {
  channelID: ID!
  choiceIndex: Int!
  tokens: PollVoteTokensInput
  userID: ID!
  voteID: ID!
}

type VoteInPollByChoiceIndexPayload {
  error: VoteInPollError
  voter: PollVoter
}

type VoteInPollError {
  code: VoteInPollErrorCode!
}

enum VoteInPollErrorCode {
  POLL_NOT_FOUND
  POLL_NOT_ACTIVE
  VOTE_ID_CONFLICT
  MULTI_CHOICE_VOTE_FORBIDDEN
  INVALID_CHANNEL_ID
  INVALID_CHOICE_INDEX
  INVALID_CHOICE_ID
  INVALID_BITS_AMOUNT
  INVALID_COMMUNITY_POINTS_AMOUNT
  INSUFFICIENT_BITS_BALANCE
  INSUFFICIENT_COMMUNITY_POINTS_BALANCE
  TOKENS_REQUIRED
  USER_FORBIDDEN
  SELF_BITS_VOTE_NOT_ALLOWED
  RATE_LIMITED
  UNKNOWN
}

input VoteInPollInput {
  choiceID: ID!
  pollID: ID!
  tokens: PollVoteTokensInput
  userID: ID!
  voteID: ID!
}

type VoteInPollPayload {
  error: VoteInPollError
  voter: PollVoter
}

type WalletBalances {
  allBalances: [Balance!]
  eligibleCurrencies: [Currency!]
}

enum WalletType {
  GIFT_CARD
}

type Watching implements Activity {
  type: ActivityType
  user: User
}

enum WatchPartiesRestriction {
  REGION_NOT_SUPPORTED
  UNKNOWN
}

type WatchParty {
  contentRestriction: WatchPartyContentRestriction!
  decoration: WatchPartyDecoration
  gti: ID! @deprecated(reason: "Use decoration.item.id")
  id: ID!
  progress: WatchPartyProgress
  state: WatchPartyState!
  title: String!
  viewersCount: Int!
}

enum WatchPartyContentRestriction {
  UNKNOWN
  BROAD_AVAILABILITY
  LIMITED_AVAILABILITY
}

type WatchPartyDecoration {
  item: WatchPartyItem!
  player: WatchPartyPlayer
}

type WatchPartyError {
  code: WatchPartyErrorCode!
}

enum WatchPartyErrorCode {
  BAD_REQUEST
  FORBIDDEN
  REQUEST_THROTTLED
  GEO_RESTRICTED
  UNKNOWN
}

type WatchPartyItem {
  contentRating: String
  contentRestriction: WatchPartyContentRestriction!
  details: WatchPartyItemDetails
  genres: [String!]!
  hasChildren: Boolean!
  id: ID!
  isMature: Boolean!
  parentID: ID
  primeVideoLink: String
  primeVideoRating: PrimeVideoRating
  self: WatchPartyItemSelfEdge
  starring: [String!]!
  summary: String
  thumbnailURL: String!
  title: String!
  type: WatchPartyItemType!
  yearPublished: Int
  isParentalControlRestricted: Boolean
}

type WatchPartyItemConnection {
  edges: [WatchPartyItemEdge!]!
  error: WatchPartyError
  homepageBrowseLink: String!
  pageInfo: PageInfo!
}

union WatchPartyItemDetails =
    EpisodeDetails
  | MovieDetails
  | SeasonDetails
  | SeriesDetails
type WatchPartyItemEdge {
  cursor: Cursor!
  node: WatchPartyItem!
}

type WatchPartyItemEligibility {
  canView: Boolean!
  reason: String
}

input WatchPartyItemSearchOptions {
  parentID: ID
  searchQuery: String
}

type WatchPartyItemSelfEdge {
  eligibility: WatchPartyItemEligibility!
  willShowPrimeUpsell: Boolean!
}

enum WatchPartyItemType {
  UNKNOWN
  EPISODE
  MOVIE
  SEASON
  SERIES
}

type WatchPartyPlayer {
  deviceProxyBaseURL: String!
  sdkInit: String!
  token: String!
}

type WatchPartyProgress {
  durationSeconds: Int!
  positionSeconds: Int!
  start: Time!
}

type WatchPartyResult {
  error: WatchPartyError
  session: WatchParty
}

enum WatchPartyState {
  UNKNOWN
  HYPE_IN
  IN_PROGRESS
  OFFLINE
}

type WhisperMessage {
  content: MessageBody!
  deletedAt: Time
  editedAt: Time
  from: User!
  id: ID!
  nonce: String
  sentAt: Time!
  thread: WhisperThread!
}

type WhisperMessageConnection {
  edges: [WhisperMessageEdge!]!
  pageInfo: PageInfo!
}

type WhisperMessageEdge {
  cursor: Cursor!
  node: WhisperMessage!
}

type WhisperPermissions {
  isStrangerBlocked: Boolean!
  receive: WhisperPermissionType
  send: WhisperPermissionType
}

enum WhisperPermissionType {
  PERMITTED
  NOT_PERMITTED
  NOT_RESTRICTED
  TEMPORARY
}

type WhisperSettings {
  isBlockingWhispersFromStrangers: Boolean!
  isWhisperBanned: Boolean!
}

type WhisperSpamInfo {
  lastMarkedNotSpamAt: Time
  likelihood: WhisperSpamLikelihood
}

enum WhisperSpamLikelihood {
  LOW
  MEDIUM
  HIGH
}

type WhisperThread {
  id: ID!
  isArchived: Boolean!
  isMuted: Boolean!
  lastMessage: WhisperMessage
  messages(first: Int = 10, after: Cursor): WhisperMessageConnection
  participants: [User]!
  spamInfo: WhisperSpamInfo
  unreadMessagesCount: Int!
  userLastMessageRead: WhisperMessage
    @deprecated(reason: "Not used. Use lastMessage to get the last message. ")
  whitelistedUntil: Time
}

type WhisperThreadConnection {
  edges: [WhisperThreadEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
  totalUnreadCount: Int
}

type WhisperThreadEdge {
  cursor: Cursor!
  node: WhisperThread!
}

type WithholdingTaxDetail {
  royaltyTaxRate: Float!
  serviceTaxRate: Float!
}

type Xsolla {
  iframeURL: String!
    @deprecated(reason: "moving iframe URL generation client-side")
  isSandbox: Boolean!
  token: String!
  ineligibilityReason: XsollaIneligibilityReason
}

type XsollaConfigs {
  iframeURL: String!
    @deprecated(reason: "Moving iframe URL generation to Twilight")
  token: String!
  isSandbox: Boolean!
}

enum XsollaIneligibilityReason {
  UNKNOWN
  BLOCK_PURCHASE
}

type ZuoraConfigs {
  externalAccountID: ID!
  hostedPageID: ID!
  hostedPageURL: String!
  publicKey: String!
  signature: String!
  tenantID: ID!
  token: String!
}

